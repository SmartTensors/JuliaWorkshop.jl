\documentclass[11pt]{article}

    \usepackage[breakable]{tcolorbox}
    \usepackage{parskip} % Stop auto-indenting (to mimic markdown behaviour)
    
    \usepackage{iftex}
    \ifPDFTeX
    	\usepackage[T1]{fontenc}
    	\usepackage{mathpazo}
    \else
    	\usepackage{fontspec}
    \fi

    % Basic figure setup, for now with no caption control since it's done
    % automatically by Pandoc (which extracts ![](path) syntax from Markdown).
    \usepackage{graphicx}
    % Maintain compatibility with old templates. Remove in nbconvert 6.0
    \let\Oldincludegraphics\includegraphics
    % Ensure that by default, figures have no caption (until we provide a
    % proper Figure object with a Caption API and a way to capture that
    % in the conversion process - todo).
    \usepackage{caption}
    \DeclareCaptionFormat{nocaption}{}
    \captionsetup{format=nocaption,aboveskip=0pt,belowskip=0pt}

    \usepackage{float}
    \floatplacement{figure}{H} % forces figures to be placed at the correct location
    \usepackage{xcolor} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage{textcomp} % defines textquotesingle
    % Hack from http://tex.stackexchange.com/a/47451/13684:
    \AtBeginDocument{%
        \def\PYZsq{\textquotesingle}% Upright quotes in Pygmentized code
    }
    \usepackage{upquote} % Upright quotes for verbatim code
    \usepackage{eurosym} % defines \euro
    \usepackage[mathletters]{ucs} % Extended unicode (utf-8) support
    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics 
                         % to support a larger range
    \makeatletter % fix for old versions of grffile with XeLaTeX
    \@ifpackagelater{grffile}{2019/11/01}
    {
      % Do nothing on new versions
    }
    {
      \def\Gread@@xetex#1{%
        \IfFileExists{"\Gin@base".bb}%
        {\Gread@eps{\Gin@base.bb}}%
        {\Gread@@xetex@aux#1}%
      }
    }
    \makeatother
    \usepackage[Export]{adjustbox} % Used to constrain images to a maximum size
    \adjustboxset{max size={0.9\linewidth}{0.9\paperheight}}

    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    % The default LaTeX title has an obnoxious amount of whitespace. By default,
    % titling removes some of it. It also provides customization options.
    \usepackage{titling}
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    \usepackage[inline]{enumitem} % IRkernel/repr support (it uses the enumerate* environment)
    \usepackage[normalem]{ulem} % ulem is needed to support strikethroughs (\sout)
                                % normalem makes italics be italics, not underlines
    \usepackage{mathrsfs}
    

    
    % Colors for the hyperref package
    \definecolor{urlcolor}{rgb}{0,.145,.698}
    \definecolor{linkcolor}{rgb}{.71,0.21,0.01}
    \definecolor{citecolor}{rgb}{.12,.54,.11}

    % ANSI colors
    \definecolor{ansi-black}{HTML}{3E424D}
    \definecolor{ansi-black-intense}{HTML}{282C36}
    \definecolor{ansi-red}{HTML}{E75C58}
    \definecolor{ansi-red-intense}{HTML}{B22B31}
    \definecolor{ansi-green}{HTML}{00A250}
    \definecolor{ansi-green-intense}{HTML}{007427}
    \definecolor{ansi-yellow}{HTML}{DDB62B}
    \definecolor{ansi-yellow-intense}{HTML}{B27D12}
    \definecolor{ansi-blue}{HTML}{208FFB}
    \definecolor{ansi-blue-intense}{HTML}{0065CA}
    \definecolor{ansi-magenta}{HTML}{D160C4}
    \definecolor{ansi-magenta-intense}{HTML}{A03196}
    \definecolor{ansi-cyan}{HTML}{60C6C8}
    \definecolor{ansi-cyan-intense}{HTML}{258F8F}
    \definecolor{ansi-white}{HTML}{C5C1B4}
    \definecolor{ansi-white-intense}{HTML}{A1A6B2}
    \definecolor{ansi-default-inverse-fg}{HTML}{FFFFFF}
    \definecolor{ansi-default-inverse-bg}{HTML}{000000}

    % common color for the border for error outputs.
    \definecolor{outerrorbackground}{HTML}{FFDFDF}

    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \providecommand{\tightlist}{%
      \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}
    
    % Additional commands for more recent versions of Pandoc
    \newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
    \newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
    \newcommand{\ImportTok}[1]{{#1}}
    \newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
    \newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
    \newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
    \newcommand{\BuiltInTok}[1]{{#1}}
    \newcommand{\ExtensionTok}[1]{{#1}}
    \newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
    \newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
    \newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    
    
    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatibility definitions
    \def\gt{>}
    \def\lt{<}
    \let\Oldtex\TeX
    \let\Oldlatex\LaTeX
    \renewcommand{\TeX}{\textrm{\Oldtex}}
    \renewcommand{\LaTeX}{\textrm{\Oldlatex}}
    % Document parameters
    % Document title
    \title{Julia\_vs\_Python}
    
    
    
    
    
% Pygments definitions
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\@namedef{PY@tok@w}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\@namedef{PY@tok@c}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\@namedef{PY@tok@cp}{\def\PY@tc##1{\textcolor[rgb]{0.74,0.48,0.00}{##1}}}
\@namedef{PY@tok@k}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kp}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kt}{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\@namedef{PY@tok@o}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@ow}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\@namedef{PY@tok@nb}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@nf}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@nc}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@nn}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@ne}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.82,0.25,0.23}{##1}}}
\@namedef{PY@tok@nv}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@no}{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\@namedef{PY@tok@nl}{\def\PY@tc##1{\textcolor[rgb]{0.63,0.63,0.00}{##1}}}
\@namedef{PY@tok@ni}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}
\@namedef{PY@tok@na}{\def\PY@tc##1{\textcolor[rgb]{0.49,0.56,0.16}{##1}}}
\@namedef{PY@tok@nt}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@nd}{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\@namedef{PY@tok@s}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sd}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@si}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\@namedef{PY@tok@se}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.13}{##1}}}
\@namedef{PY@tok@sr}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\@namedef{PY@tok@ss}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@sx}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@m}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@gh}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\@namedef{PY@tok@gu}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\@namedef{PY@tok@gd}{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\@namedef{PY@tok@gi}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\@namedef{PY@tok@gr}{\def\PY@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\@namedef{PY@tok@ge}{\let\PY@it=\textit}
\@namedef{PY@tok@gs}{\let\PY@bf=\textbf}
\@namedef{PY@tok@gp}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\@namedef{PY@tok@go}{\def\PY@tc##1{\textcolor[rgb]{0.53,0.53,0.53}{##1}}}
\@namedef{PY@tok@gt}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\@namedef{PY@tok@err}{\def\PY@bc##1{{\setlength{\fboxsep}{\string -\fboxrule}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}}
\@namedef{PY@tok@kc}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kd}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kn}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kr}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@bp}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@fm}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@vc}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vg}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vi}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vm}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@sa}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sb}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sc}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@dl}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@s2}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sh}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@s1}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@mb}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mf}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mh}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mi}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@il}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mo}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@ch}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\@namedef{PY@tok@cm}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\@namedef{PY@tok@cpf}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\@namedef{PY@tok@c1}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\@namedef{PY@tok@cs}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % For linebreaks inside Verbatim environment from package fancyvrb. 
    \makeatletter
        \newbox\Wrappedcontinuationbox 
        \newbox\Wrappedvisiblespacebox 
        \newcommand*\Wrappedvisiblespace {\textcolor{red}{\textvisiblespace}} 
        \newcommand*\Wrappedcontinuationsymbol {\textcolor{red}{\llap{\tiny$\m@th\hookrightarrow$}}} 
        \newcommand*\Wrappedcontinuationindent {3ex } 
        \newcommand*\Wrappedafterbreak {\kern\Wrappedcontinuationindent\copy\Wrappedcontinuationbox} 
        % Take advantage of the already applied Pygments mark-up to insert 
        % potential linebreaks for TeX processing. 
        %        {, <, #, %, $, ' and ": go to next line. 
        %        _, }, ^, &, >, - and ~: stay at end of broken line. 
        % Use of \textquotesingle for straight quote. 
        \newcommand*\Wrappedbreaksatspecials {% 
            \def\PYGZus{\discretionary{\char`\_}{\Wrappedafterbreak}{\char`\_}}% 
            \def\PYGZob{\discretionary{}{\Wrappedafterbreak\char`\{}{\char`\{}}% 
            \def\PYGZcb{\discretionary{\char`\}}{\Wrappedafterbreak}{\char`\}}}% 
            \def\PYGZca{\discretionary{\char`\^}{\Wrappedafterbreak}{\char`\^}}% 
            \def\PYGZam{\discretionary{\char`\&}{\Wrappedafterbreak}{\char`\&}}% 
            \def\PYGZlt{\discretionary{}{\Wrappedafterbreak\char`\<}{\char`\<}}% 
            \def\PYGZgt{\discretionary{\char`\>}{\Wrappedafterbreak}{\char`\>}}% 
            \def\PYGZsh{\discretionary{}{\Wrappedafterbreak\char`\#}{\char`\#}}% 
            \def\PYGZpc{\discretionary{}{\Wrappedafterbreak\char`\%}{\char`\%}}% 
            \def\PYGZdl{\discretionary{}{\Wrappedafterbreak\char`\$}{\char`\$}}% 
            \def\PYGZhy{\discretionary{\char`\-}{\Wrappedafterbreak}{\char`\-}}% 
            \def\PYGZsq{\discretionary{}{\Wrappedafterbreak\textquotesingle}{\textquotesingle}}% 
            \def\PYGZdq{\discretionary{}{\Wrappedafterbreak\char`\"}{\char`\"}}% 
            \def\PYGZti{\discretionary{\char`\~}{\Wrappedafterbreak}{\char`\~}}% 
        } 
        % Some characters . , ; ? ! / are not pygmentized. 
        % This macro makes them "active" and they will insert potential linebreaks 
        \newcommand*\Wrappedbreaksatpunct {% 
            \lccode`\~`\.\lowercase{\def~}{\discretionary{\hbox{\char`\.}}{\Wrappedafterbreak}{\hbox{\char`\.}}}% 
            \lccode`\~`\,\lowercase{\def~}{\discretionary{\hbox{\char`\,}}{\Wrappedafterbreak}{\hbox{\char`\,}}}% 
            \lccode`\~`\;\lowercase{\def~}{\discretionary{\hbox{\char`\;}}{\Wrappedafterbreak}{\hbox{\char`\;}}}% 
            \lccode`\~`\:\lowercase{\def~}{\discretionary{\hbox{\char`\:}}{\Wrappedafterbreak}{\hbox{\char`\:}}}% 
            \lccode`\~`\?\lowercase{\def~}{\discretionary{\hbox{\char`\?}}{\Wrappedafterbreak}{\hbox{\char`\?}}}% 
            \lccode`\~`\!\lowercase{\def~}{\discretionary{\hbox{\char`\!}}{\Wrappedafterbreak}{\hbox{\char`\!}}}% 
            \lccode`\~`\/\lowercase{\def~}{\discretionary{\hbox{\char`\/}}{\Wrappedafterbreak}{\hbox{\char`\/}}}% 
            \catcode`\.\active
            \catcode`\,\active 
            \catcode`\;\active
            \catcode`\:\active
            \catcode`\?\active
            \catcode`\!\active
            \catcode`\/\active 
            \lccode`\~`\~ 	
        }
    \makeatother

    \let\OriginalVerbatim=\Verbatim
    \makeatletter
    \renewcommand{\Verbatim}[1][1]{%
        %\parskip\z@skip
        \sbox\Wrappedcontinuationbox {\Wrappedcontinuationsymbol}%
        \sbox\Wrappedvisiblespacebox {\FV@SetupFont\Wrappedvisiblespace}%
        \def\FancyVerbFormatLine ##1{\hsize\linewidth
            \vtop{\raggedright\hyphenpenalty\z@\exhyphenpenalty\z@
                \doublehyphendemerits\z@\finalhyphendemerits\z@
                \strut ##1\strut}%
        }%
        % If the linebreak is at a space, the latter will be displayed as visible
        % space at end of first line, and a continuation symbol starts next line.
        % Stretch/shrink are however usually zero for typewriter font.
        \def\FV@Space {%
            \nobreak\hskip\z@ plus\fontdimen3\font minus\fontdimen4\font
            \discretionary{\copy\Wrappedvisiblespacebox}{\Wrappedafterbreak}
            {\kern\fontdimen2\font}%
        }%
        
        % Allow breaks at special characters using \PYG... macros.
        \Wrappedbreaksatspecials
        % Breaks at punctuation characters . , ; ? ! and / need catcode=\active 	
        \OriginalVerbatim[#1,codes*=\Wrappedbreaksatpunct]%
    }
    \makeatother

    % Exact colors from NB
    \definecolor{incolor}{HTML}{303F9F}
    \definecolor{outcolor}{HTML}{D84315}
    \definecolor{cellborder}{HTML}{CFCFCF}
    \definecolor{cellbackground}{HTML}{F7F7F7}
    
    % prompt
    \makeatletter
    \newcommand{\boxspacing}{\kern\kvtcb@left@rule\kern\kvtcb@boxsep}
    \makeatother
    \newcommand{\prompt}[4]{
        {\ttfamily\llap{{\color{#2}[#3]:\hspace{3pt}#4}}\vspace{-\baselineskip}}
    }
    

    
    % Prevent overflowing lines due to hard-to-break entities
    \sloppy 
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=urlcolor,
      linkcolor=linkcolor,
      citecolor=citecolor,
      }
    % Slightly bigger margins than the latex defaults
    
    \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
    
    

\begin{document}
    
    \maketitle
    
    

    
    \hypertarget{for-pythonistas}{%
\section{\texorpdfstring{ \emph{for
Pythonistas}}{ for Pythonistas}}\label{for-pythonistas}}

Julia looks and feels a lot like MATLAB and Python! Only much, much
faster.

It is dynamic, expressive, extensible.

It is particularly designed for Data Science and Machine Learning.

    \hypertarget{julia-repl}{%
\section{Julia REPL}\label{julia-repl}}

Julia REPL (read-eval-print loop) allows us to: * write scripts *
execute scripts * evaluate variables, experessions and functions * get
help * manage Julia packages (modules) and installations * access OS
sheell

    \hypertarget{julia-help}{%
\section{Julia Help}\label{julia-help}}

To get help on any module, function, variable, or just about anything
else, just type \texttt{?} followed by what you're interested in.

For example, here is the help for the exponent function (\texttt{?exp}).

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{1}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{o}{?}\PY{n}{exp}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
search: \textbf{e}\textbf{x}\textbf{p}
\textbf{e}\textbf{x}\textbf{p}2
\textbf{E}\textbf{x}\textbf{p}r
\textbf{e}\textbf{x}\textbf{p}m1
\textbf{e}\textbf{x}\textbf{p}10
\textbf{e}\textbf{x}\textbf{p}\_a
\textbf{e}\textbf{x}\textbf{p}ort
\textbf{e}\textbf{x}\textbf{p}onent
\textbf{e}\textbf{x}\textbf{p}anduser

    \end{Verbatim}
 
            
\prompt{Out}{outcolor}{1}{}
    
    \begin{verbatim}
exp(x)
\end{verbatim}
Compute the natural base exponential of \texttt{x}, in other words $e^x$.

\section{Examples}
\begin{verbatim}
julia> exp(1.0)
2.718281828459045
\end{verbatim}
\rule{\textwidth}{1pt}
\begin{verbatim}
exp(A::AbstractMatrix)
\end{verbatim}
Compute the matrix exponential of \texttt{A}, defined by

$$e^A = \sum_{n=0}^{\infty} \frac{A^n}{n!}.$$
For symmetric or Hermitian \texttt{A}, an eigendecomposition (\href{@ref}{\texttt{eigen}}) is used, otherwise the scaling and squaring algorithm (see \footnotemark[H05]) is chosen.

\footnotetext[H05]{Nicholas J. Higham, "The squaring and scaling method for the matrix exponential revisited", SIAM Journal on Matrix Analysis and Applications, 26(4), 2005, 1179-1193. \href{https://doi.org/10.1137/090768539}{doi:10.1137/090768539}

}
\section{Examples}
\begin{verbatim}
julia> A = Matrix(1.0I, 2, 2)
2×2 Matrix{Float64}:
 1.0  0.0
 0.0  1.0

julia> exp(A)
2×2 Matrix{Float64}:
 2.71828  0.0
 0.0      2.71828
\end{verbatim}


    

    Using \texttt{?} to switch to help mode works in interactive mode only
(in Jupyter and in the Julia REPL).

    Here are other ways to get help and inspect objects in interactive mode:

\begin{longtable}[]{@{}ll@{}}
\toprule
Julia & Python \\
\midrule
\endhead
\texttt{?obj} & \texttt{help(obj)} \\
\texttt{dump(obj)} & \texttt{print(repr(obj))} \\
\texttt{names(FooModule)} & \texttt{dir(foo\_module)} \\
\texttt{methodswith(SomeType)} & \texttt{dir(SomeType)} \\
\texttt{@which\ func} & \texttt{func.\_\_module\_\_} \\
\texttt{apropos("bar")} & Search for \texttt{"bar"} in docstrings of all
installed packages \\
\texttt{typeof(obj)} & \texttt{type(obj)} \\
\texttt{obj\ isa\ SomeType}or\texttt{isa(obj,\ SomeType)} &
\texttt{isinstance(obj,\ SomeType)} \\
\bottomrule
\end{longtable}

    \hypertarget{simple-first-steps}{%
\section{Simple first steps}\label{simple-first-steps}}

    \hypertarget{estimating-ux3c0}{%
\subsection{Estimating π}\label{estimating-ux3c0}}

Let's write our first function.

It will estimate π using the equation:

\(π = 4 \times \left(1 - \dfrac{1}{3} + \dfrac{1}{5} - \dfrac{1}{7} + \dfrac{1}{9}-\dfrac{1}{11}+\dots\right)\)

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{2}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{function} \PY{n}{estimate\PYZus{}pi}\PY{p}{(}\PY{n}{n}\PY{p}{)}
    \PY{n}{s} \PY{o}{=} \PY{l+m+mf}{1.0}
    \PY{k}{for} \PY{n}{i} \PY{k}{in} \PY{l+m+mi}{1}\PY{o}{:}\PY{n}{n}
        \PY{n}{s} \PY{o}{+=} \PY{p}{(}\PY{n}{isodd}\PY{p}{(}\PY{n}{i}\PY{p}{)} \PY{o}{?} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1} \PY{o}{:} \PY{l+m+mi}{1}\PY{p}{)} \PY{o}{/} \PY{p}{(}\PY{l+m+mi}{2}\PY{n}{i} \PY{o}{+} \PY{l+m+mi}{1}\PY{p}{)}
    \PY{k}{end}
    \PY{l+m+mi}{4}\PY{n}{s} \PY{c}{\PYZsh{} or return 4s}
\PY{k}{end}

\PY{n}{p} \PY{o}{=} \PY{n}{estimate\PYZus{}pi}\PY{p}{(}\PY{l+m+mi}{100\PYZus{}000\PYZus{}000}\PY{p}{)}
\PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{π ≈ }\PY{l+s+si}{\PYZdl{}p}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Error is }\PY{l+s+si}{\PYZdl{}}\PY{p}{(}\PY{n}{p} \PY{o}{\PYZhy{}} \PY{n+nb}{π}\PY{p}{)}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
π ≈ 3.141592663589326
Error is 9.999532757376528e-9
    \end{Verbatim}

    Compare this with the equivalent Python 3 code:

    \begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# PYTHON}
\ImportTok{import}\NormalTok{ math}

\KeywordTok{def}\NormalTok{ estimate\_pi(n):}
\NormalTok{    s }\OperatorTok{=} \FloatTok{1.0}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, n }\OperatorTok{+} \DecValTok{1}\NormalTok{):}
\NormalTok{        s }\OperatorTok{+=}\NormalTok{ (}\OperatorTok{{-}}\DecValTok{1} \ControlFlowTok{if}\NormalTok{ i }\OperatorTok{\%} \DecValTok{2} \ControlFlowTok{else} \DecValTok{1}\NormalTok{) }\OperatorTok{/}\NormalTok{ (}\DecValTok{2} \OperatorTok{*}\NormalTok{ i }\OperatorTok{+} \DecValTok{1}\NormalTok{)}
    \ControlFlowTok{return} \DecValTok{4} \OperatorTok{*}\NormalTok{ s}

\NormalTok{p }\OperatorTok{=}\NormalTok{ estimate\_pi(}\DecValTok{100\_000\_000}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"π ≈ }\SpecialCharTok{\{p\}}\SpecialStringTok{"}\NormalTok{) }\CommentTok{\# f{-}strings are available in Python 3.6+}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Error is }\SpecialCharTok{\{p} \OperatorTok{{-}}\NormalTok{ math}\SpecialCharTok{.pi\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

    Similar, but notice the small differences:

\begin{longtable}[]{@{}ll@{}}
\toprule
Julia & Python \\
\midrule
\endhead
\texttt{function} & \texttt{def} \\
\texttt{for\ i\ in\ X}~~~~\texttt{...}\texttt{end} &
\texttt{for\ i\ in\ X:}~~~~\texttt{...} \\
\texttt{1:n} & \texttt{range(1,\ n+1)} \\
\texttt{cond\ ?\ a\ :\ b} & \texttt{a\ if\ cond\ else\ b} \\
\texttt{2i\ +\ 1} & \texttt{2\ *\ i\ +\ 1} \\
\texttt{4s} & \texttt{return\ 4\ *\ s} \\
\texttt{println(a,\ b)} & \texttt{print(a,\ b,\ sep="")} \\
\texttt{print(a,\ b)} & \texttt{print(a,\ b,\ sep="",\ end="")} \\
\texttt{"\$p"} & \texttt{f"\{p\}"} \\
\texttt{"\$(p\ -\ π)"} & \texttt{f"\{p\ -\ math.pi\}"} \\
\bottomrule
\end{longtable}

This example shows that: * Julia can be just as concise and readable as
Python. * Indentation in Julia does not define the code structure like
it is in Python. Instead, blocks end with \texttt{end}. * Many math
features are built in Julia and do not need to be imported imports. * In
Julia you can use mathy syntactic sugar, such as \texttt{2i} and
\texttt{4s} (but you can write \texttt{2\ *\ i} and \texttt{4\ *\ s} if
you prefer). * In Julia, the \texttt{return} keyword is optional at the
end of a function. The result of the last expression is returned
(\texttt{4s} in this example). * Julia does not hesitate to use Unicode
characters like \texttt{π}. However, there are generally plain-ASCII
equivalents (e.g., \texttt{π\ ==\ pi}).

    \hypertarget{import-vs.-using-julia-modules}{%
\subsection{Import vs.~using Julia
modules}\label{import-vs.-using-julia-modules}}

\texttt{import} is more general and mode flexible.

\texttt{import} is especilly conviniet when running Julia in parallel
(see the \texttt{Parallelization} notebook).

\texttt{import} also make the Julia code more readable. You will know
explictly the called methods from which module are coming.

\texttt{using} makes the code more compact but less readable and
explicit.

    In Julia, \texttt{import\ Foo.Bar:\ a,\ b} corresponds to running
\texttt{from\ foo.bar\ import\ a,\ b} in Python.

\begin{longtable}[]{@{}ll@{}}
\toprule
Julia & Python \\
\midrule
\endhead
\texttt{import\ Foo} & \texttt{from\ foo\ import\ *;\ import\ foo} \\
\texttt{import\ Foo.Bar} &
\texttt{from\ foo.bar\ import\ *;\ from\ foo\ import\ bar} \\
\texttt{import\ Foo.Bar:\ a,\ b} &
\texttt{from\ foo.bar\ import\ a,\ b} \\
\texttt{import\ Foo:\ Bar} & \texttt{from\ foo\ import\ bar} \\
\bottomrule
\end{longtable}

    \hypertarget{running-python-code-in-julia}{%
\subsection{Running Python code in
Julia}\label{running-python-code-in-julia}}

Julia lets you easily run Python code using the \texttt{PyCall} module.
We installed it earlier, so we just need to import it:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{3}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{import} \PY{n}{PyCall}
\end{Verbatim}
\end{tcolorbox}

    Now that we have imported \texttt{PyCall}, we can use the
\texttt{PyCall.pyimport()} function to import a Python module directly
in Julia.

For example, let's check which Python version we are using:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{4}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{sys} \PY{o}{=} \PY{n}{PyCall}\PY{o}{.}\PY{n}{pyimport}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{sys}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{n}{sys}\PY{o}{.}\PY{n}{version}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{4}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
"3.8.5 (default, Sep  4 2020, 02:23:17) \textbackslash{}n[Clang 10.0.0 ]"
\end{Verbatim}
\end{tcolorbox}
        
    In fact, let's run the Python code we discussed earlier (this will take
about 15 seconds to run, because Python is so slow\ldots):

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{5}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{PyCall}\PY{o}{.}\PY{l+s+sa}{py}\PY{l+s}{\PYZdq{}\PYZdq{}\PYZdq{}}
\PY{l+s}{import math}
\PY{l+s}{ }
\PY{l+s}{def estimate\PYZus{}pi(n):}
\PY{l+s}{    s = 1.0}
\PY{l+s}{    for i in range(1, n + 1):}
\PY{l+s}{        s += (\PYZhy{}1 if i }\PY{l+s}{\PYZpc{}}\PY{l+s}{ 2 else 1) / (2 * i + 1)}
\PY{l+s}{    return 4 * s}
\PY{l+s}{ }
\PY{l+s}{p = estimate\PYZus{}pi(100\PYZus{}000\PYZus{}000)}
\PY{l+s}{print(f}\PY{l+s}{\PYZdq{}}\PY{l+s}{π ≈ \PYZob{}p\PYZcb{}}\PY{l+s}{\PYZdq{}}\PY{l+s}{) \PYZsh{} f\PYZhy{}strings are available in Python 3.6+}
\PY{l+s}{print(f}\PY{l+s}{\PYZdq{}}\PY{l+s}{Error is \PYZob{}p \PYZhy{} math.pi\PYZcb{}}\PY{l+s}{\PYZdq{}}\PY{l+s}{)}
\PY{l+s}{\PYZdq{}\PYZdq{}\PYZdq{}}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
π ≈ 3.141592663589326
Error is 9.999532757376528e-09
    \end{Verbatim}

    As you can see, running arbitrary Python code is as simple as using
py-strings (\texttt{PyCall.py"..."}).

Note that py-strings are not part of the Julia language itself: they are
defined by the \texttt{PyCall} module (we will see how this works
later).

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{6}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{PyCall}\PY{o}{.}\PY{l+s+sa}{py}\PY{l+s}{\PYZdq{}}\PY{l+s}{p}\PY{l+s}{\PYZdq{}}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{6}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
3.141592663589326
\end{Verbatim}
\end{tcolorbox}
        
    Let's compare this to the value we calculated above using Julia:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{7}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{PyCall}\PY{o}{.}\PY{l+s+sa}{py}\PY{l+s}{\PYZdq{}}\PY{l+s}{p}\PY{l+s}{\PYZdq{}} \PY{o}{\PYZhy{}} \PY{n}{p}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{7}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
0.0
\end{Verbatim}
\end{tcolorbox}
        
    Perfect, they are exactly equal!

As you can see, it's very easy to mix Julia and Python code. So if
there's a module you really love in Python, you can keep using it as
long as you want! For example, let's use NumPy:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{8}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{np} \PY{o}{=} \PY{n}{PyCall}\PY{o}{.}\PY{n}{pyimport}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{numpy}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{n}{a} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{rand}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{8}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
2×3 Matrix\{Float64\}:
 0.997556  0.642777    0.134838
 0.434044  0.00266033  0.365324
\end{Verbatim}
\end{tcolorbox}
        
    Notice that \texttt{PyCall} automatically converts some Python types to
Julia types, including NumPy arrays. That's really quite convenient!
Note that Julia supports multi-dimensional arrays (analog to NumPy
arrays) out of the box. \texttt{Array\{Float64,\ 2\}} means that it's a
2-dimensional array of 64-bit floats.

\texttt{PyCall} also converts Julia arrays to NumPy arrays when needed:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{9}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{exp\PYZus{}a} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{exp}\PY{p}{(}\PY{n}{a}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{9}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
2×3 Matrix\{Float64\}:
 2.71165  1.90175  1.14435
 1.54349  1.00266  1.44098
\end{Verbatim}
\end{tcolorbox}
        
    If you want to use some Julia variable in a py-string, for example
\texttt{exp\_a}, you can do so by writing \texttt{\$exp\_a} like this:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{10}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{PyCall}\PY{o}{.}\PY{l+s+sa}{py}\PY{l+s}{\PYZdq{}\PYZdq{}\PYZdq{}}
\PY{l+s}{import numpy as np}

\PY{l+s}{result = np.log(}\PY{l+s+si}{\PYZdl{}exp\PYZus{}a}\PY{l+s}{)}
\PY{l+s}{\PYZdq{}\PYZdq{}\PYZdq{}}

\PY{n}{PyCall}\PY{o}{.}\PY{l+s+sa}{py}\PY{l+s}{\PYZdq{}}\PY{l+s}{result}\PY{l+s}{\PYZdq{}}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{10}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
2×3 Matrix\{Float64\}:
 0.997556  0.642777    0.134838
 0.434044  0.00266033  0.365324
\end{Verbatim}
\end{tcolorbox}
        
    If you want to keep using Matplotlib, it's best to use the
\texttt{PyPlot} module (which we installed earlier), rather than trying
to use \texttt{PyCall.pyimport("matplotlib")}, as \texttt{PyPlot}
provides a more straightforward interface with Julia, and it plays
nicely with Jupyter:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{11}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{import} \PY{n}{PyPlot}

\PY{n}{x} \PY{o}{=} \PY{n}{range}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{l+m+mi}{5}\PY{n+nb}{π}\PY{p}{,} \PY{l+m+mi}{5}\PY{n+nb}{π}\PY{p}{;} \PY{n}{length}\PY{o}{=}\PY{l+m+mi}{100}\PY{p}{)}
\PY{n}{PyPlot}\PY{o}{.}\PY{n}{plt}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{x}\PY{p}{,} \PY{n}{sin}\PY{o}{.}\PY{p}{(}\PY{n}{x}\PY{p}{)} \PY{o}{./} \PY{n}{x}\PY{p}{)} \PY{c}{\PYZsh{} we\PYZsq{}ll discuss this syntax in the next section}
\PY{n}{PyPlot}\PY{o}{.}\PY{n}{plt}\PY{o}{.}\PY{n}{title}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{sin(x) / x}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{n}{PyPlot}\PY{o}{.}\PY{n}{plt}\PY{o}{.}\PY{n}{grid}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{True}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{Julia_vs_Python_files/Julia_vs_Python_31_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    That said, Julia has its own plotting libraries, such as the
\texttt{Plots} and \texttt{Gadfly} modules, which are much more powerful
convinient than matplotlib.

    Julia's \texttt{range()} function acts much like NumPy's
\texttt{linspace()} function, when you use the \texttt{length} argument.

However, it acts like Python's \texttt{range()} function when you use
the \texttt{step} argument instead (except the upper bound is
inclusive).

Julia's \texttt{range()} function returns an object which behaves just
like an array, except it doesn't actually use any RAM for its elements,
it just stores the range parameters.

If you want to collect all of the elements into an array, use the
\texttt{collect()} function (similar to Python's \texttt{list()}
function):

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{12}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{println}\PY{p}{(}\PY{n}{collect}\PY{p}{(}\PY{n}{range}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{80}\PY{p}{,} \PY{n}{step}\PY{o}{=}\PY{l+m+mi}{20}\PY{p}{)}\PY{p}{)}\PY{p}{)}
\PY{n}{println}\PY{p}{(}\PY{n}{collect}\PY{p}{(}\PY{l+m+mi}{10}\PY{o}{:}\PY{l+m+mi}{20}\PY{o}{:}\PY{l+m+mi}{80}\PY{p}{)}\PY{p}{)} \PY{c}{\PYZsh{} 10:20:80 is equivalent to the previous range}
\PY{n}{println}\PY{p}{(}\PY{n}{collect}\PY{p}{(}\PY{n}{range}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{80}\PY{p}{,} \PY{n}{length}\PY{o}{=}\PY{l+m+mi}{5}\PY{p}{)}\PY{p}{)}\PY{p}{)} \PY{c}{\PYZsh{} similar to NumPy\PYZsq{}s linspace()}
\PY{n}{step} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{80}\PY{o}{\PYZhy{}}\PY{l+m+mi}{10}\PY{p}{)}\PY{o}{/}\PY{p}{(}\PY{l+m+mi}{5}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)} \PY{c}{\PYZsh{} 17.5}
\PY{n}{println}\PY{p}{(}\PY{n}{collect}\PY{p}{(}\PY{l+m+mi}{10}\PY{o}{:}\PY{n}{step}\PY{o}{:}\PY{l+m+mi}{80}\PY{p}{)}\PY{p}{)} \PY{c}{\PYZsh{} equivalent to the previous range}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
[10, 30, 50, 70]
[10, 30, 50, 70]
[10.0, 27.5, 45.0, 62.5, 80.0]
[10.0, 27.5, 45.0, 62.5, 80.0]
    \end{Verbatim}

    The equivalent Python code is:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# PYTHON}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{80}\OperatorTok{+}\DecValTok{1}\NormalTok{, }\DecValTok{20}\NormalTok{)))}
\CommentTok{\# there\textquotesingle{}s no short{-}hand for range() in Python}
\BuiltInTok{print}\NormalTok{(np.linspace(}\DecValTok{10}\NormalTok{, }\DecValTok{80}\NormalTok{, }\DecValTok{5}\NormalTok{))}
\NormalTok{step }\OperatorTok{=}\NormalTok{ (}\DecValTok{80}\OperatorTok{{-}}\DecValTok{10}\NormalTok{)}\OperatorTok{/}\NormalTok{(}\DecValTok{5}\OperatorTok{{-}}\DecValTok{1}\NormalTok{) }\CommentTok{\# 17.5}
\BuiltInTok{print}\NormalTok{([i}\OperatorTok{*}\NormalTok{step }\OperatorTok{+} \DecValTok{10} \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{5}\NormalTok{)])}
\end{Highlighting}
\end{Shaded}

    \begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.45}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.55}}@{}}
\toprule
Julia & Python \\
\midrule
\endhead
\texttt{np\ =\ PyPlot.pyimport("numpy")} &
\texttt{import\ numpy\ as\ np} \\
\texttt{import\ PyPlot} & \texttt{from\ pylab\ import\ *} \\
\texttt{1:10} & \texttt{range(1,\ 11)} \\
\texttt{1:2:10}or\texttt{range(1,\ 11,\ 2)} &
\texttt{range(1,\ 11,\ 2)} \\
\texttt{1.2:0.5:10.3}or\texttt{range(1.2,\ 10.3,\ step=0.5)} &
\texttt{np.arange(1.2,\ 10.3,\ 0.5)} \\
\texttt{range(1,\ 10,\ length=3)} & \texttt{np.linspace(1,\ 10,\ 3)} \\
\texttt{collect(1:5)}or\texttt{{[}i\ for\ i\ in\ 1:5{]}} &
\texttt{list(range(1,\ 6))}or\texttt{{[}i\ for\ i\ in\ range(1,\ 6){]}} \\
\bottomrule
\end{longtable}

    \hypertarget{loop-fusion}{%
\subsection{Loop Fusion}\label{loop-fusion}}

Did you notice that we wrote \texttt{sin.(x)\ ./\ x} (not
\texttt{sin(x)\ /\ x})?

This is equivalent to \texttt{{[}sin(i)\ /\ i\ for\ i\ in\ x{]}}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{13}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{a} \PY{o}{=} \PY{n}{sin}\PY{o}{.}\PY{p}{(}\PY{n}{x}\PY{p}{)} \PY{o}{./} \PY{n}{x}
\PY{n}{b} \PY{o}{=} \PY{p}{[}\PY{n}{sin}\PY{p}{(}\PY{n}{i}\PY{p}{)} \PY{o}{/} \PY{n}{i} \PY{k}{for} \PY{n}{i} \PY{k}{in} \PY{n}{x}\PY{p}{]}
\PY{n+nd}{@assert} \PY{n}{a} \PY{o}{==} \PY{n}{b}
\end{Verbatim}
\end{tcolorbox}

    This is not just syntactic sugar: it's actually a very powerful Julia
feature. Indeed, notice that the array only gets traversed once. Even if
we chained more than two dotted operations, the array would still only
get traversed once. This is called \emph{loop fusion}.

In contrast, when using NumPy arrays, \texttt{sin(x)\ /\ x} first
computes a temporary array containing \texttt{sin(x)} and then it
computes the final array. Two loops and two arrays instead of one. NumPy
is implemented in C, and has been heavily optimized, but if you chain
many operations, it still ends up being slower and using more RAM than
Julia.

However, all the extra dots can sometimes make the code a bit harder to
read. To avoid that, you can write \texttt{@.} before an expression:
every operation will be ``dotted'' automatically, like this:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{14}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{a} \PY{o}{=} \PY{n+nd}{@.} \PY{n}{sin}\PY{p}{(}\PY{n}{x}\PY{p}{)} \PY{o}{/} \PY{n}{x}
\PY{n}{b} \PY{o}{=} \PY{n}{sin}\PY{o}{.}\PY{p}{(}\PY{n}{x}\PY{p}{)} \PY{o}{./} \PY{n}{x}
\PY{n+nd}{@assert} \PY{n}{a} \PY{o}{==} \PY{n}{b}
\end{Verbatim}
\end{tcolorbox}

    \textbf{Note}: Julia's \texttt{@assert} statement starts with an
\texttt{@} sign, just like \texttt{@.}, which means that they are
macros. In Julia, macros are very powerful metaprogramming tools: a
macro is evaluated at parse time, and it can inspect the expression that
follows it and then transform it, or even replace it. In practice, you
will often \emph{use} macros, but you will rarely \emph{define} your
own. I'll come back to macros later.

    \hypertarget{julia-is-fast}{%
\subsection{Julia is fast!}\label{julia-is-fast}}

Let's compare the Julia and Python implementations of the
\texttt{estimate\_pi()} function:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{15}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nd}{@time} \PY{n}{estimate\PYZus{}pi}\PY{p}{(}\PY{l+m+mi}{100\PYZus{}000\PYZus{}000}\PY{p}{)}\PY{p}{;}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
  0.114690 seconds
    \end{Verbatim}

    To get a more precise benchmark, it's preferable to use the
\texttt{BenchmarkTools} module. Just like Python's \texttt{timeit}
module, it provides tools to benchmark code by running it multiple
times. This provides a better estimate of how long each call takes:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{16}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{import} \PY{n}{BenchmarkTools}

\PY{n}{BenchmarkTools}\PY{o}{.}\PY{n+nd}{@benchmark} \PY{n}{estimate\PYZus{}pi}\PY{p}{(}\PY{l+m+mi}{100\PYZus{}000\PYZus{}000}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{16}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
BenchmarkTools.Trial: 53 samples with 1 evaluation.
 Range \textcolor{ansi-black-intense}{(}\textcolor{ansi-cyan-intense}{\textbf{min}} … \textcolor{ansi-magenta}{max}\textcolor{ansi-black-intense}{):
}\textcolor{ansi-cyan-intense}{\textbf{89.611 ms}} … \textcolor{ansi-magenta}{105.873 ms}  \textcolor{ansi-black-intense}{┊} GC
\textcolor{ansi-black-intense}{(}min … max\textcolor{ansi-black-intense}{): }0.00\% … 0.00\%
 Time  \textcolor{ansi-black-intense}{(}\textcolor{ansi-blue-intense}{\textbf{median}}\textcolor{ansi-black-intense}{):     }\textcolor{ansi-blue-intense}{\textbf{94.416 ms
}}\textcolor{ansi-black-intense}{┊} GC \textcolor{ansi-black-intense}{(}median\textcolor{ansi-black-intense}{):    }0.00\%
 Time  \textcolor{ansi-black-intense}{(}\textcolor{ansi-green-intense}{\textbf{mean}} ± \textcolor{ansi-green}{σ}\textcolor{ansi-black-intense}{):
}\textcolor{ansi-green-intense}{\textbf{94.796 ms}} ± \textcolor{ansi-green}{  4.135 ms}  \textcolor{ansi-black-intense}{┊} GC
\textcolor{ansi-black-intense}{(}mean ± σ\textcolor{ansi-black-intense}{):  }0.00\% ± 0.00\%

  ▄ █▁ ▁  ▁ ▁ 
  ▄    ▁\textcolor{ansi-blue}{▁}\textcolor{ansi-green}{ }
 ▁ ▁▁ ▁▁ ▁  
            
         ▁ 
  █▆██▆█▁▆█▁█▆▆
▁▆█▁▁▆▁█\textcolor{ansi-blue}{█}\textcolor{ansi-green}{▆}▁[39
m▁█▆██▁██▁█▆▁▆▁
▁▁▁▁▆▁▁▁▁▁▆▁▆[
39m▆▁▁▁▆▁▁▁█ ▁
  89.6 ms\textcolor{ansi-black-intense}{         Histogram: frequency by time}          104 ms
\textbf{<}

 Memory estimate\textcolor{ansi-black-intense}{: }\textcolor{ansi-yellow}{0 bytes}, allocs estimate\textcolor{ansi-black-intense}{:
}\textcolor{ansi-yellow}{0}.
\end{Verbatim}
\end{tcolorbox}
        
    If this output is too verbose for you, simply use \texttt{@btime}
instead:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{17}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{BenchmarkTools}\PY{o}{.}\PY{n+nd}{@btime} \PY{n}{estimate\PYZus{}pi}\PY{p}{(}\PY{l+m+mi}{100\PYZus{}000\PYZus{}000}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
  88.932 ms (0 allocations: 0 bytes)
    \end{Verbatim}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{17}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
3.141592663589326
\end{Verbatim}
\end{tcolorbox}
        
    Now let's time the Python version. Since the call is so slow, we just
run it once (it will take about 15 seconds):

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{18}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{PyCall}\PY{o}{.}\PY{l+s+sa}{py}\PY{l+s}{\PYZdq{}\PYZdq{}\PYZdq{}}
\PY{l+s}{from timeit import timeit}

\PY{l+s}{duration = timeit(}\PY{l+s}{\PYZdq{}}\PY{l+s}{estimate\PYZus{}pi(100\PYZus{}000\PYZus{}000)}\PY{l+s}{\PYZdq{}}\PY{l+s}{, number=1, globals=globals())}
\PY{l+s}{\PYZdq{}\PYZdq{}\PYZdq{}}

\PY{n}{PyCall}\PY{o}{.}\PY{l+s+sa}{py}\PY{l+s}{\PYZdq{}}\PY{l+s}{duration}\PY{l+s}{\PYZdq{}}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{18}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
12.366449234999891
\end{Verbatim}
\end{tcolorbox}
        
    It looks like Julia is close to 100 times faster than Python in this
case! To be fair, \texttt{PyCall} does add some overhead, but even if
you run this code in a separate Python shell, you will see that Julia
crushes (pure) Python when it comes to speed.

    So why is Julia so much faster than Python? Well, \textbf{Julia compiles
the code on the fly as it runs it}.

    Okay, let's summarize what we learned so far: Julia is a dynamic
language that looks and feels a lot like Python, you can even execute
Python code super easily, and pure Julia code runs much faster than pure
Python code, because it is compiled on the fly. I hope this convinces
you to read on!

Next, let's continue to see how Python's main constructs can be
implemented in Julia.

    \hypertarget{numbers}{%
\section{Numbers}\label{numbers}}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{19}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{i} \PY{o}{=} \PY{l+m+mi}{42} \PY{c}{\PYZsh{} 64\PYZhy{}bit integer}
\PY{n}{f} \PY{o}{=} \PY{l+m+mf}{3.14} \PY{c}{\PYZsh{} 64\PYZhy{}bit float}
\PY{n}{c} \PY{o}{=} \PY{l+m+mf}{3.4} \PY{o}{+} \PY{l+m+mf}{4.5}\PY{n+nb}{im} \PY{c}{\PYZsh{} 128\PYZhy{}bit complex number}

\PY{n}{bi} \PY{o}{=} \PY{k+kt}{BigInt}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{)}\PY{o}{\PYZca{}}\PY{l+m+mi}{1000} \PY{c}{\PYZsh{} arbitrarily long integer}
\PY{n}{bf} \PY{o}{=} \PY{k+kt}{BigFloat}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{)} \PY{o}{/} \PY{l+m+mi}{7} \PY{c}{\PYZsh{} arbitrary precision}

\PY{n}{r} \PY{o}{=} \PY{l+m+mi}{15}\PY{o}{//}\PY{l+m+mi}{6} \PY{o}{*} \PY{l+m+mi}{9}\PY{o}{//}\PY{l+m+mi}{20} \PY{c}{\PYZsh{} rational number}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{19}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
9//8
\end{Verbatim}
\end{tcolorbox}
        
    And the equivalent Python code:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# PYTHON}
\NormalTok{i }\OperatorTok{=} \DecValTok{42}
\NormalTok{f }\OperatorTok{=} \FloatTok{3.14}
\NormalTok{c }\OperatorTok{=} \FloatTok{3.4} \OperatorTok{+} \OtherTok{4.5j}

\NormalTok{bi }\OperatorTok{=} \DecValTok{2}\OperatorTok{**}\DecValTok{1000} \CommentTok{\# integers are seemlessly promoted to long integers}
\ImportTok{from}\NormalTok{ decimal }\ImportTok{import}\NormalTok{ Decimal}
\NormalTok{bf }\OperatorTok{=}\NormalTok{ Decimal(}\DecValTok{1}\NormalTok{) }\OperatorTok{/} \DecValTok{7}

\ImportTok{from}\NormalTok{ fractions }\ImportTok{import}\NormalTok{ Fraction}
\NormalTok{r }\OperatorTok{=}\NormalTok{ Fraction(}\DecValTok{15}\NormalTok{, }\DecValTok{6}\NormalTok{) }\OperatorTok{*}\NormalTok{ Fraction(}\DecValTok{9}\NormalTok{, }\DecValTok{20}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

    Dividing integers gives floats, like in Python:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{20}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{l+m+mi}{5} \PY{o}{/} \PY{l+m+mi}{2}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{20}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
2.5
\end{Verbatim}
\end{tcolorbox}
        
    For integer division, use \texttt{÷} or \texttt{div()}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{21}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{l+m+mi}{5} \PY{o}{÷} \PY{l+m+mi}{2}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{21}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
2
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{22}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{div}\PY{p}{(}\PY{l+m+mi}{5}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{22}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
2
\end{Verbatim}
\end{tcolorbox}
        
    The \texttt{\%} operator is the remainder, not the modulo like in
Python. These differ only for negative numbers:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{23}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{l+m+mi}{57} \PY{o}{\PYZpc{}} \PY{l+m+mi}{10}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{23}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
7
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{24}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{p}{(}\PY{o}{\PYZhy{}}\PY{l+m+mi}{57}\PY{p}{)} \PY{o}{\PYZpc{}} \PY{l+m+mi}{10}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{24}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
-7
\end{Verbatim}
\end{tcolorbox}
        
    \begin{longtable}[]{@{}ll@{}}
\toprule
Julia & Python \\
\midrule
\endhead
\texttt{3.4\ +\ 4.5im} & \texttt{3.4\ +\ 4.5j} \\
\texttt{BigInt(2)\^{}1000} & \texttt{2**1000} \\
\texttt{BigFloat(3.14)} &
\texttt{from\ decimal\ import\ Decimal}\texttt{Decimal(3.14)} \\
\texttt{9//8} &
\texttt{from\ fractions\ import\ Fraction}\texttt{Fraction(9,\ 8)} \\
\texttt{5/2\ ==\ 2.5} & \texttt{5/2\ ==\ 2.5} \\
\texttt{5÷2\ ==\ 2}or\texttt{div(5,\ 2)} & \texttt{5//2\ ==\ 2} \\
\texttt{57\%10\ ==\ 7} & \texttt{57\%10\ ==\ 7} \\
\texttt{(-57)\%10\ ==\ -7} & \texttt{(-57)\%10\ ==\ 3} \\
\bottomrule
\end{longtable}

    \hypertarget{strings}{%
\section{Strings}\label{strings}}

Julia strings use double quotes \texttt{"} or triple quotes
\texttt{"""}, but not single quotes \texttt{\textquotesingle{}}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{25}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{s} \PY{o}{=} \PY{l+s}{\PYZdq{}}\PY{l+s}{ångström}\PY{l+s}{\PYZdq{}} \PY{c}{\PYZsh{} Julia strings are UTF\PYZhy{}8 encoded by default}
\PY{n}{println}\PY{p}{(}\PY{n}{s}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
ångström
    \end{Verbatim}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{26}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{s} \PY{o}{=} \PY{l+s}{\PYZdq{}}\PY{l+s}{Julia strings}
\PY{l+s}{     can span}
\PY{l+s}{     several lines}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+se}{\PYZbs{}n}
\PY{l+s}{     and they support the }\PY{l+s+se}{\PYZbs{}\PYZdq{}}\PY{l+s}{usual}\PY{l+s+se}{\PYZbs{}\PYZdq{}}\PY{l+s}{ escapes like}
\PY{l+s}{     }\PY{l+s+se}{\PYZbs{}x41}\PY{l+s}{, }\PY{l+s+se}{\PYZbs{}u5bb6}\PY{l+s}{, and }\PY{l+s+se}{\PYZbs{}U0001f60a}\PY{l+s}{!}\PY{l+s}{\PYZdq{}}
\PY{n}{println}\PY{p}{(}\PY{n}{s}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Julia strings
     can span
     several lines


     and they support the "usual" escapes like
     A, 家, and 😊!
    \end{Verbatim}

    Use \texttt{repeat()} instead of \texttt{*} to repeat a string, and use
\texttt{*} instead of \texttt{+} for concatenation:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{27}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{s} \PY{o}{=} \PY{n}{repeat}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{tick, }\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+m+mi}{10}\PY{p}{)} \PY{o}{*} \PY{l+s}{\PYZdq{}}\PY{l+s}{BOOM!}\PY{l+s}{\PYZdq{}}
\PY{n}{println}\PY{p}{(}\PY{n}{s}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
tick, tick, tick, tick, tick, tick, tick, tick, tick, tick, BOOM!
    \end{Verbatim}

    The equivalent Python code is:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# PYTHON}
\NormalTok{s }\OperatorTok{=} \StringTok{"tick, "} \OperatorTok{*} \DecValTok{10} \OperatorTok{+} \StringTok{"BOOM!"}
\BuiltInTok{print}\NormalTok{(s)}
\end{Highlighting}
\end{Shaded}

    Use \texttt{join(a,\ s)} instead of \texttt{s.join(a)}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{28}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{s} \PY{o}{=} \PY{n}{join}\PY{p}{(}\PY{p}{[}\PY{n}{i} \PY{k}{for} \PY{n}{i} \PY{k}{in} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{4}\PY{p}{]}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{, }\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{n}{println}\PY{p}{(}\PY{n}{s}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
1, 2, 3, 4
    \end{Verbatim}

    You can also specify a string for the last join:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{29}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{s} \PY{o}{=} \PY{n}{join}\PY{p}{(}\PY{p}{[}\PY{n}{i} \PY{k}{for} \PY{n}{i} \PY{k}{in} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{4}\PY{p}{]}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{, }\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{ and }\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{29}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
"1, 2, 3 and 4"
\end{Verbatim}
\end{tcolorbox}
        
    \texttt{split()} works as you might expect:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{30}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{split}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{   one    three     four   }\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{30}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
3-element Vector\{SubString\{String\}\}:
 "one"
 "three"
 "four"
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{31}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{split}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{one,,three,four!}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{,}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{31}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
4-element Vector\{SubString\{String\}\}:
 "one"
 ""
 "three"
 "four!"
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{32}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{occursin}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{sip}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{Mississippi}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{32}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
true
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{33}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{replace}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{I like coffee}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{coffee}\PY{l+s}{\PYZdq{}} \PY{o}{=\PYZgt{}} \PY{l+s}{\PYZdq{}}\PY{l+s}{tea}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{33}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
"I like tea"
\end{Verbatim}
\end{tcolorbox}
        
    Triple quotes work a bit like in Python, but they also remove
indentation and ignore the first line feed:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{34}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{s} \PY{o}{=} \PY{l+s}{\PYZdq{}\PYZdq{}\PYZdq{}}
\PY{l+s}{       1. the first line feed is ignored if it immediately follows }\PY{l+s+se}{\PYZbs{}\PYZdq{}}\PY{l+s}{\PYZdq{}}\PY{l+s}{\PYZdq{}}
\PY{l+s}{       2. triple quotes let you use }\PY{l+s}{\PYZdq{}}\PY{l+s}{quotes}\PY{l+s}{\PYZdq{}}\PY{l+s}{ easily}
\PY{l+s}{       3. indentation is ignored}
\PY{l+s}{           \PYZhy{} up to left\PYZhy{}most character}
\PY{l+s}{           \PYZhy{} ignoring the first line (the one with }\PY{l+s+se}{\PYZbs{}\PYZdq{}}\PY{l+s}{\PYZdq{}}\PY{l+s}{\PYZdq{}}\PY{l+s}{)}
\PY{l+s}{       4. the final line feed it n̲o̲t̲ ignored}
\PY{l+s}{       }\PY{l+s}{\PYZdq{}\PYZdq{}\PYZdq{}}
\PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{\PYZlt{}start\PYZgt{}}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{n}{println}\PY{p}{(}\PY{n}{s}\PY{p}{)}
\PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{\PYZlt{}end\PYZgt{}}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
<start>
1. the first line feed is ignored if it immediately follows """
2. triple quotes let you use "quotes" easily
3. indentation is ignored
    - up to left-most character
    - ignoring the first line (the one with """)
4. the final line feed it n̲o̲t̲ ignored

<end>
    \end{Verbatim}

    \hypertarget{string-interpolation}{%
\subsection{String Interpolation}\label{string-interpolation}}

String interpolation uses \texttt{\$variable} and
\texttt{\$(expression)}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{35}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{total} \PY{o}{=} \PY{l+m+mi}{1} \PY{o}{+} \PY{l+m+mi}{2} \PY{o}{+} \PY{l+m+mi}{3}
\PY{n}{s} \PY{o}{=} \PY{l+s}{\PYZdq{}}\PY{l+s}{1 + 2 + 3 = }\PY{l+s+si}{\PYZdl{}total}\PY{l+s}{ = }\PY{l+s+si}{\PYZdl{}}\PY{p}{(}\PY{l+m+mi}{1} \PY{o}{+} \PY{l+m+mi}{2} \PY{o}{+} \PY{l+m+mi}{3}\PY{p}{)}\PY{l+s}{\PYZdq{}}
\PY{n}{println}\PY{p}{(}\PY{n}{s}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
1 + 2 + 3 = 6 = 6
    \end{Verbatim}

    This means you must escape the \texttt{\$} sign:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{36}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{s} \PY{o}{=} \PY{l+s}{\PYZdq{}}\PY{l+s}{The car costs }\PY{l+s+se}{\PYZbs{}\PYZdl{}}\PY{l+s}{10,000}\PY{l+s}{\PYZdq{}}
\PY{n}{println}\PY{p}{(}\PY{n}{s}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
The car costs \$10,000
    \end{Verbatim}

    \hypertarget{raw-strings}{%
\subsection{Raw Strings}\label{raw-strings}}

Raw strings use \texttt{raw"..."} instead of \texttt{r"..."}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{37}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{s} \PY{o}{=} \PY{l+s+sa}{raw}\PY{l+s}{\PYZdq{}}\PY{l+s}{In a raw string, you only need to escape quotes }\PY{l+s+se}{\PYZbs{}\PYZdq{}}\PY{l+s}{, but not}
\PY{l+s}{        \PYZdl{} or \PYZbs{}. There is one exception, however: the backslash \PYZbs{}}
\PY{l+s}{        must be escaped if it\PYZsq{}s just before quotes like \PYZbs{}\PYZbs{}}\PY{l+s+se}{\PYZbs{}\PYZdq{}}\PY{l+s}{.}\PY{l+s}{\PYZdq{}}
\PY{n}{println}\PY{p}{(}\PY{n}{s}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
In a raw string, you only need to escape quotes ", but not
        \$ or \textbackslash{}. There is one exception, however: the backslash \textbackslash{}
        must be escaped if it's just before quotes like \textbackslash{}".
    \end{Verbatim}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{38}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{s} \PY{o}{=} \PY{l+s+sa}{raw}\PY{l+s}{\PYZdq{}\PYZdq{}\PYZdq{}}
\PY{l+s}{   Triple quoted raw strings are possible too: \PYZdl{}, \PYZbs{}, \PYZbs{}t, \PYZdq{}}
\PY{l+s}{     \PYZhy{} They handle indentation and the first line feed like regular}
\PY{l+s}{       triple quoted strings.}
\PY{l+s}{     \PYZhy{} You only need to escape triple quotes like \PYZbs{}}\PY{l+s}{\PYZdq{}\PYZdq{}\PYZdq{}}\PY{p}{,} \PY{n}{and} \PY{n}{the}
       \PY{n}{backslash} \PY{n}{before} \PY{n}{quotes} \PY{n}{like} \PY{o}{\PYZbs{}}\PY{o}{\PYZbs{}}\PY{l+s}{\PYZdq{}}\PY{l+s}{.}
\PY{l+s}{   }\PY{l+s}{\PYZdq{}}\PY{l+s}{\PYZdq{}}\PY{l+s}{\PYZdq{}}
\PY{n}{println}\PY{p}{(}\PY{n}{s}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Triple quoted raw strings are possible too: \$, \textbackslash{}, \textbackslash{}t, "
  - They handle indentation and the first line feed like regular
    triple quoted strings.
  - You only need to escape triple quotes like """, and the
    backslash before quotes like \textbackslash{}".

    \end{Verbatim}

    \hypertarget{characters}{%
\subsection{Characters}\label{characters}}

Single quotes are used for individual Unicode characters:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{39}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{a} \PY{o}{=} \PY{l+s+sc}{\PYZsq{}å\PYZsq{}} \PY{c}{\PYZsh{} Unicode code point (single quotes)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{39}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
'å': Unicode U+00E5 (category Ll: Letter, lowercase)
\end{Verbatim}
\end{tcolorbox}
        
    To be more precise: * A Julia ``character'' represents a single Unicode
code point (sometimes called a Unicode scalar). * Multiple code points
may be required to produce a single \emph{grapheme}, i.e., something
that readers would recognize as a single character. Such a sequence of
code points is called a ``Grapheme cluster''.

For example, the character \texttt{é} can be represented either using
the single code point \texttt{\textbackslash{}u00E9}, or the grapheme
cluster \texttt{e} + \texttt{\textbackslash{}u0301}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{40}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{s} \PY{o}{=} \PY{l+s}{\PYZdq{}}\PY{l+s}{café}\PY{l+s}{\PYZdq{}}
\PY{n}{println}\PY{p}{(}\PY{n}{s}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{ has }\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{n}{length}\PY{p}{(}\PY{n}{s}\PY{p}{)}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{ code points}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
café has 4 code points
    \end{Verbatim}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{41}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{s} \PY{o}{=} \PY{l+s}{\PYZdq{}}\PY{l+s}{cafe}\PY{l+s+se}{\PYZbs{}u0301}\PY{l+s}{\PYZdq{}}
\PY{n}{println}\PY{p}{(}\PY{n}{s}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{ has }\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{n}{length}\PY{p}{(}\PY{n}{s}\PY{p}{)}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{ code points}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
café has 5 code points
    \end{Verbatim}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{42}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{for} \PY{n}{c} \PY{k}{in} \PY{l+s}{\PYZdq{}}\PY{l+s}{cafe}\PY{l+s+se}{\PYZbs{}u0301}\PY{l+s}{\PYZdq{}}
    \PY{n}{display}\PY{p}{(}\PY{n}{c}\PY{p}{)}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    
    \begin{Verbatim}[commandchars=\\\{\}]
'c': ASCII/Unicode U+0063 (category Ll: Letter, lowercase)
    \end{Verbatim}

    
    
    \begin{Verbatim}[commandchars=\\\{\}]
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)
    \end{Verbatim}

    
    
    \begin{Verbatim}[commandchars=\\\{\}]
'f': ASCII/Unicode U+0066 (category Ll: Letter, lowercase)
    \end{Verbatim}

    
    
    \begin{Verbatim}[commandchars=\\\{\}]
'e': ASCII/Unicode U+0065 (category Ll: Letter, lowercase)
    \end{Verbatim}

    
    
    \begin{Verbatim}[commandchars=\\\{\}]
'́': Unicode U+0301 (category Mn: Mark, nonspacing)
    \end{Verbatim}

    
    Julia represents any individual character like
\texttt{\textquotesingle{}é\textquotesingle{}} using 32-bits (4 bytes):

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{43}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{sizeof}\PY{p}{(}\PY{l+s+sc}{\PYZsq{}é\PYZsq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{43}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
4
\end{Verbatim}
\end{tcolorbox}
        
    But strings are represented using the UTF-8 encoding. In this encoding,
code points 0 to 127 are represented using one byte, but any code point
above 127 is represented using 2 to 6 bytes:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{44}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{sizeof}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{a}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{44}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
1
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{45}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{sizeof}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{é}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{45}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
2
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{46}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{sizeof}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{家}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{46}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
3
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{47}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{sizeof}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{🏳️‍🌈}\PY{l+s}{\PYZdq{}}\PY{p}{)} \PY{c}{\PYZsh{} this is a grapheme with 4 code points of 4 + 3 + 3 + 4 bytes}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{47}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
14
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{48}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{p}{[}\PY{n}{sizeof}\PY{p}{(}\PY{n}{string}\PY{p}{(}\PY{n}{c}\PY{p}{)}\PY{p}{)} \PY{k}{for} \PY{n}{c} \PY{k}{in} \PY{l+s}{\PYZdq{}}\PY{l+s}{🏳️‍🌈}\PY{l+s}{\PYZdq{}}\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{48}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
4-element Vector\{Int64\}:
 4
 3
 3
 4
\end{Verbatim}
\end{tcolorbox}
        
    You can iterate through graphemes instead of code points:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{49}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{import} \PY{n}{Unicode}

\PY{k}{for} \PY{n}{g} \PY{k}{in} \PY{n}{Unicode}\PY{o}{.}\PY{n}{graphemes}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{e}\PY{l+s+se}{\PYZbs{}u0301}\PY{l+s}{🏳️‍🌈}\PY{l+s}{\PYZdq{}}\PY{p}{)}
  \PY{n}{println}\PY{p}{(}\PY{n}{g}\PY{p}{)}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
é
🏳️‍🌈
    \end{Verbatim}

    \hypertarget{string-indexing}{%
\subsection{String Indexing}\label{string-indexing}}

Characters in a string are indexed based on the position of their
starting byte in the UTF-8 representation. For example, the character
\texttt{ê} in the string \texttt{"être"} is located at index 1, but the
character \texttt{\textquotesingle{}t\textquotesingle{}} is located at
index 3, since the UTF-8 encoding of \texttt{ê} is 2 bytes long:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{50}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{s} \PY{o}{=} \PY{l+s}{\PYZdq{}}\PY{l+s}{être}\PY{l+s}{\PYZdq{}}
\PY{n}{println}\PY{p}{(}\PY{n}{s}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
\PY{n}{println}\PY{p}{(}\PY{n}{s}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{)}
\PY{n}{println}\PY{p}{(}\PY{n}{s}\PY{p}{[}\PY{l+m+mi}{4}\PY{p}{]}\PY{p}{)}
\PY{n}{println}\PY{p}{(}\PY{n}{s}\PY{p}{[}\PY{l+m+mi}{5}\PY{p}{]}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
ê
t
r
e
    \end{Verbatim}

    If you try to get the character at index 2, you get an exception:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{51}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{try}
    \PY{n}{s}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}
\PY{k}{catch} \PY{n}{ex}
    \PY{n}{ex}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{51}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
StringIndexError("être", 2)
\end{Verbatim}
\end{tcolorbox}
        
    By the way, notice the exception-handling syntax (we'll discuss
exceptions later):

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.45}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.55}}@{}}
\toprule
Julia & Python \\
\midrule
\endhead
\texttt{try}~~~~\texttt{...}\texttt{catch\ ex}~~~~\texttt{...}\texttt{end}
&
\texttt{try}~~~~\texttt{...}\texttt{except\ Exception\ as\ ex}~~~~\texttt{...}\texttt{end} \\
\bottomrule
\end{longtable}

    You can get a substring easily, using valid character indices:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{52}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{s}\PY{p}{[}\PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{3}\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{52}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
"êt"
\end{Verbatim}
\end{tcolorbox}
        
    You can iterate through a string, and it will return all the code
points:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{53}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{for} \PY{n}{c} \PY{k}{in} \PY{n}{s}
    \PY{n}{println}\PY{p}{(}\PY{n}{c}\PY{p}{)}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
ê
t
r
e
    \end{Verbatim}

    Or you can iterate through the valid character indices:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{54}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{for} \PY{n}{i} \PY{k}{in} \PY{n}{eachindex}\PY{p}{(}\PY{n}{s}\PY{p}{)}
    \PY{n}{println}\PY{p}{(}\PY{n}{i}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{: }\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{n}{s}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{)}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
1: ê
3: t
4: r
5: e
    \end{Verbatim}

    Benefits of representing strings as UTF-8: * All Unicode characters are
supported. * UTF-8 is fairly compact (at least for Latin scripts). * It
plays nicely with C libraries which expect ASCII characters only, since
ASCII characters correspond to the Unicode code points 0 to 127, which
UTF-8 encodes exactly like ASCII.

Drawbacks: * UTF-8 uses a variable number of bytes per character, which
makes indexing harder. * However, If the language tried to hide this by
making \texttt{s{[}5{]}} search for the 5th character from the start of
the string, then code like
\texttt{for\ i\ in\ 1:length(s);\ s{[}i{]};\ end} would be unexpectedly
inefficient, since at each iteration there would be a search from the
beginning of the string, leading to O(\emph{n}2) performance instead of
O(\emph{n}).

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{55}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{findfirst}\PY{p}{(}\PY{n}{isequal}\PY{p}{(}\PY{l+s+sc}{\PYZsq{}t\PYZsq{}}\PY{p}{)}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{être}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{55}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
3
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{56}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{findlast}\PY{p}{(}\PY{n}{isequal}\PY{p}{(}\PY{l+s+sc}{\PYZsq{}p\PYZsq{}}\PY{p}{)}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{Mississippi}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{56}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
10
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{57}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{findnext}\PY{p}{(}\PY{n}{isequal}\PY{p}{(}\PY{l+s+sc}{\PYZsq{}i\PYZsq{}}\PY{p}{)}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{Mississippi}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{57}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
2
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{58}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{findnext}\PY{p}{(}\PY{n}{isequal}\PY{p}{(}\PY{l+s+sc}{\PYZsq{}i\PYZsq{}}\PY{p}{)}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{Mississippi}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+m+mi}{2} \PY{o}{+} \PY{l+m+mi}{1}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{58}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
5
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{59}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{findprev}\PY{p}{(}\PY{n}{isequal}\PY{p}{(}\PY{l+s+sc}{\PYZsq{}i\PYZsq{}}\PY{p}{)}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{Mississippi}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+m+mi}{5} \PY{o}{\PYZhy{}} \PY{l+m+mi}{1}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{59}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
2
\end{Verbatim}
\end{tcolorbox}
        
    Other useful string functions: \texttt{ncodeunits(str)},
\texttt{codeunit(str,\ i)}, \texttt{thisind(str,\ i)},
\texttt{nextind(str,\ i,\ n=1)}, \texttt{prevind(str,\ i,\ n=1)}.

    \hypertarget{regular-expressions}{%
\subsection{Regular Expressions}\label{regular-expressions}}

To create a regular expression in Julia, use the \texttt{r"..."} syntax:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{60}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{regex} \PY{o}{=} \PY{l+s+sa}{r}\PY{l+s+sr}{\PYZdq{}}\PY{l+s+sr}{c[ao]ff?(?:é|ee)}\PY{l+s+sr}{\PYZdq{}}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{60}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
r"c[ao]ff?(?:é|ee)"
\end{Verbatim}
\end{tcolorbox}
        
    The expression \texttt{r"..."} is equivalent to \texttt{Regex("...")}
except the former is evaluated at parse time, while the latter is
evaluated at runtime, so unless you need to construct a Regex
dynamically, you should prefer \texttt{r"..."}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{61}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{occursin}\PY{p}{(}\PY{n}{regex}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{A bit more coffee?}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{61}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
true
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{62}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{m} \PY{o}{=} \PY{n}{match}\PY{p}{(}\PY{n}{regex}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{A bit more coffee?}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{n}{m}\PY{o}{.}\PY{n}{match}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{62}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
"coffee"
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{63}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{m}\PY{o}{.}\PY{n}{offset}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{63}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
12
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{64}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{m} \PY{o}{=} \PY{n}{match}\PY{p}{(}\PY{n}{regex}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{A bit more tea?}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{n}{isnothing}\PY{p}{(}\PY{n}{m}\PY{p}{)} \PY{o}{\PYZam{}\PYZam{}} \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{I suggest coffee instead}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
I suggest coffee instead
    \end{Verbatim}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{65}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{regex} \PY{o}{=} \PY{l+s+sa}{r}\PY{l+s+sr}{\PYZdq{}}\PY{l+s+sr}{(.*)\PYZsh{}(.+)}\PY{l+s+sr}{\PYZdq{}}
\PY{n}{line} \PY{o}{=} \PY{l+s}{\PYZdq{}}\PY{l+s}{f(1) \PYZsh{} nice comment}\PY{l+s}{\PYZdq{}}
\PY{n}{m} \PY{o}{=} \PY{n}{match}\PY{p}{(}\PY{n}{regex}\PY{p}{,} \PY{n}{line}\PY{p}{)}
\PY{n}{code}\PY{p}{,} \PY{n}{comment} \PY{o}{=} \PY{n}{m}\PY{o}{.}\PY{n}{captures}
\PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{code: }\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{n}{repr}\PY{p}{(}\PY{n}{code}\PY{p}{)}\PY{p}{)}
\PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{comment: }\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{n}{repr}\PY{p}{(}\PY{n}{comment}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
code: "f(1) "
comment: " nice comment"
    \end{Verbatim}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{66}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{m}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{66}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
" nice comment"
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{67}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{m}\PY{o}{.}\PY{n}{offsets}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{67}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
2-element Vector\{Int64\}:
 1
 7
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{68}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{m} \PY{o}{=} \PY{n}{match}\PY{p}{(}\PY{l+s+sa}{r}\PY{l+s+sr}{\PYZdq{}}\PY{l+s+sr}{(?\PYZlt{}code\PYZgt{}.+)\PYZsh{}(?\PYZlt{}comment\PYZgt{}.+)}\PY{l+s+sr}{\PYZdq{}}\PY{p}{,} \PY{n}{line}\PY{p}{)}
\PY{n}{m}\PY{p}{[}\PY{l+s+ss}{:comment}\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{68}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
" nice comment"
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{69}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{replace}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Want more bread?}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+s+sa}{r}\PY{l+s+sr}{\PYZdq{}}\PY{l+s+sr}{(?\PYZlt{}verb\PYZgt{}more|some)}\PY{l+s+sr}{\PYZdq{}} \PY{o}{=\PYZgt{}} \PY{l+s+sa}{s}\PY{l+s}{\PYZdq{}}\PY{l+s}{a little}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{69}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
"Want a little bread?"
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{70}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{replace}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Want more bread?}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+s+sa}{r}\PY{l+s+sr}{\PYZdq{}}\PY{l+s+sr}{(?\PYZlt{}verb\PYZgt{}more|less)}\PY{l+s+sr}{\PYZdq{}} \PY{o}{=\PYZgt{}} \PY{l+s+sa}{s}\PY{l+s}{\PYZdq{}}\PY{l+s}{\PYZbs{}}\PY{l+s}{g\PYZlt{}verb\PYZgt{} and }\PY{l+s}{\PYZbs{}}\PY{l+s}{g\PYZlt{}verb\PYZgt{}}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{70}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
"Want more and more bread?"
\end{Verbatim}
\end{tcolorbox}
        
    \hypertarget{control-flow}{%
\section{Control Flow}\label{control-flow}}

    \hypertarget{if-statement}{%
\subsection{\texorpdfstring{\texttt{if}
statement}{if statement}}\label{if-statement}}

Julia's \texttt{if} statement works just like in Python, with a few
differences:

\begin{itemize}
\tightlist
\item
  Julia uses \texttt{elseif} instead of Python's \texttt{elif}.
\item
  Julia's logic operators are just like in C-like languages:
  \texttt{\&\&} means \texttt{and}, \texttt{\textbar{}\textbar{}} means
  \texttt{or}, \texttt{!} means \texttt{not}, and so on.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{71}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{a} \PY{o}{=} \PY{l+m+mi}{1}
\PY{k}{if} \PY{n}{a} \PY{o}{==} \PY{l+m+mi}{1}
    \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{One}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{k}{elseif} \PY{n}{a} \PY{o}{==} \PY{l+m+mi}{2}
    \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Two}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{k}{else}
    \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Other}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
One
    \end{Verbatim}

    Julia also has \texttt{⊻} for exclusive or (you can type
\texttt{\textbackslash{}xor\textless{}tab\textgreater{}} to get the ⊻
character):

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{72}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nd}{@assert} \PY{n+nb}{false} \PY{o}{⊻} \PY{n+nb}{false} \PY{o}{==} \PY{n+nb}{false}
\PY{n+nd}{@assert} \PY{n+nb}{false} \PY{o}{⊻} \PY{n+nb}{true} \PY{o}{==} \PY{n+nb}{true}
\PY{n+nd}{@assert} \PY{n+nb}{true} \PY{o}{⊻} \PY{n+nb}{false} \PY{o}{==} \PY{n+nb}{true}
\PY{n+nd}{@assert} \PY{n+nb}{true} \PY{o}{⊻} \PY{n+nb}{true} \PY{o}{==} \PY{n+nb}{false}
\end{Verbatim}
\end{tcolorbox}

    Oh, and notice that \texttt{true} and \texttt{false} are all lowercase,
unlike Python's \texttt{True} and \texttt{False}.

    Since \texttt{\&\&} is lazy (like \texttt{and} in Python),
\texttt{cond\ \&\&\ f()} is a common shorthand for
\texttt{if\ cond;\ f();\ end}. Think of it as ``\emph{cond then f()}'':

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{73}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{a} \PY{o}{=} \PY{l+m+mi}{2}
\PY{n}{a} \PY{o}{==} \PY{l+m+mi}{1} \PY{o}{\PYZam{}\PYZam{}} \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{One}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{n}{a} \PY{o}{==} \PY{l+m+mi}{2} \PY{o}{\PYZam{}\PYZam{}} \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Two}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Two
    \end{Verbatim}

    Similarly, \texttt{cond\ \textbar{}\textbar{}\ f()} is a common
shorthand for \texttt{if\ !cond;\ f();\ end}. Think of it as
``\emph{cond else f()}'':

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{74}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{a} \PY{o}{=} \PY{l+m+mi}{1}
\PY{n}{a} \PY{o}{==} \PY{l+m+mi}{1} \PY{o}{||} \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Not one}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{n}{a} \PY{o}{==} \PY{l+m+mi}{2} \PY{o}{||} \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Not two}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Not two
    \end{Verbatim}

    All expressions return a value in Julia, including \texttt{if}
statements. For example:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{75}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{a} \PY{o}{=} \PY{l+m+mi}{1}
\PY{n}{result} \PY{o}{=} \PY{k}{if} \PY{n}{a} \PY{o}{==} \PY{l+m+mi}{1}
             \PY{l+s}{\PYZdq{}}\PY{l+s}{one}\PY{l+s}{\PYZdq{}}
         \PY{k}{else}
             \PY{l+s}{\PYZdq{}}\PY{l+s}{two}\PY{l+s}{\PYZdq{}}
         \PY{k}{end}
\PY{n}{result}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{75}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
"one"
\end{Verbatim}
\end{tcolorbox}
        
    When an expression cannot return anything, it returns \texttt{nothing}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{76}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{a} \PY{o}{=} \PY{l+m+mi}{1}
\PY{n}{result} \PY{o}{=} \PY{k}{if} \PY{n}{a} \PY{o}{==} \PY{l+m+mi}{2}
            \PY{l+s}{\PYZdq{}}\PY{l+s}{two}\PY{l+s}{\PYZdq{}}
          \PY{k}{end}

\PY{n}{isnothing}\PY{p}{(}\PY{n}{result}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{76}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
true
\end{Verbatim}
\end{tcolorbox}
        
    \texttt{nothing} is the single instance of the type \texttt{Nothing}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{77}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{typeof}\PY{p}{(}\PY{n+nb}{nothing}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{77}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
Nothing
\end{Verbatim}
\end{tcolorbox}
        
    \hypertarget{for-loops}{%
\subsection{\texorpdfstring{\texttt{for}
loops}{for loops}}\label{for-loops}}

You can use \texttt{for} loops just like in Python, as we saw earlier.
However, it's also possible to create nested loops on a single line:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{78}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{for} \PY{n}{a} \PY{k}{in} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{2}\PY{p}{,} \PY{n}{b} \PY{k}{in} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{3}\PY{p}{,} \PY{n}{c} \PY{k}{in} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{2}
    \PY{n}{println}\PY{p}{(}\PY{p}{(}\PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{,} \PY{n}{c}\PY{p}{)}\PY{p}{)}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
(1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 2, 2)
(1, 3, 1)
(1, 3, 2)
(2, 1, 1)
(2, 1, 2)
(2, 2, 1)
(2, 2, 2)
(2, 3, 1)
(2, 3, 2)
    \end{Verbatim}

    The corresponding Python code would look like this:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# PYTHON}
\ImportTok{from}\NormalTok{ itertools }\ImportTok{import}\NormalTok{ product}

\ControlFlowTok{for}\NormalTok{ a, b, c }\KeywordTok{in}\NormalTok{ product(}\BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{), }\BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{), }\BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{)):}
    \BuiltInTok{print}\NormalTok{((a, b, c))}
\end{Highlighting}
\end{Shaded}

    The \texttt{continue} and \texttt{break} keywords work just like in
Python. Note that in single-line nested loops, \texttt{break} will exit
all loops, not just the inner loop:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{79}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{for} \PY{n}{a} \PY{k}{in} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{2}\PY{p}{,} \PY{n}{b} \PY{k}{in} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{3}\PY{p}{,} \PY{n}{c} \PY{k}{in} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{2}
    \PY{n}{println}\PY{p}{(}\PY{p}{(}\PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{,} \PY{n}{c}\PY{p}{)}\PY{p}{)}
    \PY{p}{(}\PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{,} \PY{n}{c}\PY{p}{)} \PY{o}{==} \PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)} \PY{o}{\PYZam{}\PYZam{}} \PY{k}{break}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
(1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 2, 2)
(1, 3, 1)
(1, 3, 2)
(2, 1, 1)
    \end{Verbatim}

    Julia does not support the equivalent of Python's
\texttt{for}/\texttt{else} construct. You need to write something like
this:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{80}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{found} \PY{o}{=} \PY{n+nb}{false}
\PY{k}{for} \PY{n}{person} \PY{k}{in} \PY{p}{[}\PY{l+s}{\PYZdq{}}\PY{l+s}{Joe}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{Jane}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{Wally}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{Jack}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{Julia}\PY{l+s}{\PYZdq{}}\PY{p}{]} \PY{c}{\PYZsh{} try removing \PYZdq{}Wally\PYZdq{}}
    \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Looking at }\PY{l+s+si}{\PYZdl{}person}\PY{l+s}{\PYZdq{}}\PY{p}{)}
    \PY{n}{person} \PY{o}{==} \PY{l+s}{\PYZdq{}}\PY{l+s}{Wally}\PY{l+s}{\PYZdq{}} \PY{o}{\PYZam{}\PYZam{}} \PY{p}{(}\PY{n}{found} \PY{o}{=} \PY{n+nb}{true}\PY{p}{;} \PY{k}{break}\PY{p}{)}
\PY{k}{end}
\PY{n}{found} \PY{o}{||} \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{I did not find Wally.}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Looking at Joe
Looking at Jane
Looking at Wally
    \end{Verbatim}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{80}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
true
\end{Verbatim}
\end{tcolorbox}
        
    The equivalent Python code looks like this:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# PYTHON}
\ControlFlowTok{for}\NormalTok{ person }\KeywordTok{in}\NormalTok{ [}\StringTok{"Joe"}\NormalTok{, }\StringTok{"Jane"}\NormalTok{, }\StringTok{"Wally"}\NormalTok{, }\StringTok{"Jack"}\NormalTok{, }\StringTok{"Julia"}\NormalTok{]: }\CommentTok{\# try removing "Wally"}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Looking at }\SpecialCharTok{\{}\NormalTok{person}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
    \ControlFlowTok{if}\NormalTok{ person }\OperatorTok{==} \StringTok{"Wally"}\NormalTok{:}
        \ControlFlowTok{break}
\ControlFlowTok{else}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"I did not find Wally."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

    \begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.45}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.55}}@{}}
\toprule
Julia & Python \\
\midrule
\endhead
\texttt{if\ cond1}~~~~\texttt{...}\texttt{elseif\ cond2}~~~~\texttt{...}\texttt{else}~~~~\texttt{...}\texttt{end}
&
\texttt{if\ cond1:}~~~~\texttt{...}\texttt{elif\ cond2:}~~~~\texttt{...}\texttt{else:}~~~~\texttt{...} \\
\texttt{\&\&} & \texttt{and} \\
\texttt{\textbackslash{}\textbar{}\textbackslash{}\textbar{}} &
\texttt{or} \\
\texttt{!} & \texttt{not} \\
\texttt{⊻} (type
\texttt{\textbackslash{}xor\textless{}tab\textgreater{}}) &
\texttt{\^{}} \\
\texttt{true} & \texttt{True} \\
\texttt{false} & \texttt{False} \\
\texttt{cond\ \&\&\ f()} & \texttt{if\ cond:\ f()} \\
\texttt{cond\ \textbackslash{}\textbar{}\textbackslash{}\textbar{}\ f()}
& \texttt{if\ not\ cond:\ f()} \\
\texttt{for\ i\ in\ 1:5\ ...\ end} &
\texttt{for\ i\ in\ range(1,\ 6):\ ...} \\
\texttt{for\ i\ in\ 1:5,\ j\ in\ 1:6\ ...\ end} &
\texttt{from\ itertools\ import\ product}\texttt{for\ i,\ j\ in\ product(range(1,\ 6),\ range(1,\ 7)):}~~~~\texttt{...} \\
\texttt{while\ cond\ ...\ end} & \texttt{while\ cond:\ ...} \\
\texttt{continue} & \texttt{continue} \\
\texttt{break} & \texttt{break} \\
\bottomrule
\end{longtable}

    Now lets looks at data structures, starting with tuples.

    \hypertarget{tuples}{%
\section{Tuples}\label{tuples}}

    Julia has tuples, very much like Python. They can contain anything:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{81}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{t} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{Two}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{81}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
(1, "Two", 3, 4, 5)
\end{Verbatim}
\end{tcolorbox}
        
    Let's look at one element:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{82}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{t}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{82}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
1
\end{Verbatim}
\end{tcolorbox}
        
    Hey! Did you see that? \textbf{Julia is 1-indexed}, like Matlab and
other math-oriented programming languages, not 0-indexed like Python and
most programming languages. I found it easy to get used to, and in fact
I quite like it, but your mileage may vary.

Moreover, the indexing bounds are inclusive. In Python, to get the 1st
and 2nd elements of a list or tuple, you would write \texttt{t{[}0:2{]}}
(or just \texttt{t{[}:2{]}}), while in Julia you write
\texttt{t{[}1:2{]}}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{83}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{t}\PY{p}{[}\PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{2}\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{83}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
(1, "Two")
\end{Verbatim}
\end{tcolorbox}
        
    Note that \texttt{end} represents the index of the last element in the
tuple. So you must write \texttt{t{[}end{]}} instead of
\texttt{t{[}-1{]}}. Similarly, you must write \texttt{t{[}end\ -\ 1{]}},
not \texttt{t{[}-2{]}}, and so on.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{84}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{t}\PY{p}{[}\PY{k}{end}\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{84}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
5
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{85}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{t}\PY{p}{[}\PY{k}{end} \PY{o}{\PYZhy{}} \PY{l+m+mi}{1}\PY{o}{:}\PY{k}{end}\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{85}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
(4, 5)
\end{Verbatim}
\end{tcolorbox}
        
    Like in Python, tuples are immutable:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{86}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{try}
  \PY{n}{t}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]} \PY{o}{=} \PY{l+m+mi}{2}
\PY{k}{catch} \PY{n}{ex}
  \PY{n}{ex}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{86}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
MethodError(setindex!, ((1, "Two", 3, 4, 5), 2, 2), 0x00000000000074ee)
\end{Verbatim}
\end{tcolorbox}
        
    The syntax for empty and 1-element tuples is the same as in Python:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{87}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{empty\PYZus{}tuple} \PY{o}{=} \PY{p}{(}\PY{p}{)}
\PY{n}{one\PYZus{}element\PYZus{}tuple} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{42}\PY{p}{,}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{87}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
(42,)
\end{Verbatim}
\end{tcolorbox}
        
    You can unpack a tuple, just like in Python (it's called
``destructuring'' in Julia):

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{88}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{,} \PY{n}{c}\PY{p}{,} \PY{n}{d}\PY{p}{,} \PY{n}{e} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{Two}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{)}
\PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{a=}\PY{l+s+si}{\PYZdl{}a}\PY{l+s}{, b=}\PY{l+s+si}{\PYZdl{}b}\PY{l+s}{, c=}\PY{l+s+si}{\PYZdl{}c}\PY{l+s}{, d=}\PY{l+s+si}{\PYZdl{}d}\PY{l+s}{, e=}\PY{l+s+si}{\PYZdl{}e}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
a=1, b=Two, c=3, d=4, e=5
    \end{Verbatim}

    It also works with nested tuples, just like in Python:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{89}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{p}{(}\PY{n}{a}\PY{p}{,} \PY{p}{(}\PY{n}{b}\PY{p}{,} \PY{n}{c}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{n}{d}\PY{p}{,} \PY{n}{e}\PY{p}{)}\PY{p}{)} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Two}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{)}\PY{p}{)}
\PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{a=}\PY{l+s+si}{\PYZdl{}a}\PY{l+s}{, b=}\PY{l+s+si}{\PYZdl{}b}\PY{l+s}{, c=}\PY{l+s+si}{\PYZdl{}c}\PY{l+s}{, d=}\PY{l+s+si}{\PYZdl{}d}\PY{l+s}{, e=}\PY{l+s+si}{\PYZdl{}e}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
a=1, b=Two, c=3, d=4, e=5
    \end{Verbatim}

    However, consider this example:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{90}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{,} \PY{n}{c} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{Two}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{)}
\PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{a=}\PY{l+s+si}{\PYZdl{}a}\PY{l+s}{, b=}\PY{l+s+si}{\PYZdl{}b}\PY{l+s}{, c=}\PY{l+s+si}{\PYZdl{}c}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
a=1, b=Two, c=3
    \end{Verbatim}

    In Python, this would cause a
\texttt{ValueError:\ too\ many\ values\ to\ unpack}. In Julia, the extra
values in the tuple are just ignored.

If you want to capture the extra values in the variable \texttt{c}, you
need to do so explicitly:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{91}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{t} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{Two}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{)}
\PY{n}{a}\PY{p}{,} \PY{n}{b} \PY{o}{=} \PY{n}{t}\PY{p}{[}\PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{2}\PY{p}{]}
\PY{n}{c} \PY{o}{=} \PY{n}{t}\PY{p}{[}\PY{l+m+mi}{3}\PY{o}{:}\PY{k}{end}\PY{p}{]}
\PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{a=}\PY{l+s+si}{\PYZdl{}a}\PY{l+s}{, b=}\PY{l+s+si}{\PYZdl{}b}\PY{l+s}{, c=}\PY{l+s+si}{\PYZdl{}c}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
a=1, b=Two, c=(3, 4, 5)
    \end{Verbatim}

    Or more concisely:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{92}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{p}{(}\PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{)}\PY{p}{,} \PY{n}{c} \PY{o}{=} \PY{n}{t}\PY{p}{[}\PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,} \PY{n}{t}\PY{p}{[}\PY{l+m+mi}{3}\PY{o}{:}\PY{k}{end}\PY{p}{]}
\PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{a=}\PY{l+s+si}{\PYZdl{}a}\PY{l+s}{, b=}\PY{l+s+si}{\PYZdl{}b}\PY{l+s}{, c=}\PY{l+s+si}{\PYZdl{}c}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
a=1, b=Two, c=(3, 4, 5)
    \end{Verbatim}

    The corresponding Python code is:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# PYTHON}
\NormalTok{t }\OperatorTok{=}\NormalTok{ (}\DecValTok{1}\NormalTok{, }\StringTok{"Two"}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\NormalTok{a, b, }\OperatorTok{*}\NormalTok{c }\OperatorTok{=}\NormalTok{ t}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"a=}\SpecialCharTok{\{a\}}\SpecialStringTok{, b=}\SpecialCharTok{\{b\}}\SpecialStringTok{, c=}\SpecialCharTok{\{c\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

    \hypertarget{named-tuples}{%
\subsection{Named Tuples}\label{named-tuples}}

    Julia supports named tuples:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{93}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{nt} \PY{o}{=} \PY{p}{(}\PY{n}{name}\PY{o}{=}\PY{l+s}{\PYZdq{}}\PY{l+s}{Julia}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{n}{category}\PY{o}{=}\PY{l+s}{\PYZdq{}}\PY{l+s}{Language}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{n}{stars}\PY{o}{=}\PY{l+m+mi}{5}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{93}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
(name = "Julia", category = "Language", stars = 5)
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{94}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{nt}\PY{o}{.}\PY{n}{name}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{94}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
"Julia"
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{95}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{dump}\PY{p}{(}\PY{n}{nt}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
NamedTuple\{(:name, :category, :stars), Tuple\{String, String, Int64\}\}
  name: String "Julia"
  category: String "Language"
  stars: Int64 5
    \end{Verbatim}

    The corresponding Python code is:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# PYTHON}
\ImportTok{from}\NormalTok{ collections }\ImportTok{import}\NormalTok{ namedtuple}

\NormalTok{Rating }\OperatorTok{=}\NormalTok{ namedtuple(}\StringTok{"Rating"}\NormalTok{, [}\StringTok{"name"}\NormalTok{, }\StringTok{"category"}\NormalTok{, }\StringTok{"stars"}\NormalTok{])}
\NormalTok{nt }\OperatorTok{=}\NormalTok{ Rating(name}\OperatorTok{=}\StringTok{"Julia"}\NormalTok{, category}\OperatorTok{=}\StringTok{"Language"}\NormalTok{, stars}\OperatorTok{=}\DecValTok{5}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(nt.name) }\CommentTok{\# prints: Julia}
\BuiltInTok{print}\NormalTok{(nt) }\CommentTok{\# prints: Rating(name=\textquotesingle{}Julia\textquotesingle{}, category=\textquotesingle{}Language\textquotesingle{}, stars=5)}
\end{Highlighting}
\end{Shaded}

    \hypertarget{structs}{%
\section{Structs}\label{structs}}

Julia supports structs, which hold multiple named fields, a bit like
named tuples:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{96}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{struct} \PY{k+kt}{Person}
    \PY{n}{name}
    \PY{n}{age}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    Structs have a default constructor, which expects all the field values,
in order:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{97}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{p} \PY{o}{=} \PY{n}{Person}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Mary}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+m+mi}{30}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{97}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
Person("Mary", 30)
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{98}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{p}\PY{o}{.}\PY{n}{age}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{98}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
30
\end{Verbatim}
\end{tcolorbox}
        
    You can create other constructors by creating functions with the same
name as the struct:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{99}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{function} \PY{n}{Person}\PY{p}{(}\PY{n}{name}\PY{p}{)}
    \PY{n}{Person}\PY{p}{(}\PY{n}{name}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}
\PY{k}{end}

\PY{k}{function} \PY{n}{Person}\PY{p}{(}\PY{p}{)}
    \PY{n}{Person}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{no name}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{k}{end}

\PY{n}{p} \PY{o}{=} \PY{n}{Person}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{99}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
Person("no name", -1)
\end{Verbatim}
\end{tcolorbox}
        
    This creates two constructors: the second calls the first, which calls
the default constructor. Notice that you can create multiple functions
with the same name but different arguments. We will discuss this later.

    These two constructors are called ``outer constructors'', since they are
defined outside of the definition of the struct. You can also define
``inner constructors'':

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{100}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{struct} \PY{k+kt}{Person2}
    \PY{n}{name}
    \PY{n}{age}
    \PY{k}{function} \PY{n}{Person2}\PY{p}{(}\PY{n}{name}\PY{p}{)}
        \PY{n}{new}\PY{p}{(}\PY{n}{name}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}
    \PY{k}{end}
\PY{k}{end}

\PY{k}{function} \PY{n}{Person2}\PY{p}{(}\PY{p}{)}
    \PY{n}{Person2}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{no name}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{k}{end}

\PY{n}{p} \PY{o}{=} \PY{n}{Person2}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{100}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
Person2("no name", -1)
\end{Verbatim}
\end{tcolorbox}
        
    This time, the outer constructor calls the inner constructor, which
calls the \texttt{new()} function. This \texttt{new()} function only
works in inner constructors, and of course it creates an instance of the
struct.

When you define inner constructors, they replace the default
constructor:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{101}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{try}
    \PY{n}{Person2}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Bob}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+m+mi}{40}\PY{p}{)}
\PY{k}{catch} \PY{n}{ex}
    \PY{n}{ex}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{101}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
MethodError(Person2, ("Bob", 40), 0x00000000000074f3)
\end{Verbatim}
\end{tcolorbox}
        
    Structs usually have very few inner constructors (often just one), which
do the heavy duty work, and the checks. Then they may have multiple
outer constructors which are mostly there for convenience.

    By default, structs are immutable:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{102}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{try}
    \PY{n}{p}\PY{o}{.}\PY{n}{name} \PY{o}{=} \PY{l+s}{\PYZdq{}}\PY{l+s}{Someone}\PY{l+s}{\PYZdq{}}
\PY{k}{catch} \PY{n}{ex}
    \PY{n}{ex}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{102}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
ErrorException("setfield! immutable struct of type Person2 cannot be changed")
\end{Verbatim}
\end{tcolorbox}
        
    However, it is possible to define a mutable struct:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{103}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{mutable struct} \PY{k+kt}{Person3}
    \PY{n}{name}
    \PY{n}{age}
\PY{k}{end}

\PY{n}{p} \PY{o}{=} \PY{n}{Person3}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Lucy}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+m+mi}{79}\PY{p}{)}
\PY{n}{p}\PY{o}{.}\PY{n}{age} \PY{o}{+=} \PY{l+m+mi}{1}
\PY{n}{p}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{103}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
Person3("Lucy", 80)
\end{Verbatim}
\end{tcolorbox}
        
    Structs look a lot like Python classes, with instance variables and
constructors, but where are the methods? We will discuss this later, in
the ``Methods'' section.

    \hypertarget{arrays}{%
\section{Arrays}\label{arrays}}

Let's create a small array:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{104}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{a} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{9}\PY{p}{,} \PY{l+m+mi}{16}\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{104}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
4-element Vector\{Int64\}:
  1
  4
  9
 16
\end{Verbatim}
\end{tcolorbox}
        
    Indexing and assignments work as you would expect:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{105}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{a}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]} \PY{o}{=} \PY{l+m+mi}{10}
\PY{n}{a}\PY{p}{[}\PY{l+m+mi}{2}\PY{o}{:}\PY{l+m+mi}{3}\PY{p}{]} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{20}\PY{p}{,} \PY{l+m+mi}{30}\PY{p}{]}
\PY{n}{a}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{105}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
4-element Vector\{Int64\}:
 10
 20
 30
 16
\end{Verbatim}
\end{tcolorbox}
        
    \hypertarget{element-type}{%
\subsection{Element Type}\label{element-type}}

Since we used only integers when creating the array, Julia inferred that
the array is only meant to hold integers (NumPy arrays behave the same
way). Let's try adding a string:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{106}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{try}
  \PY{n}{a}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]} \PY{o}{=} \PY{l+s}{\PYZdq{}}\PY{l+s}{Three}\PY{l+s}{\PYZdq{}}
\PY{k}{catch} \PY{n}{ex}
  \PY{n}{ex}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{106}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
MethodError(convert, (Int64, "Three"), 0x00000000000074f4)
\end{Verbatim}
\end{tcolorbox}
        
    Nope! We get a \texttt{MethodError} exception, telling us that Julia
could not convert the string \texttt{"Three"} to a 64-bit integer (we
will discuss exceptions later). If we want an array that can hold any
type, like Python's lists can, we must prefix the array with
\texttt{Any}, which is Julia's root type (like \texttt{object} in
Python):

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{107}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{a} \PY{o}{=} \PY{k+kt}{Any}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{9}\PY{p}{,} \PY{l+m+mi}{16}\PY{p}{]}
\PY{n}{a}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]} \PY{o}{=} \PY{l+s}{\PYZdq{}}\PY{l+s}{Three}\PY{l+s}{\PYZdq{}}
\PY{n}{a}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{107}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
4-element Vector\{Any\}:
  1
  4
   "Three"
 16
\end{Verbatim}
\end{tcolorbox}
        
    Prefixing with \texttt{Float64}, or \texttt{String} or any other type
works as well:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{108}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kt}{Float64}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{9}\PY{p}{,} \PY{l+m+mi}{16}\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{108}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
4-element Vector\{Float64\}:
  1.0
  4.0
  9.0
 16.0
\end{Verbatim}
\end{tcolorbox}
        
    An empty array is automatically an \texttt{Any} array:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{109}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{a} \PY{o}{=} \PY{p}{[}\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{109}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
Any[]
\end{Verbatim}
\end{tcolorbox}
        
    You can use the \texttt{eltype()} function to get an array's element
type (the equivalent of NumPy arrays' \texttt{dtype}):

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{110}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{eltype}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{9}\PY{p}{,} \PY{l+m+mi}{16}\PY{p}{]}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{110}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
Int64
\end{Verbatim}
\end{tcolorbox}
        
    If you create an array containing objects of different types, Julia will
do its best to use a type that can hold all the values as precisely as
possible. For example, a mix of integers and floats results in a float
array:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{111}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mf}{3.0}\PY{p}{,} \PY{l+m+mf}{4.0}\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{111}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
4-element Vector\{Float64\}:
 1.0
 2.0
 3.0
 4.0
\end{Verbatim}
\end{tcolorbox}
        
    This is similar to NumPy's behavior:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# PYTHON}
\NormalTok{np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\FloatTok{3.0}\NormalTok{, }\FloatTok{4.0}\NormalTok{]) }\CommentTok{\# =\textgreater{} array([1., 2., 3., 4.])}
\end{Highlighting}
\end{Shaded}

A mix of unrelated types results in an \texttt{Any} array:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{112}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{Three}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{112}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
4-element Vector\{Any\}:
 1
 2
  "Three"
 4
\end{Verbatim}
\end{tcolorbox}
        
    If you want to live in a world without type constraints, you can prefix
all you arrays with \texttt{Any}, and you will feel like you're coding
in Python. But I don't recommend it: the compiler can perform a bunch of
optimizations when it knows exactly the type and size of the data the
program will handle, so it will run much faster. So when you create an
empty array but you know the type of the values it will contain, you
might as well prefix it with that type (you don't have to, but it will
speed up your program).

    \hypertarget{push-and-pop}{%
\subsection{Push and Pop}\label{push-and-pop}}

To append elements to an array, use the \texttt{push!()} function. By
convention, functions whose name ends with a bang \texttt{!} may modify
their arguments:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{113}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{a} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}
\PY{n}{push!}\PY{p}{(}\PY{n}{a}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{)}
\PY{n}{push!}\PY{p}{(}\PY{n}{a}\PY{p}{,} \PY{l+m+mi}{9}\PY{p}{,} \PY{l+m+mi}{16}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{113}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
4-element Vector\{Int64\}:
  1
  4
  9
 16
\end{Verbatim}
\end{tcolorbox}
        
    This is similar to the following Python code:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# PYTHON}
\NormalTok{a }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{]}
\NormalTok{a.append(}\DecValTok{4}\NormalTok{)}
\NormalTok{a.extend([}\DecValTok{9}\NormalTok{, }\DecValTok{16}\NormalTok{]) }\CommentTok{\# or simply a += [9, 16]}
\end{Highlighting}
\end{Shaded}

    And \texttt{pop!()} works like in Python:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{114}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{pop!}\PY{p}{(}\PY{n}{a}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{114}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
16
\end{Verbatim}
\end{tcolorbox}
        
    Equivalent to:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# PYTHON}
\NormalTok{a.pop()}
\end{Highlighting}
\end{Shaded}

    There are many more functions you can call on an array. We will see
later how to find them.

    \hypertarget{multidimensional-arrays}{%
\subsection{Multidimensional Arrays}\label{multidimensional-arrays}}

Importantly, Julia arrays can be multidimensional, just like NumPy
arrays:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{115}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{M} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}   \PY{l+m+mi}{2}   \PY{l+m+mi}{3}   \PY{l+m+mi}{4}
     \PY{l+m+mi}{5}   \PY{l+m+mi}{6}   \PY{l+m+mi}{7}   \PY{l+m+mi}{8}
     \PY{l+m+mi}{9}  \PY{l+m+mi}{10}  \PY{l+m+mi}{11}  \PY{l+m+mi}{12}\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{115}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
3×4 Matrix\{Int64\}:
 1   2   3   4
 5   6   7   8
 9  10  11  12
\end{Verbatim}
\end{tcolorbox}
        
    Another syntax for this is:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{116}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{M} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1} \PY{l+m+mi}{2} \PY{l+m+mi}{3} \PY{l+m+mi}{4}\PY{p}{;} \PY{l+m+mi}{5} \PY{l+m+mi}{6} \PY{l+m+mi}{7} \PY{l+m+mi}{8}\PY{p}{;} \PY{l+m+mi}{9} \PY{l+m+mi}{10} \PY{l+m+mi}{11} \PY{l+m+mi}{12}\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{116}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
3×4 Matrix\{Int64\}:
 1   2   3   4
 5   6   7   8
 9  10  11  12
\end{Verbatim}
\end{tcolorbox}
        
    You can index them much like NumPy arrays:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{117}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{M}\PY{p}{[}\PY{l+m+mi}{2}\PY{o}{:}\PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{3}\PY{o}{:}\PY{l+m+mi}{4}\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{117}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
2×2 Matrix\{Int64\}:
  7   8
 11  12
\end{Verbatim}
\end{tcolorbox}
        
    You can transpose a matrix using the ``adjoint'' operator
\texttt{\textquotesingle{}}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{118}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{M}\PY{o}{\PYZsq{}}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{118}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
4×3 adjoint(::Matrix\{Int64\}) with eltype Int64:
 1  5   9
 2  6  10
 3  7  11
 4  8  12
\end{Verbatim}
\end{tcolorbox}
        
    As you can see, Julia arrays are closer to NumPy arrays than to Python
lists.

    Arrays can be concatenated vertically using the \texttt{vcat()}
function:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{119}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{M1} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1} \PY{l+m+mi}{2}
      \PY{l+m+mi}{3} \PY{l+m+mi}{4}\PY{p}{]}
\PY{n}{M2} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{5} \PY{l+m+mi}{6}
      \PY{l+m+mi}{7} \PY{l+m+mi}{8}\PY{p}{]}
\PY{n}{vcat}\PY{p}{(}\PY{n}{M1}\PY{p}{,} \PY{n}{M2}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{119}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
4×2 Matrix\{Int64\}:
 1  2
 3  4
 5  6
 7  8
\end{Verbatim}
\end{tcolorbox}
        
    Alternatively, you can use the \texttt{{[}M1;\ M2{]}} syntax:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{120}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{p}{[}\PY{n}{M1}\PY{p}{;} \PY{n}{M2}\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{120}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
4×2 Matrix\{Int64\}:
 1  2
 3  4
 5  6
 7  8
\end{Verbatim}
\end{tcolorbox}
        
    To concatenate arrays horizontally, use \texttt{hcat()}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{121}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{hcat}\PY{p}{(}\PY{n}{M1}\PY{p}{,} \PY{n}{M2}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{121}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
2×4 Matrix\{Int64\}:
 1  2  5  6
 3  4  7  8
\end{Verbatim}
\end{tcolorbox}
        
    Or you can use the \texttt{{[}M1\ M2{]}} syntax:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{122}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{p}{[}\PY{n}{M1} \PY{n}{M2}\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{122}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
2×4 Matrix\{Int64\}:
 1  2  5  6
 3  4  7  8
\end{Verbatim}
\end{tcolorbox}
        
    You can combine horizontal and vertical concatenation:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{123}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{M3} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{9} \PY{l+m+mi}{10} \PY{l+m+mi}{11} \PY{l+m+mi}{12}\PY{p}{]}
\PY{p}{[}\PY{n}{M1} \PY{n}{M2}\PY{p}{;} \PY{n}{M3}\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{123}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
3×4 Matrix\{Int64\}:
 1   2   5   6
 3   4   7   8
 9  10  11  12
\end{Verbatim}
\end{tcolorbox}
        
    Equivalently, you can call the \texttt{hvcat()} function. The first
argument specifies the number of arguments to concatenate in each block
row:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{124}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{hvcat}\PY{p}{(}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{,} \PY{n}{M1}\PY{p}{,} \PY{n}{M2}\PY{p}{,} \PY{n}{M3}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{124}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
3×4 Matrix\{Int64\}:
 1   2   5   6
 3   4   7   8
 9  10  11  12
\end{Verbatim}
\end{tcolorbox}
        
    \texttt{hvcat()} is useful to create a single cell matrix:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{125}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{hvcat}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{42}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{125}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
1×1 Matrix\{Int64\}:
 42
\end{Verbatim}
\end{tcolorbox}
        
    Or a column vector (i.e., an \emph{n}×1 matrix = a matrix with a single
column):

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{126}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{hvcat}\PY{p}{(}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{11}\PY{p}{,} \PY{l+m+mi}{12}\PY{p}{)} \PY{c}{\PYZsh{} a column vector with values 10, 11, 12}
\PY{n}{hvcat}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{11}\PY{p}{,} \PY{l+m+mi}{12}\PY{p}{)} \PY{c}{\PYZsh{} equivalent to the previous line}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{126}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
3×1 Matrix\{Int64\}:
 10
 11
 12
\end{Verbatim}
\end{tcolorbox}
        
    Alternatively, you can transpose a row vector (but \texttt{hvcat()} is a
bit faster):

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{127}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{p}{[}\PY{l+m+mi}{10} \PY{l+m+mi}{11} \PY{l+m+mi}{12}\PY{p}{]}\PY{o}{\PYZsq{}}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{127}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
3×1 adjoint(::Matrix\{Int64\}) with eltype Int64:
 10
 11
 12
\end{Verbatim}
\end{tcolorbox}
        
    The REPL and IJulia call \texttt{display()} to print the result of the
last expression in a cell (except when it is \texttt{nothing}). It is
fairly verbose:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{128}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{display}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{]}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    
    \begin{Verbatim}[commandchars=\\\{\}]
4-element Vector\{Int64\}:
 1
 2
 3
 4
    \end{Verbatim}

    
    The \texttt{println()} function is more concise, but be careful not to
confuse vectors, column vectors and row vectors (printed with commas,
semi-colons and spaces, respectively):

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{129}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Vector: }\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{]}\PY{p}{)}
\PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Column vector: }\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{n}{hvcat}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{)}\PY{p}{)}
\PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Row vector: }\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{p}{[}\PY{l+m+mi}{1} \PY{l+m+mi}{2} \PY{l+m+mi}{3} \PY{l+m+mi}{4}\PY{p}{]}\PY{p}{)}
\PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Matrix: }\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{p}{[}\PY{l+m+mi}{1} \PY{l+m+mi}{2} \PY{l+m+mi}{3}\PY{p}{;} \PY{l+m+mi}{4} \PY{l+m+mi}{5} \PY{l+m+mi}{6}\PY{p}{]}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Vector: [1, 2, 3, 4]
Column vector: [1; 2; 3; 4]
Row vector: [1 2 3 4]
Matrix: [1 2 3; 4 5 6]
    \end{Verbatim}

    Although column vectors are printed as \texttt{{[}1;\ 2;\ 3;\ 4{]}},
evaluating \texttt{{[}1;\ 2;\ 3;\ 4{]}} will give you a regular vector.
That's because \texttt{{[}x;y{]}} concatenates \texttt{x} and \texttt{y}
vertically, and if \texttt{x} and \texttt{y} are scalars or vectors, you
just get a regular vector.

    \begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.45}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.55}}@{}}
\toprule
Julia & Python \\
\midrule
\endhead
\texttt{a\ =\ {[}1,\ 2,\ 3{]}} &
\texttt{a\ =\ {[}1,\ 2,\ 3{]}}or\texttt{import\ numpy\ as\ np}\texttt{np.array({[}1,\ 2,\ 3{]})} \\
\texttt{a{[}1{]}} & \texttt{a{[}0{]}} \\
\texttt{a{[}end{]}} & \texttt{a{[}-1{]}} \\
\texttt{a{[}2:end-1{]}} & \texttt{a{[}1:-1{]}} \\
\texttt{push!(a,\ 5)} & \texttt{a.append(5)} \\
\texttt{pop!(a)} & \texttt{a.pop()} \\
\texttt{M\ =\ {[}1\ 2\ 3{]}} &
\texttt{np.array({[}{[}1,\ 2,\ 3{]}{]})} \\
\texttt{M\ =\ {[}1\ 2\ 3{]}\textquotesingle{}} &
\texttt{np.array({[}{[}1,\ 2,\ 3{]}{]}).T} \\
\texttt{M\ =\ hvcat(1,\ \ 1,\ 2,\ 3)} &
\texttt{np.array({[}{[}1{]},\ {[}2{]},\ {[}3{]}{]})} \\
\texttt{M\ =\ {[}1\ 2\ 3}~ ~ ~ ~ ~
~\texttt{4\ 5\ 6{]}}or\texttt{M\ =\ {[}1\ 2\ 3;\ 4\ 5\ 6{]}} &
\texttt{M\ =\ np.array({[}{[}1,2,3{]},\ {[}4,5,6{]}{]})} \\
\texttt{M{[}1:2,\ 2:3{]}} & \texttt{M{[}0:2,\ 1:3{]}} \\
\texttt{{[}M1;\ M2{]}} & \texttt{np.r\_{[}M1,\ M2{]}} \\
\texttt{{[}M1\ \ M2{]}} & \texttt{np.c\_{[}M1,\ M2{]}} \\
\texttt{{[}M1\ M2;\ M3{]}} &
\texttt{np.r\_{[}np.c\_{[}M1,\ M2{]},\ M3{]}} \\
\bottomrule
\end{longtable}

    \hypertarget{comprehensions}{%
\subsection{Comprehensions}\label{comprehensions}}

List comprehensions are available in Julia, just like in Python (they're
usually just called ``comprehensions'' in Julia):

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{130}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{a} \PY{o}{=} \PY{p}{[}\PY{n}{x}\PY{o}{\PYZca{}}\PY{l+m+mi}{2} \PY{k}{for} \PY{n}{x} \PY{k}{in} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{4}\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{130}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
4-element Vector\{Int64\}:
  1
  4
  9
 16
\end{Verbatim}
\end{tcolorbox}
        
    You can filter elements using an \texttt{if} clause, just like in
Python:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{131}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{a} \PY{o}{=} \PY{p}{[}\PY{n}{x}\PY{o}{\PYZca{}}\PY{l+m+mi}{2} \PY{k}{for} \PY{n}{x} \PY{k}{in} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{5} \PY{k}{if} \PY{n}{x} \PY{o}{∉} \PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{)}\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{131}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
3-element Vector\{Int64\}:
  1
  9
 25
\end{Verbatim}
\end{tcolorbox}
        
    \begin{itemize}
\tightlist
\item
  \texttt{a\ ∉\ b} is equivalent to \texttt{!(a\ in\ b)} (or
  \texttt{a\ not\ in\ b} in Python). You can type \texttt{∉} with
  \texttt{\textbackslash{}notin\textless{}tab\textgreater{}}
\item
  \texttt{a\ ∈\ b} is equivalent to \texttt{a\ in\ b}. You can type it
  with \texttt{\textbackslash{}in\textless{}tab\textgreater{}}
\end{itemize}

    In Julia, comprehensions can contain nested loops, just like in Python:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{132}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{a} \PY{o}{=} \PY{p}{[}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{n}{j}\PY{p}{)} \PY{k}{for} \PY{n}{i} \PY{k}{in} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{3} \PY{k}{for} \PY{n}{j} \PY{k}{in} \PY{l+m+mi}{1}\PY{o}{:}\PY{n}{i}\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{132}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
6-element Vector\{Tuple\{Int64, Int64\}\}:
 (1, 1)
 (2, 1)
 (2, 2)
 (3, 1)
 (3, 2)
 (3, 3)
\end{Verbatim}
\end{tcolorbox}
        
    Here's the corresponding Python code:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# PYTHON}
\NormalTok{a }\OperatorTok{=}\NormalTok{ [(i, j) }\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{) }\ControlFlowTok{for}\NormalTok{ j }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, i}\OperatorTok{+}\DecValTok{1}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

    Julia comprehensions can also create multi-dimensional arrays (note the
different syntax: there is only one \texttt{for}):

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{133}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{a} \PY{o}{=} \PY{p}{[}\PY{n}{row} \PY{o}{*} \PY{n}{col} \PY{k}{for} \PY{n}{row} \PY{k}{in} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{3}\PY{p}{,} \PY{n}{col} \PY{k}{in} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{5}\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{133}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
3×5 Matrix\{Int64\}:
 1  2  3   4   5
 2  4  6   8  10
 3  6  9  12  15
\end{Verbatim}
\end{tcolorbox}
        
    \hypertarget{dictionaries}{%
\section{Dictionaries}\label{dictionaries}}

The syntax for dictionaries is a bit different than Python:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{134}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{d} \PY{o}{=} \PY{k+kt}{Dict}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{tree}\PY{l+s}{\PYZdq{}}\PY{o}{=\PYZgt{}}\PY{l+s}{\PYZdq{}}\PY{l+s}{arbre}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{love}\PY{l+s}{\PYZdq{}}\PY{o}{=\PYZgt{}}\PY{l+s}{\PYZdq{}}\PY{l+s}{amour}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{coffee}\PY{l+s}{\PYZdq{}}\PY{o}{=\PYZgt{}}\PY{l+s}{\PYZdq{}}\PY{l+s}{café}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{n}{println}\PY{p}{(}\PY{n}{d}\PY{p}{[}\PY{l+s}{\PYZdq{}}\PY{l+s}{tree}\PY{l+s}{\PYZdq{}}\PY{p}{]}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
arbre
    \end{Verbatim}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{135}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{println}\PY{p}{(}\PY{n}{get}\PY{p}{(}\PY{n}{d}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{unknown}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{pardon?}\PY{l+s}{\PYZdq{}}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
pardon?
    \end{Verbatim}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{136}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{keys}\PY{p}{(}\PY{n}{d}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{136}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
KeySet for a Dict\{String, String\} with 3 entries. Keys:
  "coffee"
  "tree"
  "love"
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{137}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{values}\PY{p}{(}\PY{n}{d}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{137}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
ValueIterator for a Dict\{String, String\} with 3 entries. Values:
  "café"
  "arbre"
  "amour"
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{138}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{haskey}\PY{p}{(}\PY{n}{d}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{love}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{138}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
true
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{139}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{l+s}{\PYZdq{}}\PY{l+s}{love}\PY{l+s}{\PYZdq{}} \PY{k}{in} \PY{n}{keys}\PY{p}{(}\PY{n}{d}\PY{p}{)} \PY{c}{\PYZsh{} this is slower than haskey()}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{139}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
true
\end{Verbatim}
\end{tcolorbox}
        
    The equivalent Python code is of course:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d }\OperatorTok{=}\NormalTok{ \{}\StringTok{"tree"}\NormalTok{: }\StringTok{"arbre"}\NormalTok{, }\StringTok{"love"}\NormalTok{: }\StringTok{"amour"}\NormalTok{, }\StringTok{"coffee"}\NormalTok{: }\StringTok{"café"}\NormalTok{\}}
\NormalTok{d[}\StringTok{"tree"}\NormalTok{]}
\NormalTok{d.get(}\StringTok{"unknown"}\NormalTok{, }\StringTok{"pardon?"}\NormalTok{)}
\NormalTok{d.keys()}
\NormalTok{d.values()}
\CommentTok{"love"} \KeywordTok{in}\NormalTok{ d}
\CommentTok{"love"} \KeywordTok{in}\NormalTok{ d.keys()}
\end{Highlighting}
\end{Shaded}

    Dict comprehensions work as you would expect:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{140}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{d} \PY{o}{=} \PY{k+kt}{Dict}\PY{p}{(}\PY{n}{i}\PY{o}{=\PYZgt{}}\PY{n}{i}\PY{o}{\PYZca{}}\PY{l+m+mi}{2} \PY{k}{for} \PY{n}{i} \PY{k}{in} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{5}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{140}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
Dict\{Int64, Int64\} with 5 entries:
  5 => 25
  4 => 16
  2 => 4
  3 => 9
  1 => 1
\end{Verbatim}
\end{tcolorbox}
        
    Note that the items (aka ``pairs'' in Julia) are shuffled, since
dictionaries are hash-based, like in Python (although Python sorts them
by key for display).

You can easily iterate through the dictionary's pairs like this:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{141}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{for} \PY{p}{(}\PY{n}{k}\PY{p}{,} \PY{n}{v}\PY{p}{)} \PY{k}{in} \PY{n}{d}
    \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s+si}{\PYZdl{}k}\PY{l+s}{ maps to }\PY{l+s+si}{\PYZdl{}v}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
5 maps to 25
4 maps to 16
2 maps to 4
3 maps to 9
1 maps to 1
    \end{Verbatim}

    The equivalent code in Python is:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# PYTHON}
\NormalTok{d }\OperatorTok{=}\NormalTok{ \{i: i}\OperatorTok{**}\DecValTok{2} \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{6}\NormalTok{)\}}
\ControlFlowTok{for}\NormalTok{ k, v }\KeywordTok{in}\NormalTok{ d.items():}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\SpecialCharTok{\{k\}}\SpecialStringTok{ maps to }\SpecialCharTok{\{v\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

    And you can merge dictionaries like this:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{142}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{d1} \PY{o}{=} \PY{k+kt}{Dict}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{tree}\PY{l+s}{\PYZdq{}}\PY{o}{=\PYZgt{}}\PY{l+s}{\PYZdq{}}\PY{l+s}{arbre}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{love}\PY{l+s}{\PYZdq{}}\PY{o}{=\PYZgt{}}\PY{l+s}{\PYZdq{}}\PY{l+s}{amour}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{coffee}\PY{l+s}{\PYZdq{}}\PY{o}{=\PYZgt{}}\PY{l+s}{\PYZdq{}}\PY{l+s}{café}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{n}{d2} \PY{o}{=} \PY{k+kt}{Dict}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{car}\PY{l+s}{\PYZdq{}}\PY{o}{=\PYZgt{}}\PY{l+s}{\PYZdq{}}\PY{l+s}{voiture}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{love}\PY{l+s}{\PYZdq{}}\PY{o}{=\PYZgt{}}\PY{l+s}{\PYZdq{}}\PY{l+s}{aimer}\PY{l+s}{\PYZdq{}}\PY{p}{)}

\PY{n}{d} \PY{o}{=} \PY{n}{merge}\PY{p}{(}\PY{n}{d1}\PY{p}{,} \PY{n}{d2}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{142}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
Dict\{String, String\} with 4 entries:
  "car"    => "voiture"
  "coffee" => "café"
  "tree"   => "arbre"
  "love"   => "aimer"
\end{Verbatim}
\end{tcolorbox}
        
    Notice that the second dictionary has priority in case of conflict (it's
\texttt{"love"\ =\textgreater{}\ "aimer"}, not
\texttt{"love"\ =\textgreater{}\ "amour"}).

    In Python, this would be:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# PYTHON}
\NormalTok{d1 }\OperatorTok{=}\NormalTok{ \{}\StringTok{"tree"}\NormalTok{: }\StringTok{"arbre"}\NormalTok{, }\StringTok{"love"}\NormalTok{: }\StringTok{"amour"}\NormalTok{, }\StringTok{"coffee"}\NormalTok{: }\StringTok{"café"}\NormalTok{\}}
\NormalTok{d2 }\OperatorTok{=}\NormalTok{ \{}\StringTok{"car"}\NormalTok{: }\StringTok{"voiture"}\NormalTok{, }\StringTok{"love"}\NormalTok{: }\StringTok{"aimer"}\NormalTok{\}}
\NormalTok{d }\OperatorTok{=}\NormalTok{ \{}\OperatorTok{**}\NormalTok{d1, }\OperatorTok{**}\NormalTok{d2\}}
\end{Highlighting}
\end{Shaded}

    Or if you want to update the first dictionary instead of creating a new
one:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{143}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{merge!}\PY{p}{(}\PY{n}{d1}\PY{p}{,} \PY{n}{d2}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{143}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
Dict\{String, String\} with 4 entries:
  "car"    => "voiture"
  "coffee" => "café"
  "tree"   => "arbre"
  "love"   => "aimer"
\end{Verbatim}
\end{tcolorbox}
        
    In Python, that's:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# PYTHON}
\NormalTok{d1.update(d2)}
\end{Highlighting}
\end{Shaded}

    In Julia, each pair is an actual \texttt{Pair} object:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{144}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{p} \PY{o}{=} \PY{l+s}{\PYZdq{}}\PY{l+s}{tree}\PY{l+s}{\PYZdq{}} \PY{o}{=\PYZgt{}} \PY{l+s}{\PYZdq{}}\PY{l+s}{arbre}\PY{l+s}{\PYZdq{}}
\PY{n}{println}\PY{p}{(}\PY{n}{typeof}\PY{p}{(}\PY{n}{p}\PY{p}{)}\PY{p}{)}
\PY{n}{k}\PY{p}{,} \PY{n}{v} \PY{o}{=} \PY{n}{p}
\PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s+si}{\PYZdl{}k}\PY{l+s}{ maps to }\PY{l+s+si}{\PYZdl{}v}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Pair\{String, String\}
tree maps to arbre
    \end{Verbatim}

    Note that any object for which a \texttt{hash()} method is implemented
can be used as a key in a dictionary. This includes all the basic types
like integers, floats, as well as string, tuples, etc. But it also
includes arrays! In Julia, you have the freedom to use arrays as keys
(unlike in Python), but make sure not to mutate these arrays after
insertion, or else things will break! Indeed, the pairs will be stored
in memory in a location that depends on the hash of the key at insertion
time, so if that key changes afterwards, you won't be able to find the
pair anymore:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{145}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{a} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{]}
\PY{n}{d} \PY{o}{=} \PY{k+kt}{Dict}\PY{p}{(}\PY{n}{a} \PY{o}{=\PYZgt{}} \PY{l+s}{\PYZdq{}}\PY{l+s}{My array}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{The dictionary is: }\PY{l+s+si}{\PYZdl{}d}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Indexing works fine as long as the array is unchanged: }\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{n}{d}\PY{p}{[}\PY{n}{a}\PY{p}{]}\PY{p}{)}
\PY{n}{a}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]} \PY{o}{=} \PY{l+m+mi}{10}
\PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{This is the dictionary now: }\PY{l+s+si}{\PYZdl{}d}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{k}{try}
    \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Key changed, indexing is now broken: }\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{n}{d}\PY{p}{[}\PY{n}{a}\PY{p}{]}\PY{p}{)}
\PY{k}{catch} \PY{n}{ex}
    \PY{n}{ex}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
The dictionary is: Dict([1, 2, 3] => "My array")
Indexing works fine as long as the array is unchanged: My array
This is the dictionary now: Dict([10, 2, 3] => "My array")
    \end{Verbatim}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{145}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
KeyError([10, 2, 3])
\end{Verbatim}
\end{tcolorbox}
        
    However, it's still possible to iterate through the keys, the values or
the pairs:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{146}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{for} \PY{n}{pair} \PY{k}{in} \PY{n}{d}
    \PY{n}{println}\PY{p}{(}\PY{n}{pair}\PY{p}{)}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
[10, 2, 3] => "My array"
    \end{Verbatim}

    \begin{longtable}[]{@{}ll@{}}
\toprule
Julia & Python \\
\midrule
\endhead
\texttt{Dict("tree"=\textgreater{}"arbre",\ "love"=\textgreater{}"amour")}
& \texttt{\{"tree":\ "arbre",\ "love":\ "amour"\}} \\
\texttt{d{[}"arbre"{]}} & \texttt{d{[}"arbre"{]}} \\
\texttt{get(d,\ "unknown",\ "default")} &
\texttt{d.get("unknown",\ "default")} \\
\texttt{keys(d)} & \texttt{d.keys()} \\
\texttt{values(d)} & \texttt{d.values()} \\
\texttt{haskey(d,\ k)} & \texttt{k\ in\ d} \\
\texttt{Dict(i=\textgreater{}i\^{}2\ for\ i\ in\ 1:4)} &
\texttt{\{i:\ i**2\ for\ i\ in\ 1:4\}} \\
\texttt{for\ (k,\ v)\ in\ d} & \texttt{for\ k,\ v\ in\ d.items():} \\
\texttt{merge(d1,\ d2)} & \texttt{\{**d1,\ **d2\}} \\
\texttt{merge!(d1,\ d2)} & \texttt{d1.update(d2)} \\
\bottomrule
\end{longtable}

    \hypertarget{sets}{%
\section{Sets}\label{sets}}

    Let's create a couple sets:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{147}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{odd} \PY{o}{=} \PY{k+kt}{Set}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{,} \PY{l+m+mi}{7}\PY{p}{,} \PY{l+m+mi}{9}\PY{p}{,} \PY{l+m+mi}{11}\PY{p}{]}\PY{p}{)}
\PY{n}{prime} \PY{o}{=} \PY{k+kt}{Set}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{,} \PY{l+m+mi}{7}\PY{p}{,} \PY{l+m+mi}{11}\PY{p}{]}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{147}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
Set\{Int64\} with 5 elements:
  5
  7
  2
  11
  3
\end{Verbatim}
\end{tcolorbox}
        
    The order of sets is not guaranteed, just like in Python.

    Use \texttt{in} or \texttt{∈} (type
\texttt{\textbackslash{}in\textless{}tab\textgreater{}}) to check
whether a set contains a given value:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{148}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{l+m+mi}{5} \PY{o}{∈} \PY{n}{odd}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{148}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
true
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{149}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{l+m+mi}{5} \PY{k}{in} \PY{n}{odd}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{149}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
true
\end{Verbatim}
\end{tcolorbox}
        
    Both of these expressions are equivalent to:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{150}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{in}\PY{p}{(}\PY{l+m+mi}{5}\PY{p}{,} \PY{n}{odd}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{150}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
true
\end{Verbatim}
\end{tcolorbox}
        
    Now let's get the union of these two sets:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{151}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{odd} \PY{o}{∪} \PY{n}{prime}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{151}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
Set\{Int64\} with 7 elements:
  5
  7
  1
  11
  2
  9
  3
\end{Verbatim}
\end{tcolorbox}
        
    ∪ is the union symbol, not a U. To type this character, type
\texttt{\textbackslash{}cup\textless{}tab\textgreater{}} (it has the
shape of a cup). Alternatively, you can just use the \texttt{union()}
function:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{152}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{union}\PY{p}{(}\PY{n}{odd}\PY{p}{,} \PY{n}{prime}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{152}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
Set\{Int64\} with 7 elements:
  5
  7
  1
  11
  2
  9
  3
\end{Verbatim}
\end{tcolorbox}
        
    Now let's get the intersection using the ∩ symbol (type
\texttt{\textbackslash{}cap\textless{}tab\textgreater{}}):

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{153}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{odd} \PY{o}{∩} \PY{n}{prime}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{153}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
Set\{Int64\} with 4 elements:
  5
  7
  11
  3
\end{Verbatim}
\end{tcolorbox}
        
    Or use the \texttt{intersect()} function:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{154}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{intersect}\PY{p}{(}\PY{n}{odd}\PY{p}{,} \PY{n}{prime}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{154}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
Set\{Int64\} with 4 elements:
  5
  7
  11
  3
\end{Verbatim}
\end{tcolorbox}
        
    Next, let's get the
\href{https://en.wikipedia.org/wiki/Complement_(set_theory)\#Relative_complement}{set
difference} and the
\href{https://en.wikipedia.org/wiki/Symmetric_difference}{symetric
difference} between these two sets:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{155}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{setdiff}\PY{p}{(}\PY{n}{odd}\PY{p}{,} \PY{n}{prime}\PY{p}{)} \PY{c}{\PYZsh{} values in odd but not in prime}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{155}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
Set\{Int64\} with 2 elements:
  9
  1
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{156}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{symdiff}\PY{p}{(}\PY{n}{odd}\PY{p}{,} \PY{n}{prime}\PY{p}{)} \PY{c}{\PYZsh{} values that are not in the intersection}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{156}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
Set\{Int64\} with 3 elements:
  2
  9
  1
\end{Verbatim}
\end{tcolorbox}
        
    Lastly, set comprehensions work just fine:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{157}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kt}{Set}\PY{p}{(}\PY{p}{[}\PY{n}{i}\PY{o}{\PYZca{}}\PY{l+m+mi}{2} \PY{k}{for} \PY{n}{i} \PY{k}{in} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{4}\PY{p}{]}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{157}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
Set\{Int64\} with 4 elements:
  4
  16
  9
  1
\end{Verbatim}
\end{tcolorbox}
        
    The equivalent Python code is:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# PYTHON}
\NormalTok{odds }\OperatorTok{=}\NormalTok{ \{}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{11}\NormalTok{\}}
\NormalTok{primes }\OperatorTok{=}\NormalTok{ \{}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{11}\NormalTok{\}}
\DecValTok{5} \KeywordTok{in}\NormalTok{ primes}
\NormalTok{odds }\OperatorTok{|}\NormalTok{ primes }\CommentTok{\# union}
\NormalTok{odds.union(primes)}
\NormalTok{odds }\OperatorTok{\&}\NormalTok{ primes }\CommentTok{\# intersection}
\NormalTok{odds.intersection(primes)}
\NormalTok{odds }\OperatorTok{{-}}\NormalTok{ primes }\CommentTok{\# set difference}
\NormalTok{odds.difference(primes)}
\NormalTok{odds }\OperatorTok{\^{}}\NormalTok{ primes }\CommentTok{\# symmetric difference}
\NormalTok{odds.symmetric\_difference(primes)}
\NormalTok{\{i}\OperatorTok{**}\DecValTok{2} \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{)\}}
\end{Highlighting}
\end{Shaded}

    Note that you can store any hashable object in a \texttt{Set} (i.e., any
instance of a type for which the \texttt{hash()} method is implemented).
This includes arrays, unlike in Python. Just like for dictionary keys,
you can add arrays to sets, but make sure not to mutate them after
insertion.

    \begin{longtable}[]{@{}ll@{}}
\toprule
Julia & Python \\
\midrule
\endhead
\texttt{Set({[}1,\ 3,\ 5,\ 7{]})} & \texttt{\{1,\ 3,\ 5,\ 7\}} \\
\texttt{5\ in\ odd} & \texttt{5\ in\ odd} \\
\texttt{Set({[}i\^{}2\ for\ i\ in\ 1:4{]})} &
\texttt{\{i**2\ for\ i\ in\ range(1,\ 5)\}} \\
\texttt{odd\ ∪\ primes} & \texttt{odd\ \textbar{}\ primes} \\
\texttt{union(odd,\ primes)} & \texttt{odd.union(primes)} \\
\texttt{odd\ ∩\ primes} & \texttt{odd\ \&\ primes} \\
\texttt{insersect(odd,\ primes)} & \texttt{odd.intersection(primes)} \\
\texttt{setdiff(odd,\ primes)} & \texttt{odd\ -\ primes} or
\texttt{odd.difference(primes)} \\
\texttt{symdiff(odd,\ primes)} & \texttt{odd\ \^{}\ primes} or
\texttt{odd.symmetric\_difference(primes)} \\
\bottomrule
\end{longtable}

    \hypertarget{enums}{%
\section{Enums}\label{enums}}

    To create an enum, use the \texttt{@enum} macro:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{158}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nd}{@enum} \PY{n}{Fruit} \PY{n}{apple}\PY{o}{=}\PY{l+m+mi}{1} \PY{n}{banana}\PY{o}{=}\PY{l+m+mi}{2} \PY{n}{orange}\PY{o}{=}\PY{l+m+mi}{3}
\end{Verbatim}
\end{tcolorbox}

    This creates the \texttt{Fruit} enum, with 3 possible values. It also
binds the names to the values:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{159}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{banana}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{159}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
banana::Fruit = 2
\end{Verbatim}
\end{tcolorbox}
        
    Or you can get a \texttt{Fruit} instance using the value:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{160}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{Fruit}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{160}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
banana::Fruit = 2
\end{Verbatim}
\end{tcolorbox}
        
    And you can get all the instances of the enum easily:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{161}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{instances}\PY{p}{(}\PY{n}{Fruit}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{161}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
(apple, banana, orange)
\end{Verbatim}
\end{tcolorbox}
        
    \begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.45}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.55}}@{}}
\toprule
Julia & Python \\
\midrule
\endhead
\texttt{@enum\ Fruit\ apple=1\ banana=2\ orange=3} &
\texttt{from\ enum\ import\ Enum}\texttt{class\ Fruit(Enum):}~~~~\texttt{APPLE\ =\ 1}~~~~\texttt{BANANA\ =\ 2}~~~~\texttt{ORANGE\ =\ 3} \\
\texttt{Fruit(2)\ ===\ banana} & \texttt{Fruit(2)\ is\ Fruit.BANANA} \\
\texttt{instances(Fruit)} & \texttt{dir(Fruit)} \\
\bottomrule
\end{longtable}

    \hypertarget{object-identity}{%
\section{Object Identity}\label{object-identity}}

In the previous example, \texttt{Fruit(2)} and \texttt{banana} refer to
the same object, not just two objects that happen to be equal. You can
verify using the \texttt{===} operator, which is the equivalent of
Python's \texttt{is} operator:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{162}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{banana} \PY{o}{===} \PY{n}{Fruit}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{162}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
true
\end{Verbatim}
\end{tcolorbox}
        
    You can also check this by looking at their \texttt{objectid()}, which
is the equivalent of Python's \texttt{id()} function:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{163}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{objectid}\PY{p}{(}\PY{n}{banana}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{163}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
0x00000000671ca988
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{164}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{objectid}\PY{p}{(}\PY{n}{Fruit}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{164}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
0x00000000671ca988
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{165}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{a} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{]}
\PY{n}{b} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{]}
\PY{n+nd}{@assert} \PY{n}{a} \PY{o}{==} \PY{n}{b}  \PY{c}{\PYZsh{} a and b are equal}
\PY{n+nd}{@assert} \PY{n}{a} \PY{o}{!==} \PY{n}{b} \PY{c}{\PYZsh{} but they are not the same object}
\end{Verbatim}
\end{tcolorbox}

    \begin{longtable}[]{@{}ll@{}}
\toprule
Julia & Python \\
\midrule
\endhead
\texttt{a\ ===\ b} & \texttt{a\ is\ b} \\
\texttt{a\ !==\ b} & \texttt{a\ is\ not\ b} \\
\texttt{objectid(obj)} & \texttt{id(obj)} \\
\bottomrule
\end{longtable}

    \hypertarget{other-collections}{%
\section{Other Collections}\label{other-collections}}

For the Julia equivalent of Python's other collections, namely
\texttt{defaultdict}, \texttt{deque}, \texttt{OrderedDict}, and
\texttt{Counter}, check out these libraries:

\begin{itemize}
\tightlist
\item
  https://github.com/JuliaCollections/DataStructures.jl
\item
  https://github.com/JuliaCollections/OrderedCollections.jl
\item
  https://github.com/andyferris/Dictionaries.jl
\end{itemize}

    Now let's looks at various iteration constructs.

    \hypertarget{iteration-tools}{%
\section{Iteration Tools}\label{iteration-tools}}

    \hypertarget{generator-expressions}{%
\subsection{Generator Expressions}\label{generator-expressions}}

Just like in Python, a generator expression resembles a list
comprehension, but without the square brackets, and it returns a
generator instead of a list. Here's a much shorter implementation of the
\texttt{estimate\_pi()} function using a generator expression:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{166}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{function} \PY{n}{estimate\PYZus{}pi2}\PY{p}{(}\PY{n}{n}\PY{p}{)}
    \PY{l+m+mi}{4} \PY{o}{*} \PY{n}{sum}\PY{p}{(}\PY{p}{(}\PY{n}{isodd}\PY{p}{(}\PY{n}{i}\PY{p}{)} \PY{o}{?} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1} \PY{o}{:} \PY{l+m+mi}{1}\PY{p}{)}\PY{o}{/}\PY{p}{(}\PY{l+m+mi}{2}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{)} \PY{k}{for} \PY{n}{i} \PY{k}{in} \PY{l+m+mi}{0}\PY{o}{:}\PY{n}{n}\PY{p}{)}
\PY{k}{end}

\PY{n+nd}{@assert} \PY{n}{estimate\PYZus{}pi}\PY{p}{(}\PY{l+m+mi}{100}\PY{p}{)} \PY{o}{==} \PY{n}{estimate\PYZus{}pi2}\PY{p}{(}\PY{l+m+mi}{100}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    That's very similar to the corresponding Python code:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# PYTHON}
\KeywordTok{def}\NormalTok{ estimate\_pi2(n):}
  \ControlFlowTok{return} \DecValTok{4} \OperatorTok{*} \BuiltInTok{sum}\NormalTok{((}\OperatorTok{{-}}\DecValTok{1} \ControlFlowTok{if}\NormalTok{ i}\OperatorTok{\%}\DecValTok{2}\OperatorTok{==}\DecValTok{1} \ControlFlowTok{else} \DecValTok{1}\NormalTok{)}\OperatorTok{/}\NormalTok{(}\DecValTok{2}\OperatorTok{*}\NormalTok{i}\OperatorTok{+}\DecValTok{1}\NormalTok{) }\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(n}\OperatorTok{+}\DecValTok{1}\NormalTok{))}

\ControlFlowTok{assert}\NormalTok{ estimate\_pi(}\DecValTok{100}\NormalTok{) }\OperatorTok{==}\NormalTok{ estimate\_pi2(}\DecValTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

    \hypertarget{zip-enumerate-collect}{%
\subsection{\texorpdfstring{\texttt{zip}, \texttt{enumerate},
\texttt{collect}}{zip, enumerate, collect}}\label{zip-enumerate-collect}}

    The \texttt{zip()} function works much like in Python:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{167}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{for} \PY{p}{(}\PY{n}{i}\PY{p}{,} \PY{n}{s}\PY{p}{)} \PY{k}{in} \PY{n}{zip}\PY{p}{(}\PY{l+m+mi}{10}\PY{o}{:}\PY{l+m+mi}{13}\PY{p}{,} \PY{p}{[}\PY{l+s}{\PYZdq{}}\PY{l+s}{Ten}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{Eleven}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{Twelve}\PY{l+s}{\PYZdq{}}\PY{p}{]}\PY{p}{)}
    \PY{n}{println}\PY{p}{(}\PY{n}{i}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{: }\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{n}{s}\PY{p}{)}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
10: Ten
11: Eleven
12: Twelve
    \end{Verbatim}

    Notice that the parentheses in \texttt{for\ (i,\ s)} are required in
Julia, as opposed to Python.

    The \texttt{enumerate()} function also works like in Python, except of
course it is 1-indexed:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{168}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{for} \PY{p}{(}\PY{n}{i}\PY{p}{,} \PY{n}{s}\PY{p}{)} \PY{k}{in} \PY{n}{enumerate}\PY{p}{(}\PY{p}{[}\PY{l+s}{\PYZdq{}}\PY{l+s}{One}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{Two}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{Three}\PY{l+s}{\PYZdq{}}\PY{p}{]}\PY{p}{)}
    \PY{n}{println}\PY{p}{(}\PY{n}{i}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{: }\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{n}{s}\PY{p}{)}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
1: One
2: Two
3: Three
    \end{Verbatim}

    To pull the values of a generator into an array, use \texttt{collect()}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{169}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{collect}\PY{p}{(}\PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{5}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{169}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
5-element Vector\{Int64\}:
 1
 2
 3
 4
 5
\end{Verbatim}
\end{tcolorbox}
        
    A shorter syntax for that is:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{170}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{p}{[}\PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{5}\PY{p}{;}\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{170}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
5-element Vector\{Int64\}:
 1
 2
 3
 4
 5
\end{Verbatim}
\end{tcolorbox}
        
    The equivalent Python code is:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# PYTHON}
\BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{6}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

    \hypertarget{generators}{%
\subsection{Generators}\label{generators}}

In Python, you can easily write a generator function to create an object
that will behave like an iterator. For example, let's create a generator
for the Fibonacci sequence (where each number is the sum of the two
previous numbers):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ fibonacci(n):}
\NormalTok{    a, b }\OperatorTok{=} \DecValTok{1}\NormalTok{, }\DecValTok{1}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(n):}
      \ControlFlowTok{yield}\NormalTok{ a}
\NormalTok{      a, b }\OperatorTok{=}\NormalTok{ b, a }\OperatorTok{+}\NormalTok{ b}

\ControlFlowTok{for}\NormalTok{ f }\KeywordTok{in}\NormalTok{ fibonacci(}\DecValTok{10}\NormalTok{):}
    \BuiltInTok{print}\NormalTok{(f)}
\end{Highlighting}
\end{Shaded}

    This is also quite easy in Julia:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{171}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{function} \PY{n}{fibonacci}\PY{p}{(}\PY{n}{n}\PY{p}{)}
    \PY{k+kt}{Channel}\PY{p}{(}\PY{p}{)} \PY{k}{do} \PY{n}{ch}
        \PY{n}{a}\PY{p}{,} \PY{n}{b} \PY{o}{=} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{1}
        \PY{k}{for} \PY{n}{i} \PY{k}{in} \PY{l+m+mi}{1}\PY{o}{:}\PY{n}{n}
            \PY{n}{put!}\PY{p}{(}\PY{n}{ch}\PY{p}{,} \PY{n}{a}\PY{p}{)}
            \PY{n}{a}\PY{p}{,} \PY{n}{b} \PY{o}{=} \PY{n}{b}\PY{p}{,} \PY{n}{a} \PY{o}{+} \PY{n}{b}
        \PY{k}{end}
    \PY{k}{end}
\PY{k}{end}

\PY{k}{for} \PY{n}{f} \PY{k}{in} \PY{n}{fibonacci}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}
    \PY{n}{println}\PY{p}{(}\PY{n}{f}\PY{p}{)}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
1
1
2
3
5
8
13
21
34
55
    \end{Verbatim}

    The \texttt{Channel} type is part of the API for tasks and coroutines.
We'll discuss these later.

    Now let's take a closer look at functions.

    \hypertarget{functions}{%
\section{Functions}\label{functions}}

    \hypertarget{arguments}{%
\subsection{Arguments}\label{arguments}}

Julia functions supports positional arguments and default values:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{172}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{function} \PY{n}{draw\PYZus{}face}\PY{p}{(}\PY{n}{x}\PY{p}{,} \PY{n}{y}\PY{p}{,} \PY{n}{width}\PY{o}{=}\PY{l+m+mi}{3}\PY{p}{,} \PY{n}{height}\PY{o}{=}\PY{l+m+mi}{4}\PY{p}{)}
    \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{x=}\PY{l+s+si}{\PYZdl{}x}\PY{l+s}{, y=}\PY{l+s+si}{\PYZdl{}y}\PY{l+s}{, width=}\PY{l+s+si}{\PYZdl{}width}\PY{l+s}{, height=}\PY{l+s+si}{\PYZdl{}height}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{k}{end}

\PY{n}{draw\PYZus{}face}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{20}\PY{p}{,} \PY{l+m+mi}{30}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
x=10, y=20, width=30, height=4
    \end{Verbatim}

    However, unlike in Python, positional arguments must not be named when
the function is called:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{173}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{try}
    \PY{n}{draw\PYZus{}face}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{20}\PY{p}{,} \PY{n}{width}\PY{o}{=}\PY{l+m+mi}{30}\PY{p}{)}
\PY{k}{catch} \PY{n}{ex}
    \PY{n}{ex}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{173}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
MethodError(var"\#draw\_face\#\#kw"(), ((width = 30,), draw\_face, 10, 20),
0x0000000000007508)
\end{Verbatim}
\end{tcolorbox}
        
    Julia also supports a variable number of arguments (called ``varargs'')
using the syntax \texttt{arg...}, which is the equivalent of Python's
\texttt{*arg}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{174}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{function} \PY{n}{copy\PYZus{}files}\PY{p}{(}\PY{n}{target\PYZus{}dir}\PY{p}{,} \PY{n}{paths}\PY{o}{...}\PY{p}{)}
    \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{target\PYZus{}dir=}\PY{l+s+si}{\PYZdl{}target\PYZus{}dir}\PY{l+s}{, paths=}\PY{l+s+si}{\PYZdl{}paths}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{k}{end}

\PY{n}{copy\PYZus{}files}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{/tmp}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{a.txt}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{b.txt}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
target\_dir=/tmp, paths=("a.txt", "b.txt")
    \end{Verbatim}

    Keyword arguments are supported, after a semicolon \texttt{;}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{175}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{function} \PY{n}{copy\PYZus{}files2}\PY{p}{(}\PY{n}{paths}\PY{o}{...}\PY{p}{;} \PY{n}{confirm}\PY{o}{=}\PY{n+nb}{false}\PY{p}{,} \PY{n}{target\PYZus{}dir}\PY{p}{)}
    \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{paths=}\PY{l+s+si}{\PYZdl{}paths}\PY{l+s}{, confirm=}\PY{l+s+si}{\PYZdl{}confirm}\PY{l+s}{, }\PY{l+s+si}{\PYZdl{}target\PYZus{}dir}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{k}{end}

\PY{n}{copy\PYZus{}files2}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{a.txt}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{b.txt}\PY{l+s}{\PYZdq{}}\PY{p}{;} \PY{n}{target\PYZus{}dir}\PY{o}{=}\PY{l+s}{\PYZdq{}}\PY{l+s}{/tmp}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
paths=("a.txt", "b.txt"), confirm=false, /tmp
    \end{Verbatim}

    Notes: * \texttt{target\_dir} has no default value, so it is a required
argument. * The order of the keyword arguments does not matter.

    You can have another vararg in the keyword section. It corresponds to
Python's \texttt{**kwargs}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{176}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{function} \PY{n}{copy\PYZus{}files3}\PY{p}{(}\PY{n}{paths}\PY{o}{...}\PY{p}{;} \PY{n}{confirm}\PY{o}{=}\PY{n+nb}{false}\PY{p}{,} \PY{n}{target\PYZus{}dir}\PY{p}{,} \PY{n}{options}\PY{o}{...}\PY{p}{)}
    \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{paths=}\PY{l+s+si}{\PYZdl{}paths}\PY{l+s}{, confirm=}\PY{l+s+si}{\PYZdl{}confirm}\PY{l+s}{, }\PY{l+s+si}{\PYZdl{}target\PYZus{}dir}\PY{l+s}{\PYZdq{}}\PY{p}{)}
    \PY{n}{verbose} \PY{o}{=} \PY{n}{options}\PY{p}{[}\PY{l+s+ss}{:verbose}\PY{p}{]}
    \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{verbose=}\PY{l+s+si}{\PYZdl{}verbose}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{k}{end}

\PY{n}{copy\PYZus{}files3}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{a.txt}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{b.txt}\PY{l+s}{\PYZdq{}}\PY{p}{;} \PY{n}{target\PYZus{}dir}\PY{o}{=}\PY{l+s}{\PYZdq{}}\PY{l+s}{/tmp}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{n}{verbose}\PY{o}{=}\PY{n+nb}{true}\PY{p}{,} \PY{n}{timeout}\PY{o}{=}\PY{l+m+mi}{60}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
paths=("a.txt", "b.txt"), confirm=false, /tmp
verbose=true
    \end{Verbatim}

    The \texttt{options} vararg acts like a dictionary (we will discuss
dictionaries later). The keys are \textbf{symbols}, e.g.,
\texttt{:verbose}. Symbols are like strings, less flexible but faster.
They are typically used as keys or identifiers.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.45}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.55}}@{}}
\toprule
Julia & Python (3.8+ if \texttt{/} is used) \\
\midrule
\endhead
\texttt{function\ foo(a,\ b=2,\ c=3)}~~~~\texttt{...}\texttt{end}\texttt{foo(1,\ 2)\ \#\ positional\ only}
&
\texttt{def\ foo(a,\ b=2,\ c=3,\ /):}~~~~\texttt{...}\texttt{foo(1,\ 2)\ \#\ pos\ only\ because\ of\ /} \\
\texttt{function\ foo(;a=1,\ b,\ c=3)}~~~~\texttt{...}\texttt{end}\texttt{foo(c=30,\ b=2)\ \#\ keyword\ only}
&
\texttt{def\ foo(*,\ a=1,\ b,\ c=3):}~~~~\texttt{...}\texttt{foo(c=30,\ b=2)\ \#\ kw\ only\ because\ of\ *} \\
\texttt{function\ foo(a,\ b=2;\ c=3,\ d)}~~~~\texttt{...}\texttt{end}\texttt{foo(1;\ d=4)\ \#\ pos\ only;\ then\ keyword\ only}
&
\texttt{def\ foo(a,\ b=2,\ /,\ *,\ c=3,\ d):}~~~~\texttt{...}\texttt{foo(1,\ d=4)\ \#\ pos\ only\ then\ kw\ only} \\
\texttt{function\ foo(a,\ b=2,\ c...)}~~~~\texttt{...}\texttt{end}\texttt{foo(1,\ 2,\ 3,\ 4)\ \#\ positional\ only}
&
\texttt{def\ foo(a,\ b=2,\ /,\ *c):}~~~~\texttt{...}\texttt{foo(1,\ 2,\ 3,\ 4)\ \#\ positional\ only} \\
\texttt{function\ foo(a,\ b=1,\ c...;\ d=1,\ e,\ f...)}~~~~\texttt{...}\texttt{end}\texttt{foo(1,\ 2,\ 3,\ 4,\ e=5,\ x=10,\ y=20)}
&
\texttt{def\ foo(a,\ b=1,\ /,\ *c,\ d=1,\ e,\ **f):}~~~~\texttt{...}\texttt{foo(1,\ 2,\ 3,\ 4,\ e=5,\ x=10,\ y=20)} \\
\bottomrule
\end{longtable}

    \hypertarget{concise-functions}{%
\subsection{Concise Functions}\label{concise-functions}}

In Julia, the following definition:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{177}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{square}\PY{p}{(}\PY{n}{x}\PY{p}{)} \PY{o}{=} \PY{n}{x}\PY{o}{\PYZca{}}\PY{l+m+mi}{2}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{177}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
square (generic function with 1 method)
\end{Verbatim}
\end{tcolorbox}
        
    is equivalent to:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{178}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{function} \PY{n}{square}\PY{p}{(}\PY{n}{x}\PY{p}{)}
    \PY{n}{x}\PY{o}{\PYZca{}}\PY{l+m+mi}{2}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{178}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
square (generic function with 1 method)
\end{Verbatim}
\end{tcolorbox}
        
    For example, here's a shorter way to define the \texttt{estimate\_pi()}
function in Julia:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{179}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{estimate\PYZus{}pi3}\PY{p}{(}\PY{n}{n}\PY{p}{)} \PY{o}{=} \PY{l+m+mi}{4} \PY{o}{*} \PY{n}{sum}\PY{p}{(}\PY{p}{(}\PY{n}{isodd}\PY{p}{(}\PY{n}{i}\PY{p}{)} \PY{o}{?} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1} \PY{o}{:} \PY{l+m+mi}{1}\PY{p}{)}\PY{o}{/}\PY{p}{(}\PY{l+m+mi}{2}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{)} \PY{k}{for} \PY{n}{i} \PY{k}{in} \PY{l+m+mi}{0}\PY{o}{:}\PY{n}{n}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{179}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
estimate\_pi3 (generic function with 1 method)
\end{Verbatim}
\end{tcolorbox}
        
    To define a function on one line in Python, you need to use a
\texttt{lambda} (but this is generally frowned upon, since the resulting
function's name is \texttt{"\textless{}lambda\textgreater{}"}):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# PYTHON}
\NormalTok{square }\OperatorTok{=} \KeywordTok{lambda}\NormalTok{ x: x}\OperatorTok{**}\DecValTok{2}
\ControlFlowTok{assert}\NormalTok{ square.}\VariableTok{\_\_name\_\_} \OperatorTok{==} \StringTok{"\textless{}lambda\textgreater{}"}
\end{Highlighting}
\end{Shaded}

    This leads us to anonymous functions.

    \hypertarget{anonymous-functions}{%
\subsection{Anonymous Functions}\label{anonymous-functions}}

Just like in Python, you can define anonymous functions:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{180}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{map}\PY{p}{(}\PY{n}{x} \PY{o}{\PYZhy{}\PYZgt{}} \PY{n}{x}\PY{o}{\PYZca{}}\PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{4}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{180}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
4-element Vector\{Int64\}:
  1
  4
  9
 16
\end{Verbatim}
\end{tcolorbox}
        
    Here is the equivalent Python code:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{list}\NormalTok{(}\BuiltInTok{map}\NormalTok{(}\KeywordTok{lambda}\NormalTok{ x: x}\OperatorTok{**}\DecValTok{2}\NormalTok{, }\BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

Notes: * \texttt{map()} returns an array in Julia, instead of an
iterator like in Python. * You could use a comprehension instead:
\texttt{{[}x\^{}2\ for\ x\ in\ 1:4{]}}.

    \begin{longtable}[]{@{}ll@{}}
\toprule
Julia & Python \\
\midrule
\endhead
\texttt{x\ -\textgreater{}\ x\^{}2} & \texttt{lambda\ x:\ x**2} \\
\texttt{(x,y)\ -\textgreater{}\ x\ +\ y} &
\texttt{lambda\ x,y:\ x\ +\ y} \\
\texttt{()\ -\textgreater{}\ println("yes")} &
\texttt{lambda:\ print("yes")} \\
\bottomrule
\end{longtable}

    In Python, lambda functions must be simple expressions. They cannot
contain multiple statements. In Julia, they can be as long as you want.
Indeed, you can create a multi-statement block using the syntax
\texttt{(stmt\_1;\ stmt\_2;\ ...;\ stmt\_n)}. The return value is the
output of the last statement. For example:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{181}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{map}\PY{p}{(}\PY{n}{x} \PY{o}{\PYZhy{}\PYZgt{}} \PY{p}{(}\PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Number }\PY{l+s+si}{\PYZdl{}x}\PY{l+s}{\PYZdq{}}\PY{p}{)}\PY{p}{;} \PY{n}{x}\PY{o}{\PYZca{}}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{4}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Number 1
Number 2
Number 3
Number 4
    \end{Verbatim}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{181}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
4-element Vector\{Int64\}:
  1
  4
  9
 16
\end{Verbatim}
\end{tcolorbox}
        
    This syntax can span multiple lines:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{182}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{map}\PY{p}{(}\PY{n}{x} \PY{o}{\PYZhy{}\PYZgt{}} \PY{p}{(}
  \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Number }\PY{l+s+si}{\PYZdl{}x}\PY{l+s}{\PYZdq{}}\PY{p}{)}\PY{p}{;}
  \PY{n}{x}\PY{o}{\PYZca{}}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{4}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Number 1
Number 2
Number 3
Number 4
    \end{Verbatim}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{182}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
4-element Vector\{Int64\}:
  1
  4
  9
 16
\end{Verbatim}
\end{tcolorbox}
        
    But in this case, it's probably clearer to use the
\texttt{begin\ ...\ end} syntax instead:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{183}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{map}\PY{p}{(}\PY{n}{x} \PY{o}{\PYZhy{}\PYZgt{}} \PY{k}{begin}
        \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Number }\PY{l+s+si}{\PYZdl{}x}\PY{l+s}{\PYZdq{}}\PY{p}{)}
        \PY{n}{x}\PY{o}{\PYZca{}}\PY{l+m+mi}{2}
    \PY{k}{end}\PY{p}{,} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{4}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Number 1
Number 2
Number 3
Number 4
    \end{Verbatim}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{183}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
4-element Vector\{Int64\}:
  1
  4
  9
 16
\end{Verbatim}
\end{tcolorbox}
        
    Notice that this syntax allows you to drop the semicolons \texttt{;} at
the end of each line in the block.

Yet another way to define an anonymous function is using the
\texttt{function\ (args)\ ...\ end} syntax:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{184}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{map}\PY{p}{(}\PY{k}{function} \PY{p}{(}\PY{n}{x}\PY{p}{)}
        \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Number }\PY{l+s+si}{\PYZdl{}x}\PY{l+s}{\PYZdq{}}\PY{p}{)}
        \PY{n}{x}\PY{o}{\PYZca{}}\PY{l+m+mi}{2}
    \PY{k}{end}\PY{p}{,} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{4}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Number 1
Number 2
Number 3
Number 4
    \end{Verbatim}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{184}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
4-element Vector\{Int64\}:
  1
  4
  9
 16
\end{Verbatim}
\end{tcolorbox}
        
    Lastly, if you're passing the anonymous function as the first argument
to a function (as is the case in this example), it's usually much
preferable to define the anonymous function immediately after the
function call, using the \texttt{do} syntax, like this:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{185}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{map}\PY{p}{(}\PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{4}\PY{p}{)} \PY{k}{do} \PY{n}{x}
  \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Number }\PY{l+s+si}{\PYZdl{}x}\PY{l+s}{\PYZdq{}}\PY{p}{)}
  \PY{n}{x}\PY{o}{\PYZca{}}\PY{l+m+mi}{2}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Number 1
Number 2
Number 3
Number 4
    \end{Verbatim}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{185}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
4-element Vector\{Int64\}:
  1
  4
  9
 16
\end{Verbatim}
\end{tcolorbox}
        
    This syntax lets you easily define constructs that feel like language
extensions:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{186}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{function} \PY{n}{my\PYZus{}for}\PY{p}{(}\PY{n}{func}\PY{p}{,} \PY{n}{collection}\PY{p}{)}
    \PY{k}{for} \PY{n}{i} \PY{k}{in} \PY{n}{collection}
        \PY{n}{func}\PY{p}{(}\PY{n}{i}\PY{p}{)}
    \PY{k}{end}
\PY{k}{end}

\PY{n}{my\PYZus{}for}\PY{p}{(}\PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{4}\PY{p}{)} \PY{k}{do} \PY{n}{i}
    \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{The square of }\PY{l+s+si}{\PYZdl{}i}\PY{l+s}{ is }\PY{l+s+si}{\PYZdl{}}\PY{p}{(}\PY{n}{i}\PY{o}{\PYZca{}}\PY{l+m+mi}{2}\PY{p}{)}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
The square of 1 is 1
The square of 2 is 4
The square of 3 is 9
The square of 4 is 16
    \end{Verbatim}

    In fact, Julia has a similar \texttt{foreach()} function.

    The \texttt{do} syntax could be used to write a Domain Specific Language
(DSL), for example an infrastructure automation DSL:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{187}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{function} \PY{n}{spawn\PYZus{}server}\PY{p}{(}\PY{n}{startup\PYZus{}func}\PY{p}{,} \PY{n}{server\PYZus{}type}\PY{p}{)}
    \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Starting }\PY{l+s+si}{\PYZdl{}server\PYZus{}type}\PY{l+s}{ server}\PY{l+s}{\PYZdq{}}\PY{p}{)}
    \PY{n}{server\PYZus{}id} \PY{o}{=} \PY{l+m+mi}{1234}
    \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Configuring server }\PY{l+s+si}{\PYZdl{}server\PYZus{}id}\PY{l+s}{...}\PY{l+s}{\PYZdq{}}\PY{p}{)}
    \PY{n}{startup\PYZus{}func}\PY{p}{(}\PY{n}{server\PYZus{}id}\PY{p}{)}
\PY{k}{end}

\PY{c}{\PYZsh{} This is the DSL part}
\PY{n}{spawn\PYZus{}server}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{web}\PY{l+s}{\PYZdq{}}\PY{p}{)} \PY{k}{do} \PY{n}{server\PYZus{}id}
    \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Creating HTML pages on server }\PY{l+s+si}{\PYZdl{}server\PYZus{}id}\PY{l+s}{...}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Starting web server
Configuring server 1234{\ldots}
Creating HTML pages on server 1234{\ldots}
    \end{Verbatim}

    It's also quite nice for event-driven code:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{188}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{handlers} \PY{o}{=} \PY{p}{[}\PY{p}{]}

\PY{n}{on\PYZus{}click}\PY{p}{(}\PY{n}{handler}\PY{p}{)} \PY{o}{=} \PY{n}{push!}\PY{p}{(}\PY{n}{handlers}\PY{p}{,} \PY{n}{handler}\PY{p}{)}

\PY{n}{click}\PY{p}{(}\PY{n}{event}\PY{p}{)} \PY{o}{=} \PY{n}{foreach}\PY{p}{(}\PY{n}{handler}\PY{o}{\PYZhy{}\PYZgt{}}\PY{n}{handler}\PY{p}{(}\PY{n}{event}\PY{p}{)}\PY{p}{,} \PY{n}{handlers}\PY{p}{)}

\PY{n}{on\PYZus{}click}\PY{p}{(}\PY{p}{)} \PY{k}{do} \PY{n}{event}
    \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Mouse clicked at }\PY{l+s+si}{\PYZdl{}event}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{k}{end}

\PY{n}{on\PYZus{}click}\PY{p}{(}\PY{p}{)} \PY{k}{do} \PY{n}{event}
    \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Beep.}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{k}{end}

\PY{n}{click}\PY{p}{(}\PY{p}{(}\PY{n}{x}\PY{o}{=}\PY{l+m+mi}{50}\PY{p}{,} \PY{n}{y}\PY{o}{=}\PY{l+m+mi}{20}\PY{p}{)}\PY{p}{)}
\PY{n}{click}\PY{p}{(}\PY{p}{(}\PY{n}{x}\PY{o}{=}\PY{l+m+mi}{120}\PY{p}{,} \PY{n}{y}\PY{o}{=}\PY{l+m+mi}{10}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Mouse clicked at (x = 50, y = 20)
Beep.
Mouse clicked at (x = 120, y = 10)
Beep.
    \end{Verbatim}

    It can also be used to create context managers, for example to
automatically close an object after it has been used, even if an
exception is raised:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{189}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{function} \PY{n}{with\PYZus{}database}\PY{p}{(}\PY{n}{func}\PY{p}{,} \PY{n}{name}\PY{p}{)}
    \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Opening connection to database }\PY{l+s+si}{\PYZdl{}name}\PY{l+s}{\PYZdq{}}\PY{p}{)}
    \PY{n}{db} \PY{o}{=} \PY{l+s}{\PYZdq{}}\PY{l+s}{a db object for database }\PY{l+s+si}{\PYZdl{}name}\PY{l+s}{\PYZdq{}}
    \PY{k}{try}
        \PY{n}{func}\PY{p}{(}\PY{n}{db}\PY{p}{)}
    \PY{k}{finally}
        \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Closing connection to database }\PY{l+s+si}{\PYZdl{}name}\PY{l+s}{\PYZdq{}}\PY{p}{)}
    \PY{k}{end}
\PY{k}{end}

\PY{n}{with\PYZus{}database}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{jobs}\PY{l+s}{\PYZdq{}}\PY{p}{)} \PY{k}{do} \PY{n}{db}
    \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{I\PYZsq{}m working with }\PY{l+s+si}{\PYZdl{}db}\PY{l+s}{\PYZdq{}}\PY{p}{)}
    \PY{c}{\PYZsh{}error(\PYZdq{}Oops\PYZdq{}) \PYZsh{} try uncommenting this line}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Opening connection to database jobs
I'm working with a db object for database jobs
Closing connection to database jobs
    \end{Verbatim}

    The equivalent code in Python would look like this:

    \begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# PYTHON}
\KeywordTok{class}\NormalTok{ Database:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, name):}
        \VariableTok{self}\NormalTok{.name }\OperatorTok{=}\NormalTok{ name}
    \KeywordTok{def} \FunctionTok{\_\_enter\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{):}
        \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Opening connection to database }\SpecialCharTok{\{}\VariableTok{self}\SpecialCharTok{.}\NormalTok{name}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
        \ControlFlowTok{return} \SpecialStringTok{f"a db object for database }\SpecialCharTok{\{}\VariableTok{self}\SpecialCharTok{.}\NormalTok{name}\SpecialCharTok{\}}\SpecialStringTok{"}
    \KeywordTok{def} \FunctionTok{\_\_exit\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, }\BuiltInTok{type}\NormalTok{, value, traceback):}
        \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Closing connection to database }\SpecialCharTok{\{}\VariableTok{self}\SpecialCharTok{.}\NormalTok{name}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\ControlFlowTok{with}\NormalTok{ Database(}\StringTok{"jobs"}\NormalTok{) }\ImportTok{as}\NormalTok{ db:}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"I\textquotesingle{}m working with }\SpecialCharTok{\{db\}}\SpecialStringTok{"}\NormalTok{)}
    \CommentTok{\#raise Exception("Oops") \# try uncommenting this line}
\end{Highlighting}
\end{Shaded}

Or you could use \texttt{contextlib}:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ contextlib }\ImportTok{import}\NormalTok{ contextmanager}

\AttributeTok{@contextmanager}
\KeywordTok{def}\NormalTok{ database(name):}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Opening connection to database }\SpecialCharTok{\{}\NormalTok{name}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\NormalTok{    db }\OperatorTok{=} \SpecialStringTok{f"a db object for database }\SpecialCharTok{\{}\NormalTok{name}\SpecialCharTok{\}}\SpecialStringTok{"}
    \ControlFlowTok{try}\NormalTok{:}
        \ControlFlowTok{yield}\NormalTok{ db}
    \ControlFlowTok{finally}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Closing connection to database }\SpecialCharTok{\{}\NormalTok{name}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\ControlFlowTok{with}\NormalTok{ database(}\StringTok{"jobs"}\NormalTok{) }\ImportTok{as}\NormalTok{ db:}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"I\textquotesingle{}m working with }\SpecialCharTok{\{db\}}\SpecialStringTok{"}\NormalTok{)}
    \CommentTok{\#raise Exception("Oops") \# try uncommenting this line}
\end{Highlighting}
\end{Shaded}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]

\end{Verbatim}
\end{tcolorbox}

    \hypertarget{piping}{%
\subsection{Piping}\label{piping}}

If you are used to the Object Oriented syntax
\texttt{"a\ b\ c".upper().split()}, you may feel that writing
\texttt{split(uppercase("a\ b\ c"))} is a bit backwards. If so, the
piping operation \texttt{\textbar{}\textgreater{}} is for you:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{190}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{l+s}{\PYZdq{}}\PY{l+s}{a b c}\PY{l+s}{\PYZdq{}} \PY{o}{|\PYZgt{}} \PY{n}{uppercase} \PY{o}{|\PYZgt{}} \PY{n}{split}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{190}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
3-element Vector\{SubString\{String\}\}:
 "A"
 "B"
 "C"
\end{Verbatim}
\end{tcolorbox}
        
    If you want to pass more than one argument to some of the functions, you
can use anonymous functions:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{191}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{l+s}{\PYZdq{}}\PY{l+s}{a b c}\PY{l+s}{\PYZdq{}} \PY{o}{|\PYZgt{}} \PY{n}{uppercase} \PY{o}{|\PYZgt{}} \PY{n}{split} \PY{o}{|\PYZgt{}} \PY{n}{tokens}\PY{o}{\PYZhy{}\PYZgt{}}\PY{n}{join}\PY{p}{(}\PY{n}{tokens}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{, }\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{191}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
"A, B, C"
\end{Verbatim}
\end{tcolorbox}
        
    The dotted version of the pipe operator works as you might expect,
applying the \emph{i}th function of the right array to the \emph{i}th
value in the left array:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{192}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{p}{[}\PY{n+nb}{π}\PY{o}{/}\PY{l+m+mi}{2}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{hello}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{]} \PY{o}{.|\PYZgt{}} \PY{p}{[}\PY{n}{sin}\PY{p}{,} \PY{n}{length}\PY{p}{,} \PY{n}{x}\PY{o}{\PYZhy{}\PYZgt{}}\PY{n}{x}\PY{o}{\PYZca{}}\PY{l+m+mi}{2}\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{192}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
3-element Vector\{Real\}:
  1.0
  5
 16
\end{Verbatim}
\end{tcolorbox}
        
    \hypertarget{composition}{%
\subsection{Composition}\label{composition}}

Julia also lets you compose functions like mathematicians do, using the
composition operator ∘
(\texttt{\textbackslash{}circ\textless{}tab\textgreater{}} in the REPL
or Jupyter):

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{193}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{f} \PY{o}{=} \PY{n}{exp} \PY{o}{∘} \PY{n}{sin} \PY{o}{∘} \PY{n}{sqrt}
\PY{n}{f}\PY{p}{(}\PY{l+m+mf}{2.0}\PY{p}{)} \PY{o}{==} \PY{n}{exp}\PY{p}{(}\PY{n}{sin}\PY{p}{(}\PY{n}{sqrt}\PY{p}{(}\PY{l+m+mf}{2.0}\PY{p}{)}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{193}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
true
\end{Verbatim}
\end{tcolorbox}
        
    \hypertarget{methods}{%
\section{Methods}\label{methods}}

Earlier, we discussed structs, which look a lot like Python classes,
with instance variables and constructors, but they did not contain any
methods (just the inner constructors). In Julia, methods are defined
separately, like regular functions:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{194}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{struct} \PY{k+kt}{Person}
    \PY{n}{name}
    \PY{n}{age}
\PY{k}{end}

\PY{k}{function} \PY{n}{greetings}\PY{p}{(}\PY{n}{greeter}\PY{p}{)}
    \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Hi, my name is }\PY{l+s+si}{\PYZdl{}}\PY{p}{(}\PY{n}{greeter}\PY{o}{.}\PY{n}{name}\PY{p}{)}\PY{l+s}{, I am }\PY{l+s+si}{\PYZdl{}}\PY{p}{(}\PY{n}{greeter}\PY{o}{.}\PY{n}{age}\PY{p}{)}\PY{l+s}{ years old.}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{k}{end}

\PY{n}{p} \PY{o}{=} \PY{n}{Person}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Alice}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+m+mi}{70}\PY{p}{)}
\PY{n}{greetings}\PY{p}{(}\PY{n}{p}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Hi, my name is Alice, I am 70 years old.
    \end{Verbatim}

    Since the \texttt{greetings()} method in Julia is not bound to any
particular type, we can use it with any other type we want, as long as
that type has a \texttt{name} and an \texttt{age} (i.e., if it quacks
like a duck):

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{195}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{struct} \PY{k+kt}{City}
    \PY{n}{name}
    \PY{n}{country}
    \PY{n}{age}
\PY{k}{end}

\PY{k}{import} \PY{n}{Dates}
\PY{n}{c} \PY{o}{=} \PY{n}{City}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Auckland}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{New Zealand}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{n}{Dates}\PY{o}{.}\PY{n}{year}\PY{p}{(}\PY{n}{Dates}\PY{o}{.}\PY{n}{now}\PY{p}{(}\PY{p}{)}\PY{p}{)} \PY{o}{\PYZhy{}} \PY{l+m+mi}{1840}\PY{p}{)}

\PY{n}{greetings}\PY{p}{(}\PY{n}{c}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Hi, my name is Auckland, I am 181 years old.
    \end{Verbatim}

    You could code this the same way in Python if you wanted to:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# PYTHON}
\KeywordTok{class}\NormalTok{ Person:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, name, age):}
        \VariableTok{self}\NormalTok{.name }\OperatorTok{=}\NormalTok{ name}
        \VariableTok{self}\NormalTok{.age }\OperatorTok{=}\NormalTok{ age}

\KeywordTok{class}\NormalTok{ City:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, name, country, age):}
        \VariableTok{self}\NormalTok{.name }\OperatorTok{=}\NormalTok{ name}
        \VariableTok{self}\NormalTok{.country }\OperatorTok{=}\NormalTok{ country}
        \VariableTok{self}\NormalTok{.age }\OperatorTok{=}\NormalTok{ age}

\KeywordTok{def}\NormalTok{ greetings(greeter):}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Hi there, my name is }\SpecialCharTok{\{}\NormalTok{greeter}\SpecialCharTok{.}\NormalTok{name}\SpecialCharTok{\}}\SpecialStringTok{, I am }\SpecialCharTok{\{}\NormalTok{greeter}\SpecialCharTok{.}\NormalTok{age}\SpecialCharTok{\}}\SpecialStringTok{ years old."}\NormalTok{)}

\NormalTok{p }\OperatorTok{=}\NormalTok{ Person(}\StringTok{"Lucy"}\NormalTok{, }\DecValTok{70}\NormalTok{)}
\NormalTok{greetings(p)}
 
\ImportTok{from}\NormalTok{ datetime }\ImportTok{import}\NormalTok{ date}
\NormalTok{c }\OperatorTok{=}\NormalTok{ City(}\StringTok{"Auckland"}\NormalTok{, }\StringTok{"New Zealand"}\NormalTok{, date.today().year }\OperatorTok{{-}} \DecValTok{1840}\NormalTok{)}
\NormalTok{greetings(c)}
\end{Highlighting}
\end{Shaded}

    However, many Python programmers would use inheritance in this case:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Greeter:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, name, age):}
        \VariableTok{self}\NormalTok{.name }\OperatorTok{=}\NormalTok{ name}
        \VariableTok{self}\NormalTok{.age }\OperatorTok{=}\NormalTok{ age}
    \KeywordTok{def}\NormalTok{ greetings(}\VariableTok{self}\NormalTok{):}
        \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Hi there, my name is }\SpecialCharTok{\{}\VariableTok{self}\SpecialCharTok{.}\NormalTok{name}\SpecialCharTok{\}}\SpecialStringTok{, I am }\SpecialCharTok{\{}\VariableTok{self}\SpecialCharTok{.}\NormalTok{age}\SpecialCharTok{\}}\SpecialStringTok{ years old."}\NormalTok{)}

\KeywordTok{class}\NormalTok{ Person(Greeter):}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, name, age):}
        \BuiltInTok{super}\NormalTok{().}\FunctionTok{\_\_init\_\_}\NormalTok{(name, age)}

\KeywordTok{class}\NormalTok{ City(Greeter):}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, name, country, age):}
        \BuiltInTok{super}\NormalTok{().}\FunctionTok{\_\_init\_\_}\NormalTok{(name, age)}
        \VariableTok{self}\NormalTok{.country }\OperatorTok{=}\NormalTok{ country}

\NormalTok{p }\OperatorTok{=}\NormalTok{ Person(}\StringTok{"Lucy"}\NormalTok{, }\DecValTok{70}\NormalTok{)}
\NormalTok{p.greetings()}

\ImportTok{from}\NormalTok{ datetime }\ImportTok{import}\NormalTok{ date}
\NormalTok{c }\OperatorTok{=}\NormalTok{ City(}\StringTok{"Auckland"}\NormalTok{, }\StringTok{"New Zealand"}\NormalTok{, date.today().year }\OperatorTok{{-}} \DecValTok{1840}\NormalTok{)}
\NormalTok{c.greetings()}
\end{Highlighting}
\end{Shaded}

    \hypertarget{extending-a-function}{%
\subsection{Extending a Function}\label{extending-a-function}}

One nice thing about having a class hierarchy is that you can override
methods in subclasses to get specialized behavior for each class. For
example, in Python you could override the \texttt{greetings()} method
like this:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# PYTHON}
\KeywordTok{class}\NormalTok{ Developer(Person):}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, name, age, language):}
        \BuiltInTok{super}\NormalTok{().}\FunctionTok{\_\_init\_\_}\NormalTok{(name, age)}
        \VariableTok{self}\NormalTok{.language }\OperatorTok{=}\NormalTok{ language}
    \KeywordTok{def}\NormalTok{ greetings(}\VariableTok{self}\NormalTok{):}
        \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Hi there, my name is }\SpecialCharTok{\{}\VariableTok{self}\SpecialCharTok{.}\NormalTok{name}\SpecialCharTok{\}}\SpecialStringTok{, I am }\SpecialCharTok{\{}\VariableTok{self}\SpecialCharTok{.}\NormalTok{age}\SpecialCharTok{\}}\SpecialStringTok{ years old."}\NormalTok{)}
        \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"My favorite language is }\SpecialCharTok{\{}\VariableTok{self}\SpecialCharTok{.}\NormalTok{language}\SpecialCharTok{\}}\SpecialStringTok{."}\NormalTok{)}

\NormalTok{d }\OperatorTok{=}\NormalTok{ Developer(}\StringTok{"Amy"}\NormalTok{, }\DecValTok{40}\NormalTok{, }\StringTok{"Julia"}\NormalTok{)}
\NormalTok{d.greetings()}
\end{Highlighting}
\end{Shaded}

    Notice that the expression \texttt{d.greetings()} will call a different
method if \texttt{d} is a \texttt{Person} or a \texttt{Developer}. This
is called ``polymorphism'': the same method call behaves differently
depending on the type of the object. The language chooses which actual
method implementation to call, based on the type of \texttt{d}: this is
called method ``dispatch''. More specifically, since it only depends on
a single variable, it is called ``single dispatch''.

The good news is that Julia can do single dispatch as well:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{196}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{struct} \PY{k+kt}{Developer}
    \PY{n}{name}
    \PY{n}{age}
    \PY{n}{language}
\PY{k}{end}

\PY{k}{function} \PY{n}{greetings}\PY{p}{(}\PY{n}{dev}\PY{o}{::}\PY{k+kt}{Developer}\PY{p}{)}
    \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Hi, my name is }\PY{l+s+si}{\PYZdl{}}\PY{p}{(}\PY{n}{dev}\PY{o}{.}\PY{n}{name}\PY{p}{)}\PY{l+s}{, I am }\PY{l+s+si}{\PYZdl{}}\PY{p}{(}\PY{n}{dev}\PY{o}{.}\PY{n}{age}\PY{p}{)}\PY{l+s}{ years old.}\PY{l+s}{\PYZdq{}}\PY{p}{)}
    \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{My favorite language is }\PY{l+s+si}{\PYZdl{}}\PY{p}{(}\PY{n}{dev}\PY{o}{.}\PY{n}{language}\PY{p}{)}\PY{l+s}{.}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{k}{end}

\PY{n}{d} \PY{o}{=} \PY{n}{Developer}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Amy}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+m+mi}{40}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{Julia}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{n}{greetings}\PY{p}{(}\PY{n}{d}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Hi, my name is Amy, I am 40 years old.
My favorite language is Julia.
    \end{Verbatim}

    Notice that the \texttt{dev} argument is followed by
\texttt{::Developer}, which means that this method will only be called
if the argument has that type.

We have \textbf{extended} the \texttt{greetings} \textbf{function}, so
that it now has two different implementations, called \textbf{methods},
each for different argument types: namely,
\texttt{greetings(dev::Developer)} for arguments of type
\texttt{Developer}, and \texttt{greetings(greeter)} for values of any
other type.

You can easily get the list of all the methods of a given function:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{197}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{methods}\PY{p}{(}\PY{n}{greetings}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{197}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\# 2 methods for generic function "greetings":
[1] greetings(dev::Developer) in Main at In[259]:7
[2] greetings(greeter) in Main at In[255]:6
\end{Verbatim}
\end{tcolorbox}
        
    You can also get the list of all the methods which take a particular
type as argument:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{198}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{methodswith}\PY{p}{(}\PY{n}{Developer}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{198}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
[1] greetings(dev::Developer) in Main at In[259]:7
\end{Verbatim}
\end{tcolorbox}
        
    When you call the \texttt{greetings()} function, Julia automatically
dispatches the call to the appropriate method, depending on the type of
the argument. If Julia can determine at compile time what the type of
the argument will be, then it optimizes the compiled code so that
there's no choice to be made at runtime. This is called \textbf{static
dispatch}, and it can significantly speed up the program. If the
argument's type can't be determined at compile time, then Julia makes
the choice at runtime, just like in Python: this is called
\textbf{dynamic dispatch}.

    \hypertarget{multiple-dispatch}{%
\subsection{Multiple Dispatch}\label{multiple-dispatch}}

Julia actually looks at the types of \emph{all} the positional
arguments, not just the first one. This is called \textbf{multiple
dispatch}. For example:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{199}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{multdisp}\PY{p}{(}\PY{n}{a}\PY{o}{::}\PY{k+kt}{Int64}\PY{p}{,} \PY{n}{b}\PY{o}{::}\PY{k+kt}{Int64}\PY{p}{)} \PY{o}{=} \PY{l+m+mi}{1}
\PY{n}{multdisp}\PY{p}{(}\PY{n}{a}\PY{o}{::}\PY{k+kt}{Int64}\PY{p}{,} \PY{n}{b}\PY{o}{::}\PY{k+kt}{Float64}\PY{p}{)} \PY{o}{=} \PY{l+m+mi}{2}
\PY{n}{multdisp}\PY{p}{(}\PY{n}{a}\PY{o}{::}\PY{k+kt}{Float64}\PY{p}{,} \PY{n}{b}\PY{o}{::}\PY{k+kt}{Int64}\PY{p}{)} \PY{o}{=} \PY{l+m+mi}{3}
\PY{n}{multdisp}\PY{p}{(}\PY{n}{a}\PY{o}{::}\PY{k+kt}{Float64}\PY{p}{,} \PY{n}{b}\PY{o}{::}\PY{k+kt}{Float64}\PY{p}{)} \PY{o}{=} \PY{l+m+mi}{4}

\PY{n}{multdisp}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{20}\PY{p}{)} \PY{c}{\PYZsh{} try changing the arguments to get each possible output}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{199}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
1
\end{Verbatim}
\end{tcolorbox}
        
    Julia always chooses the most specific method it can, so the following
method will only be called if the first argument is neither an
\texttt{Int64} nor a \texttt{Float64}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{200}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{multdisp}\PY{p}{(}\PY{n}{a}\PY{o}{::}\PY{k+kt}{Any}\PY{p}{,} \PY{n}{b}\PY{o}{::}\PY{k+kt}{Int64}\PY{p}{)} \PY{o}{=} \PY{l+m+mi}{5}

\PY{n}{multdisp}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{20}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{200}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
1
\end{Verbatim}
\end{tcolorbox}
        
    Julia will raise an exception if there is some ambiguity as to which
method is the most specific:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{201}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{ambig}\PY{p}{(}\PY{n}{a}\PY{o}{::}\PY{k+kt}{Int64}\PY{p}{,} \PY{n}{b}\PY{p}{)} \PY{o}{=} \PY{l+m+mi}{1}
\PY{n}{ambig}\PY{p}{(}\PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{o}{::}\PY{k+kt}{Int64}\PY{p}{)} \PY{o}{=} \PY{l+m+mi}{2}

\PY{k}{try}
    \PY{n}{ambig}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{20}\PY{p}{)}
\PY{k}{catch} \PY{n}{ex}
    \PY{n}{ex}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{201}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
MethodError(ambig, (10, 20), 0x0000000000007534)
\end{Verbatim}
\end{tcolorbox}
        
    To solve this problem, you can explicitely define a method for the
ambiguous case:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{202}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{ambig}\PY{p}{(}\PY{n}{a}\PY{o}{::}\PY{k+kt}{Int64}\PY{p}{,} \PY{n}{b}\PY{o}{::}\PY{k+kt}{Int64}\PY{p}{)} \PY{o}{=} \PY{l+m+mi}{3}
\PY{n}{ambig}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{20}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{202}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
3
\end{Verbatim}
\end{tcolorbox}
        
    So you can have polymorphism in Julia, just like in Python. This means
that you can write your algorithms in a generic way, without having to
know the exact types of the values you are manipulating, and it will
work fine, as long as these types act in the general way you expect
(i.e., if they ``quack like ducks''). For example:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{203}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{function} \PY{n}{how\PYZus{}can\PYZus{}i\PYZus{}help}\PY{p}{(}\PY{n}{greeter}\PY{p}{)}
    \PY{n}{greetings}\PY{p}{(}\PY{n}{greeter}\PY{p}{)}
    \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{How can I help?}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{k}{end}

\PY{n}{how\PYZus{}can\PYZus{}i\PYZus{}help}\PY{p}{(}\PY{n}{p}\PY{p}{)} \PY{c}{\PYZsh{} called on a Person}
\PY{n}{how\PYZus{}can\PYZus{}i\PYZus{}help}\PY{p}{(}\PY{n}{d}\PY{p}{)} \PY{c}{\PYZsh{} called on a Developer}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Hi, my name is Alice, I am 70 years old.
How can I help?
Hi, my name is Amy, I am 40 years old.
My favorite language is Julia.
How can I help?
    \end{Verbatim}

    \hypertarget{calling-super}{%
\subsection{\texorpdfstring{Calling
\texttt{super()}?}{Calling super()?}}\label{calling-super}}

You may have noticed that the \texttt{greetings(dev::Developer)} method
could be improved, since it currently duplicates the implementation of
the base method \texttt{greetings(greeter)}. In Python, you would get
rid of this duplication by calling the base class's \texttt{greetings()}
method, using \texttt{super()}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# PYTHON}
\KeywordTok{class}\NormalTok{ Developer(Person):}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, name, age, language):}
        \BuiltInTok{super}\NormalTok{().}\FunctionTok{\_\_init\_\_}\NormalTok{(name, age)}
        \VariableTok{self}\NormalTok{.language }\OperatorTok{=}\NormalTok{ language}
    \KeywordTok{def}\NormalTok{ greetings(}\VariableTok{self}\NormalTok{):}
        \BuiltInTok{super}\NormalTok{().greetings() }\CommentTok{\# \textless{}== THIS!}
        \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"My favorite language is }\SpecialCharTok{\{}\VariableTok{self}\SpecialCharTok{.}\NormalTok{language}\SpecialCharTok{\}}\SpecialStringTok{."}\NormalTok{)}

\NormalTok{d }\OperatorTok{=}\NormalTok{ Developer(}\StringTok{"Amy"}\NormalTok{, }\DecValTok{40}\NormalTok{, }\StringTok{"Julia"}\NormalTok{)}
\NormalTok{d.greetings()}
\end{Highlighting}
\end{Shaded}

In Julia, you can do something pretty similar, although you have to
implement your own \texttt{super()} function, as it is not part of the
language:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{204}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{super}\PY{p}{(}\PY{n}{dev}\PY{o}{::}\PY{k+kt}{Developer}\PY{p}{)} \PY{o}{=} \PY{n}{Person}\PY{p}{(}\PY{n}{dev}\PY{o}{.}\PY{n}{name}\PY{p}{,} \PY{n}{dev}\PY{o}{.}\PY{n}{age}\PY{p}{)}

\PY{k}{function} \PY{n}{greetings}\PY{p}{(}\PY{n}{dev}\PY{o}{::}\PY{k+kt}{Developer}\PY{p}{)}
    \PY{n}{greetings}\PY{p}{(}\PY{n}{super}\PY{p}{(}\PY{n}{dev}\PY{p}{)}\PY{p}{)}
    \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{My favorite language is }\PY{l+s+si}{\PYZdl{}}\PY{p}{(}\PY{n}{dev}\PY{o}{.}\PY{n}{language}\PY{p}{)}\PY{l+s}{.}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{k}{end}

\PY{n}{greetings}\PY{p}{(}\PY{n}{d}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Hi, my name is Amy, I am 40 years old.
My favorite language is Julia.
    \end{Verbatim}

    However, this implementation creates a new \texttt{Person} instance when
calling \texttt{super(dev)}, copying the \texttt{name} and \texttt{age}
fields. That's okay for small objects, but it's not ideal for larger
ones. Instead, you can explicitely call the specific method you want by
using the \texttt{invoke()} function:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{205}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{function} \PY{n}{greetings}\PY{p}{(}\PY{n}{dev}\PY{o}{::}\PY{k+kt}{Developer}\PY{p}{)}
    \PY{n}{invoke}\PY{p}{(}\PY{n}{greetings}\PY{p}{,} \PY{k+kt}{Tuple}\PY{p}{\PYZob{}}\PY{k+kt}{Any}\PY{p}{\PYZcb{}}\PY{p}{,} \PY{n}{dev}\PY{p}{)}
    \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{My favorite language is }\PY{l+s+si}{\PYZdl{}}\PY{p}{(}\PY{n}{dev}\PY{o}{.}\PY{n}{language}\PY{p}{)}\PY{l+s}{.}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{k}{end}

\PY{n}{greetings}\PY{p}{(}\PY{n}{d}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Hi, my name is Amy, I am 40 years old.
My favorite language is Julia.
    \end{Verbatim}

    The \texttt{invoke()} function expects the following arguments: * The
first argument is the function to call. * The second argument is the
type of the desired method's arguments tuple:
\texttt{Tuple\{TypeArg1,\ TypeArg2,\ etc.\}}. In this case we want to
call the base function, which takes a single \texttt{Any} argument (the
\texttt{Any} type is implicit when no type is specified). * Lastly, it
takes all the arguments to be passed to the method. In this case,
there's just one: \texttt{dev}.

    As you can see, we managed to get the same advantages Object-Oriented
programming offers, without defining classes or using inheritance. This
takes a bit of getting used to, but you might come to prefer this style
of generic programming. Indeed, OO programming encourage you to bundle
data and behavior together, but this is not always a good idea. Let's
look at one example:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# PYTHON}
\KeywordTok{class}\NormalTok{ Rectangle:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, height, width):}
        \VariableTok{self}\NormalTok{.height }\OperatorTok{=}\NormalTok{ height}
        \VariableTok{self}\NormalTok{.width }\OperatorTok{=}\NormalTok{ width}
    \KeywordTok{def}\NormalTok{ area(}\VariableTok{self}\NormalTok{):}
        \ControlFlowTok{return} \VariableTok{self}\NormalTok{.height }\OperatorTok{*} \VariableTok{self}\NormalTok{.width}

\KeywordTok{class}\NormalTok{ Square(Rectangle):}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, length):}
        \BuiltInTok{super}\NormalTok{().}\FunctionTok{\_\_init\_\_}\NormalTok{(length, length)}
\end{Highlighting}
\end{Shaded}

It makes sense for the \texttt{Square} class to be a subclass of the
\texttt{Rectangle} class, since a square \textbf{is a} special type of
rectangle. It also makes sense for the \texttt{Square} class to inherit
from all of the \texttt{Rectangle} class's behavior, such as the
\texttt{area()} method. However, it does not really make sense for
rectangles and squares to have the same memory representation: a
\texttt{Rectangle} needs two numbers (\texttt{height} and
\texttt{width}), while a \texttt{Square} only needs one
(\texttt{length}).

It's possible to work around this issue like this:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# PYTHON}
\KeywordTok{class}\NormalTok{ Rectangle:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, height, width):}
        \VariableTok{self}\NormalTok{.height }\OperatorTok{=}\NormalTok{ height}
        \VariableTok{self}\NormalTok{.width }\OperatorTok{=}\NormalTok{ width}
    \KeywordTok{def}\NormalTok{ area(}\VariableTok{self}\NormalTok{):}
        \ControlFlowTok{return} \VariableTok{self}\NormalTok{.height }\OperatorTok{*} \VariableTok{self}\NormalTok{.width}

\KeywordTok{class}\NormalTok{ Square(Rectangle):}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, length):}
        \VariableTok{self}\NormalTok{.length }\OperatorTok{=}\NormalTok{ length}
    \AttributeTok{@property}
    \KeywordTok{def}\NormalTok{ width(}\VariableTok{self}\NormalTok{):}
        \ControlFlowTok{return} \VariableTok{self}\NormalTok{.length}
    \AttributeTok{@property}
    \KeywordTok{def}\NormalTok{ height(}\VariableTok{self}\NormalTok{):}
        \ControlFlowTok{return} \VariableTok{self}\NormalTok{.length}
\end{Highlighting}
\end{Shaded}

That's better: now, each square is only represented using a single
number. We've inherited the behavior, but not the data.

In Julia, you could code this like so:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{206}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{struct} \PY{k+kt}{Rectangle}
    \PY{n}{width}
    \PY{n}{height}
\PY{k}{end}

\PY{n}{width}\PY{p}{(}\PY{n}{rect}\PY{o}{::}\PY{k+kt}{Rectangle}\PY{p}{)} \PY{o}{=} \PY{n}{rect}\PY{o}{.}\PY{n}{width}
\PY{n}{height}\PY{p}{(}\PY{n}{rect}\PY{o}{::}\PY{k+kt}{Rectangle}\PY{p}{)} \PY{o}{=} \PY{n}{rect}\PY{o}{.}\PY{n}{height}

\PY{n}{area}\PY{p}{(}\PY{n}{rect}\PY{p}{)} \PY{o}{=} \PY{n}{width}\PY{p}{(}\PY{n}{rect}\PY{p}{)} \PY{o}{*} \PY{n}{height}\PY{p}{(}\PY{n}{rect}\PY{p}{)}

\PY{k}{struct} \PY{k+kt}{Square}
    \PY{n}{length}
\PY{k}{end}

\PY{n}{width}\PY{p}{(}\PY{n}{sq}\PY{o}{::}\PY{k+kt}{Square}\PY{p}{)} \PY{o}{=} \PY{n}{sq}\PY{o}{.}\PY{n}{length}
\PY{n}{height}\PY{p}{(}\PY{n}{sq}\PY{o}{::}\PY{k+kt}{Square}\PY{p}{)} \PY{o}{=} \PY{n}{sq}\PY{o}{.}\PY{n}{length}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{206}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
height (generic function with 2 methods)
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{207}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{area}\PY{p}{(}\PY{n}{Square}\PY{p}{(}\PY{l+m+mi}{5}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{207}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
25
\end{Verbatim}
\end{tcolorbox}
        
    Notice that the \texttt{area()} function relies on the getters
\texttt{width()} and \texttt{height()}, rather than directly on the
fields \texttt{width} and \texttt{height}. This way, the argument can be
of any type at all, as long as it has these getters.

    \hypertarget{abstract-types}{%
\subsection{Abstract Types}\label{abstract-types}}

One nice thing about the class hierarchy we defined in Python is that it
makes it clear that a square \textbf{is a} kind of rectangle. Any new
function you define that takes a \texttt{Rectangle} as an argument will
automatically accept a \texttt{Square} as well, but no other
non-rectangle type. In contrast, our \texttt{area()} function currently
accepts anything at all.

In Julia, a concrete type like \texttt{Square} cannot extend another
concrete type like \texttt{Rectangle}. However, any type can extend from
an abstract type. Let's define some abstract types to create a type
hierarchy for our \texttt{Square} and \texttt{Rectangle} types.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{208}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{abstract type} \PY{k+kt}{AbstractShape} \PY{k}{end}
\PY{k}{abstract type} \PY{k+kt}{AbstractRectangle} \PY{o}{\PYZlt{}:} \PY{k+kt}{AbstractShape} \PY{k}{end}  \PY{c}{\PYZsh{} \PYZlt{}: means \PYZdq{}subtype of\PYZdq{}}
\PY{k}{abstract type} \PY{k+kt}{AbstractSquare} \PY{o}{\PYZlt{}:} \PY{k+kt}{AbstractRectangle} \PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    The \texttt{\textless{}:} operator means ``subtype of''.

    Now we can attach the \texttt{area()} function to the
\texttt{AbstractRectangle} type, instead of any type at all:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{209}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{area}\PY{p}{(}\PY{n}{rect}\PY{o}{::}\PY{k+kt}{AbstractRectangle}\PY{p}{)} \PY{o}{=} \PY{n}{width}\PY{p}{(}\PY{n}{rect}\PY{p}{)} \PY{o}{*} \PY{n}{height}\PY{p}{(}\PY{n}{rect}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{209}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
area (generic function with 2 methods)
\end{Verbatim}
\end{tcolorbox}
        
    Now we can define the concrete types, as subtypes of
\texttt{AbstractRectangle} and \texttt{AbstractSquare}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{210}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{struct} \PY{k+kt}{Rectangle\PYZus{}v2} \PY{o}{\PYZlt{}:} \PY{k+kt}{AbstractRectangle}
  \PY{n}{width}
  \PY{n}{height}
\PY{k}{end}

\PY{n}{width}\PY{p}{(}\PY{n}{rect}\PY{o}{::}\PY{k+kt}{Rectangle\PYZus{}v2}\PY{p}{)} \PY{o}{=} \PY{n}{rect}\PY{o}{.}\PY{n}{width}
\PY{n}{height}\PY{p}{(}\PY{n}{rect}\PY{o}{::}\PY{k+kt}{Rectangle\PYZus{}v2}\PY{p}{)} \PY{o}{=} \PY{n}{rect}\PY{o}{.}\PY{n}{height}

\PY{k}{struct} \PY{k+kt}{Square\PYZus{}v2} \PY{o}{\PYZlt{}:} \PY{k+kt}{AbstractSquare}
  \PY{n}{length}
\PY{k}{end}

\PY{n}{width}\PY{p}{(}\PY{n}{sq}\PY{o}{::}\PY{k+kt}{Square\PYZus{}v2}\PY{p}{)} \PY{o}{=} \PY{n}{sq}\PY{o}{.}\PY{n}{length}
\PY{n}{height}\PY{p}{(}\PY{n}{sq}\PY{o}{::}\PY{k+kt}{Square\PYZus{}v2}\PY{p}{)} \PY{o}{=} \PY{n}{sq}\PY{o}{.}\PY{n}{length}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{210}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
height (generic function with 4 methods)
\end{Verbatim}
\end{tcolorbox}
        
    In short, the Julian approach to type hierarchies looks like this:

\begin{itemize}
\tightlist
\item
  Create a hierarchy of abstract types to represent the concepts you
  want to implement.
\item
  Write functions for these abstract types. Much of your implementation
  can be coded at that level, manipulating abstract concepts.
\item
  Lastly, create concrete types, and write the methods needed to give
  them the behavior that is expected by the generic algorithms you
  wrote.
\end{itemize}

    This pattern is used everywhere in Julia's standard libraries. For
example, here are the supertypes of \texttt{Float64} and \texttt{Int64}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{211}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{Base}\PY{o}{.}\PY{n}{show\PYZus{}supertypes}\PY{p}{(}\PY{k+kt}{Float64}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Float64 <: AbstractFloat <: Real <: Number <: Any
    \end{Verbatim}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{212}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{Base}\PY{o}{.}\PY{n}{show\PYZus{}supertypes}\PY{p}{(}\PY{k+kt}{Int64}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Int64 <: Signed <: Integer <: Real <: Number <: Any
    \end{Verbatim}

    Note: Julia implicitly runs \texttt{using\ Core} and
\texttt{using\ Base} when starting the REPL. However, the
\texttt{show\_supertypes()} function is not exported by the
\texttt{Base} module, thus you cannot access it by just typing
\texttt{show\_supertypes(Float64)}. Instead, you have to specify the
module name: \texttt{Base.show\_supertypes(Float64)}.

    And here is the whole hierarchy of \texttt{Number} types:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{213}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{function} \PY{n}{show\PYZus{}hierarchy}\PY{p}{(}\PY{n}{root}\PY{p}{,} \PY{n}{indent}\PY{o}{=}\PY{l+m+mi}{0}\PY{p}{)}
    \PY{n}{println}\PY{p}{(}\PY{n}{repeat}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{ }\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{n}{indent} \PY{o}{*} \PY{l+m+mi}{4}\PY{p}{)}\PY{p}{,} \PY{n}{root}\PY{p}{)}
    \PY{k}{for} \PY{n}{subtype} \PY{k}{in} \PY{n}{subtypes}\PY{p}{(}\PY{n}{root}\PY{p}{)}
        \PY{n}{show\PYZus{}hierarchy}\PY{p}{(}\PY{n}{subtype}\PY{p}{,} \PY{n}{indent} \PY{o}{+} \PY{l+m+mi}{1}\PY{p}{)}
    \PY{k}{end}
\PY{k}{end}

\PY{n}{show\PYZus{}hierarchy}\PY{p}{(}\PY{k+kt}{Number}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Number
    Complex
    Real
        AbstractFloat
            BigFloat
            Float16
            Float32
            Float64
        AbstractIrrational
            Irrational
        FixedPointNumbers.FixedPoint
            FixedPointNumbers.Fixed
            FixedPointNumbers.Normed
        Integer
            Bool
            Signed
                BigInt
                Int128
                Int16
                Int32
                Int64
                Int8
            Unsigned
                UInt128
                UInt16
                UInt32
                UInt64
                UInt8
        Rational
        Ratios.SimpleRatio
        StatsBase.PValue
        StatsBase.TestStat
    \end{Verbatim}

    \hypertarget{iterator-interface}{%
\subsection{Iterator Interface}\label{iterator-interface}}

You will sometimes want to provide a way to iterate over your custom
types. In Python, this requires defining the \texttt{\_\_iter\_\_()}
method which should return an object which implements the
\texttt{\_\_next\_\_()} method. In Julia, you must define at least two
functions: * \texttt{iterate(::YourIteratorType)}, which must return
either \texttt{nothing} if there are no values in the sequence, or
\texttt{(first\_value,\ iterator\_state)}. *
\texttt{iterate(::YourIteratorType,\ state)}, which must return either
\texttt{nothing} if there are no more values, or
\texttt{(next\_value,\ new\_iterator\_state)}.

For example, let's create a simple iterator for the Fibonacci sequence:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{214}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{struct} \PY{k+kt}{FibonacciIterator} \PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{215}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{import} \PY{n}{Base}\PY{o}{.}\PY{n}{iterate}

\PY{n}{iterate}\PY{p}{(}\PY{n}{f}\PY{o}{::}\PY{k+kt}{FibonacciIterator}\PY{p}{)} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{)}

\PY{k}{function} \PY{n}{iterate}\PY{p}{(}\PY{n}{f}\PY{o}{::}\PY{k+kt}{FibonacciIterator}\PY{p}{,} \PY{n}{state}\PY{p}{)}
    \PY{n}{new\PYZus{}state} \PY{o}{=} \PY{p}{(}\PY{n}{state}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,} \PY{n}{state}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]} \PY{o}{+} \PY{n}{state}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{)}
    \PY{p}{(}\PY{n}{new\PYZus{}state}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{new\PYZus{}state}\PY{p}{)}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{215}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
iterate (generic function with 387 methods)
\end{Verbatim}
\end{tcolorbox}
        
    Now we can iterate over a \texttt{FibonacciIterator} instance:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{216}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{for} \PY{n}{f} \PY{k}{in} \PY{n}{FibonacciIterator}\PY{p}{(}\PY{p}{)}
    \PY{n}{println}\PY{p}{(}\PY{n}{f}\PY{p}{)}
    \PY{n}{f} \PY{o}{\PYZgt{}} \PY{l+m+mi}{10} \PY{o}{\PYZam{}\PYZam{}} \PY{k}{break}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
1
1
2
3
5
8
13
    \end{Verbatim}

    \hypertarget{indexing-interface}{%
\subsection{Indexing Interface}\label{indexing-interface}}

You can also create a type that will be indexable like an array
(allowing syntax like \texttt{a{[}5{]}\ =\ 3}). In Python, this requires
implementing the \texttt{\_\_getitem\_\_()} and
\texttt{\_\_setitem\_\_()} methods. In Julia, you must implement the
\texttt{getindex(A::YourType,\ i)},
\texttt{setindex!(A::YourType,\ v,\ i)},
\texttt{firstindex(A::YourType)} and \texttt{lastindex(A::YourType)}
methods.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{217}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{struct} \PY{k+kt}{MySquares} \PY{k}{end}

\PY{k}{import} \PY{n}{Base}\PY{o}{.}\PY{n}{getindex}\PY{p}{,} \PY{n}{Base}\PY{o}{.}\PY{n}{firstindex}

\PY{n}{getindex}\PY{p}{(}\PY{o}{::}\PY{k+kt}{MySquares}\PY{p}{,} \PY{n}{i}\PY{p}{)} \PY{o}{=} \PY{n}{i}\PY{o}{\PYZca{}}\PY{l+m+mi}{2}
\PY{n}{firstindex}\PY{p}{(}\PY{o}{::}\PY{k+kt}{MySquares}\PY{p}{)} \PY{o}{=} \PY{l+m+mi}{0}

\PY{n}{S} \PY{o}{=} \PY{n}{MySquares}\PY{p}{(}\PY{p}{)}
\PY{n}{S}\PY{p}{[}\PY{l+m+mi}{10}\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{217}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
100
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{218}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{S}\PY{p}{[}\PY{k}{begin}\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{218}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
0
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{219}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{getindex}\PY{p}{(}\PY{n}{S}\PY{o}{::}\PY{k+kt}{MySquares}\PY{p}{,} \PY{n}{r}\PY{o}{::}\PY{k+kt}{UnitRange}\PY{p}{)} \PY{o}{=} \PY{p}{[}\PY{n}{S}\PY{p}{[}\PY{n}{i}\PY{p}{]} \PY{k}{for} \PY{n}{i} \PY{k}{in} \PY{n}{r}\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{219}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
getindex (generic function with 367 methods)
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{220}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{S}\PY{p}{[}\PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{4}\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{220}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
4-element Vector\{Int64\}:
  1
  4
  9
 16
\end{Verbatim}
\end{tcolorbox}
        
    For more details on these interfaces, and to learn how to build
full-blown array types with broadcasting and more, check out
\href{https://docs.julialang.org/en/v1/manual/interfaces/}{this page}.

    \hypertarget{creating-a-number-type}{%
\subsection{Creating a Number Type}\label{creating-a-number-type}}

Let's create a \texttt{MyRational} struct and try to make it mimic the
built-in \texttt{Rational} type:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{221}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{struct} \PY{k+kt}{MyRational} \PY{o}{\PYZlt{}:} \PY{k+kt}{Real}
    \PY{n}{num} \PY{c}{\PYZsh{} numerator}
    \PY{n}{den} \PY{c}{\PYZsh{} denominator}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{222}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{MyRational}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{222}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
MyRational(2, 3)
\end{Verbatim}
\end{tcolorbox}
        
    It would be more convenient and readable if we could type
\texttt{2\ ⨸\ 3} to create a \texttt{MyRational}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{223}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{function} \PY{o}{⨸}\PY{p}{(}\PY{n}{num}\PY{p}{,} \PY{n}{den}\PY{p}{)}
    \PY{n}{MyRational}\PY{p}{(}\PY{n}{num}\PY{p}{,} \PY{n}{den}\PY{p}{)}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{223}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
⨸ (generic function with 1 method)
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{224}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{l+m+mi}{2} \PY{o}{⨸} \PY{l+m+mi}{3}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{224}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
MyRational(2, 3)
\end{Verbatim}
\end{tcolorbox}
        
    I chose \texttt{⨸} because it's a symbol that Julia's parser treats as a
binary operator, but which is otherwise not used by Julia (see the full
\href{https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm}{list
of parsed symbols} and their priorities). This particular symbol will
have the same priority as multiplication and division.

    If you want to know how to type it and check that it is unused, type
\texttt{?⨸} (copy/paste the symbol):

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{225}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{o}{?}\PY{o}{⨸}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
"\textcolor{ansi-cyan}{⨸}" can be typed by \textcolor{ansi-cyan}{\textbackslash{}odiv<tab>}

search: \textbf{⨸}

    \end{Verbatim}
 
            
\prompt{Out}{outcolor}{225}{}
    
    No documentation found.

\texttt{⨸} is a \texttt{Function}.

\begin{verbatim}
# 1 method for generic function "⨸":
[1] ⨸(num, den) in Main at In[286]:1
\end{verbatim}


    

    Now let's make it possible to add two \texttt{MyRational} values. We
want it to be possible for our \texttt{MyRational} type to be used in
existing algorithms which rely on \texttt{+}, so we must create a new
method for the \texttt{Base.+} function:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{226}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{import} \PY{n}{Base}\PY{o}{.+}

\PY{k}{function} \PY{o}{+}\PY{p}{(}\PY{n}{r1}\PY{o}{::}\PY{k+kt}{MyRational}\PY{p}{,} \PY{n}{r2}\PY{o}{::}\PY{k+kt}{MyRational}\PY{p}{)}
    \PY{p}{(}\PY{n}{r1}\PY{o}{.}\PY{n}{num} \PY{o}{*} \PY{n}{r2}\PY{o}{.}\PY{n}{den} \PY{o}{+} \PY{n}{r1}\PY{o}{.}\PY{n}{den} \PY{o}{*} \PY{n}{r2}\PY{o}{.}\PY{n}{num}\PY{p}{)} \PY{o}{⨸} \PY{p}{(}\PY{n}{r1}\PY{o}{.}\PY{n}{den} \PY{o}{*} \PY{n}{r2}\PY{o}{.}\PY{n}{den}\PY{p}{)}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{226}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
+ (generic function with 299 methods)
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{227}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{l+m+mi}{2} \PY{o}{⨸} \PY{l+m+mi}{3} \PY{o}{+} \PY{l+m+mi}{3} \PY{o}{⨸} \PY{l+m+mi}{5}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{227}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
MyRational(19, 15)
\end{Verbatim}
\end{tcolorbox}
        
    It's important to import \texttt{Base.+} first, or else you would just
be defining a new \texttt{+} function in the current module
(\texttt{Main}), which would not be called by existing algorithms.

    You can easily implement \texttt{*}, \texttt{\^{}} and so on, in much
the same way.

    Let's change the way \texttt{MyRational} values are printed, to make
them look a bit nicer. For this, we must create a new method for the
\texttt{Base.show(io::IO,\ x)} function:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{228}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{import} \PY{n}{Base}\PY{o}{.}\PY{n}{show}

\PY{k}{function} \PY{n}{show}\PY{p}{(}\PY{n}{io}\PY{o}{::}\PY{k+kt}{IO}\PY{p}{,} \PY{n}{r}\PY{o}{::}\PY{k+kt}{MyRational}\PY{p}{)}
    \PY{n}{print}\PY{p}{(}\PY{n}{io}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s+si}{\PYZdl{}}\PY{p}{(}\PY{n}{r}\PY{o}{.}\PY{n}{num}\PY{p}{)}\PY{l+s}{ ⨸ }\PY{l+s+si}{\PYZdl{}}\PY{p}{(}\PY{n}{r}\PY{o}{.}\PY{n}{den}\PY{p}{)}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{k}{end}

\PY{l+m+mi}{2} \PY{o}{⨸} \PY{l+m+mi}{3} \PY{o}{+} \PY{l+m+mi}{3} \PY{o}{⨸} \PY{l+m+mi}{5}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{228}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
19 ⨸ 15
\end{Verbatim}
\end{tcolorbox}
        
    We can expand the \texttt{show()} function so it can provide an HTML
representation for \texttt{MyRational} values. This will be called by
the \texttt{display()} function in Jupyter:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{229}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{function} \PY{n}{show}\PY{p}{(}\PY{n}{io}\PY{o}{::}\PY{k+kt}{IO}\PY{p}{,} \PY{o}{::}\PY{k+kt}{MIME}\PY{l+s}{\PYZdq{}}\PY{l+s}{text/html}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{n}{r}\PY{o}{::}\PY{k+kt}{MyRational}\PY{p}{)}
    \PY{n}{print}\PY{p}{(}\PY{n}{io}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{\PYZlt{}sup\PYZgt{}\PYZlt{}b\PYZgt{}}\PY{l+s+si}{\PYZdl{}}\PY{p}{(}\PY{n}{r}\PY{o}{.}\PY{n}{num}\PY{p}{)}\PY{l+s}{\PYZlt{}/b\PYZgt{}\PYZlt{}/sup\PYZgt{}\PYZam{}frasl;\PYZlt{}sub\PYZgt{}\PYZlt{}b\PYZgt{}}\PY{l+s+si}{\PYZdl{}}\PY{p}{(}\PY{n}{r}\PY{o}{.}\PY{n}{den}\PY{p}{)}\PY{l+s}{\PYZlt{}/b\PYZgt{}\PYZlt{}/sub\PYZgt{}}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{k}{end}

\PY{l+m+mi}{2} \PY{o}{⨸} \PY{l+m+mi}{3} \PY{o}{+} \PY{l+m+mi}{3} \PY{o}{⨸} \PY{l+m+mi}{5}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{229}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
19 ⨸ 15
\end{Verbatim}
\end{tcolorbox}
        
    Next, we want to be able to perform any operation involving
\texttt{MyRational} values and values of other \texttt{Number} types.
For example, we may want to multiply integers and \texttt{MyRational}
values. One option is to define a new method like this:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{230}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{import} \PY{n}{Base}\PY{o}{.*}

\PY{k}{function} \PY{o}{*}\PY{p}{(}\PY{n}{r}\PY{o}{::}\PY{k+kt}{MyRational}\PY{p}{,} \PY{n}{i}\PY{o}{::}\PY{k+kt}{Integer}\PY{p}{)}
    \PY{p}{(}\PY{n}{r}\PY{o}{.}\PY{n}{num} \PY{o}{*} \PY{n}{i}\PY{p}{)} \PY{o}{⨸} \PY{n}{r}\PY{o}{.}\PY{n}{den}
\PY{k}{end}

\PY{l+m+mi}{2} \PY{o}{⨸} \PY{l+m+mi}{3} \PY{o}{*} \PY{l+m+mi}{5}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{230}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
10 ⨸ 3
\end{Verbatim}
\end{tcolorbox}
        
    Since multiplication is commutative, we need the reverse method as well:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{231}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{function} \PY{o}{*}\PY{p}{(}\PY{n}{i}\PY{o}{::}\PY{k+kt}{Integer}\PY{p}{,} \PY{n}{r}\PY{o}{::}\PY{k+kt}{MyRational}\PY{p}{)}
    \PY{n}{r} \PY{o}{*} \PY{n}{i} \PY{c}{\PYZsh{} this will call the previous method}
\PY{k}{end}

\PY{l+m+mi}{5} \PY{o}{*} \PY{p}{(}\PY{l+m+mi}{2} \PY{o}{⨸} \PY{l+m+mi}{3}\PY{p}{)} \PY{c}{\PYZsh{} we need the parentheses since * and ⨸ have the same priority}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{231}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
10 ⨸ 3
\end{Verbatim}
\end{tcolorbox}
        
    It's cumbersome to have to define these methods for every operation.
There's a better way, which we will explore in the next two sections.

    \hypertarget{conversion}{%
\subsection{Conversion}\label{conversion}}

It is possible to provide a way for integers to be automatically
converted to \texttt{MyRational} values:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{232}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{import} \PY{n}{Base}\PY{o}{.}\PY{n}{convert}

\PY{n}{MyRational}\PY{p}{(}\PY{n}{x}\PY{o}{::}\PY{k+kt}{Integer}\PY{p}{)} \PY{o}{=} \PY{n}{MyRational}\PY{p}{(}\PY{n}{x}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)}

\PY{n}{convert}\PY{p}{(}\PY{o}{::}\PY{k+kt}{Type}\PY{p}{\PYZob{}}\PY{k+kt}{MyRational}\PY{p}{\PYZcb{}}\PY{p}{,} \PY{n}{x}\PY{o}{::}\PY{k+kt}{Integer}\PY{p}{)} \PY{o}{=} \PY{n}{MyRational}\PY{p}{(}\PY{n}{x}\PY{p}{)}

\PY{n}{convert}\PY{p}{(}\PY{n}{MyRational}\PY{p}{,} \PY{l+m+mi}{42}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{232}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
42 ⨸ 1
\end{Verbatim}
\end{tcolorbox}
        
    The \texttt{Type\{MyRational\}} type is a special type which has a
single instance: the \texttt{MyRational} type itself. So this
\texttt{convert()} method only accepts \texttt{MyRational} itself as its
first argument (and we don't actually use the first argument, so we
don't even need to give it a name in the function declaration).

    Now integers will be automatically converted to \texttt{MyRational}
values when you assign them to an array whose element type if
\texttt{MyRational}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{233}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{a} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{2} \PY{o}{⨸} \PY{l+m+mi}{3}\PY{p}{]} \PY{c}{\PYZsh{} the element type is MyRational}
\PY{n}{a}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]} \PY{o}{=} \PY{l+m+mi}{5}    \PY{c}{\PYZsh{} convert(MyRational, 5) is called automatically}
\PY{n}{push!}\PY{p}{(}\PY{n}{a}\PY{p}{,} \PY{l+m+mi}{6}\PY{p}{)} \PY{c}{\PYZsh{} convert(MyRational, 6) is called automatically}
\PY{n}{println}\PY{p}{(}\PY{n}{a}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
MyRational[5 ⨸ 1, 6 ⨸ 1]
    \end{Verbatim}

    Conversion will also occur automatically in these cases: *
\texttt{r::MyRational\ =\ 42}: assigning an integer to \texttt{r} where
\texttt{r} is a local variable with a declared type of
\texttt{MyRational}. * \texttt{s.b\ =\ 42} if \texttt{s} is a struct and
\texttt{b} is a field of type \texttt{MyRational} (also when calling
\texttt{new(42)} on that struct, assuming \texttt{b} is the first
field). * \texttt{return\ 42} if the return type is declared as
\texttt{MyRational} (e.g.,
\texttt{function\ f(x)::MyRational\ ...\ end}).

    However, there is no automatic conversion when calling functions:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{234}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{function} \PY{n}{for\PYZus{}my\PYZus{}rationals\PYZus{}only}\PY{p}{(}\PY{n}{x}\PY{o}{::}\PY{k+kt}{MyRational}\PY{p}{)}
    \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{It works:}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{n}{x}\PY{p}{)}
\PY{k}{end}

\PY{k}{try}
    \PY{n}{for\PYZus{}my\PYZus{}rationals\PYZus{}only}\PY{p}{(}\PY{l+m+mi}{42}\PY{p}{)}
\PY{k}{catch} \PY{n}{ex}
    \PY{n}{ex}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{234}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
MethodError(for\_my\_rationals\_only, (42,), 0x000000000000755b)
\end{Verbatim}
\end{tcolorbox}
        
    \hypertarget{promotion}{%
\subsection{Promotion}\label{promotion}}

The \texttt{Base} functions \texttt{+}, \texttt{-}, \texttt{*},
\texttt{/}, \texttt{\^{}}, etc. all use a ``promotion'' algorithm to
convert the arguments to the appropriate type. For example, adding an
integer and a float promotes the integer to a float before the addition
takes place. These functions use the \texttt{promote()} function for
this. For example, given several integers and a float, all integers get
promoted to floats:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{235}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{promote}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mf}{4.0}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{235}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
(1.0, 2.0, 3.0, 4.0)
\end{Verbatim}
\end{tcolorbox}
        
    This is why a sum of integers and floats results in a float:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{236}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{l+m+mi}{1} \PY{o}{+} \PY{l+m+mi}{2} \PY{o}{+} \PY{l+m+mi}{3} \PY{o}{+} \PY{l+m+mf}{4.0}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{236}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
10.0
\end{Verbatim}
\end{tcolorbox}
        
    The \texttt{promote()} function is also called when creating an array.
For example, the following array is a \texttt{Float64} array:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{237}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{a} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mf}{4.0}\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{237}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
4-element Vector\{Float64\}:
 1.0
 2.0
 3.0
 4.0
\end{Verbatim}
\end{tcolorbox}
        
    What about the \texttt{MyRational} type? Rather than create new methods
for the \texttt{promote()} function, the recommended approach is to
create a new method for the \texttt{promote\_rule()} function. It takes
two types and returns the type to convert to:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{238}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{promote\PYZus{}rule}\PY{p}{(}\PY{k+kt}{Float64}\PY{p}{,} \PY{k+kt}{Int64}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{238}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
Float64
\end{Verbatim}
\end{tcolorbox}
        
    Let's implement a new method for this function, to make sure that any
subtype of the \texttt{Integer} type will be promoted to
\texttt{MyRational}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{239}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{import} \PY{n}{Base}\PY{o}{.}\PY{n}{promote\PYZus{}rule}

\PY{n}{promote\PYZus{}rule}\PY{p}{(}\PY{o}{::}\PY{k+kt}{Type}\PY{p}{\PYZob{}}\PY{k+kt}{MyRational}\PY{p}{\PYZcb{}}\PY{p}{,} \PY{o}{::}\PY{k+kt}{Type}\PY{p}{\PYZob{}}\PY{k+kt}{T}\PY{p}{\PYZcb{}}\PY{p}{)} \PY{k}{where} \PY{p}{\PYZob{}}\PY{k+kt}{T} \PY{o}{\PYZlt{}:} \PY{k+kt}{Integer}\PY{p}{\PYZcb{}} \PY{o}{=} \PY{n}{MyRational}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{239}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
promote\_rule (generic function with 162 methods)
\end{Verbatim}
\end{tcolorbox}
        
    This method definition uses \textbf{parametric types}: the type
\texttt{T} can be any type at all, as long as it is a subtype of the
\texttt{Integer} abstract type. If you tried to define the method
\texttt{promote\_rule(::Type\{MyRational\},\ ::Type\{Integer\})}, it
would expect the type \texttt{Integer} itself as the second argument,
which would not work, since the \texttt{promote\_rule()} function will
usually be called with concrete types like \texttt{Int64} as its
arguments.

    Let's check that it works:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{240}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{promote}\PY{p}{(}\PY{l+m+mi}{5}\PY{p}{,} \PY{l+m+mi}{2} \PY{o}{⨸} \PY{l+m+mi}{3}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{240}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
(5 ⨸ 1, 2 ⨸ 3)
\end{Verbatim}
\end{tcolorbox}
        
    Yep! Now whenever we call \texttt{+}, \texttt{-}, etc., with an integer
and a \texttt{MyRational} value, the integer will get automatically
promoted to a \texttt{MyRational} value:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{241}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{l+m+mi}{5} \PY{o}{+} \PY{l+m+mi}{2} \PY{o}{⨸} \PY{l+m+mi}{3}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{241}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
17 ⨸ 3
\end{Verbatim}
\end{tcolorbox}
        
    Under the hood: * this called \texttt{+(5,\ 2\ ⨸\ 3)}, * which called
the \texttt{+(::Number,\ ::Number)} method (thanks to multiple
dispatch), * which called \texttt{promote(5,\ 2\ ⨸\ 3)}, * which called
\texttt{promote\_rule(Int64,\ MyRational)}, * which called
\texttt{promote\_rule(::MyRational,\ ::T)\ where\ \{T\ \textless{}:\ Integer\}},
* which returned \texttt{MyRational}, * then the
\texttt{+(::Number,\ ::Number)} method called
\texttt{convert(MyRational,\ 5)}, * which called \texttt{MyRational(5)},
* which returned \texttt{MyRational(5,\ 1)}, * and finally
\texttt{+(::Number,\ ::Number)} called
\texttt{+(MyRational(5,\ 1),\ MyRational(2,\ 3))}, * which returned
\texttt{MyRational(17,\ 3)}.

    The benefit of this approach is that we only need to implement the
\texttt{+}, \texttt{-}, etc. functions for pairs of \texttt{MyRational}
values, not with all combinations of \texttt{MyRational} values and
integers.

    If your head hurts, it's perfectly normal. ;-) Writing a new type that
is easy to use, flexible and plays nicely with existing types takes a
bit of planning and work, but the point is that you will not write these
every day, and once you have, they will make your life much easier.

    Now let's handle the case where we want to execute operations with
\texttt{MyRational} values and floats. In this case, we naturally want
to promote the \texttt{MyRational} value to a float. We first need to
define how to convert a \texttt{MyRational} value to any subtype of
\texttt{AbstractFloat}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{242}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{convert}\PY{p}{(}\PY{o}{::}\PY{k+kt}{Type}\PY{p}{\PYZob{}}\PY{k+kt}{T}\PY{p}{\PYZcb{}}\PY{p}{,} \PY{n}{x}\PY{o}{::}\PY{k+kt}{MyRational}\PY{p}{)} \PY{k}{where} \PY{p}{\PYZob{}}\PY{k+kt}{T} \PY{o}{\PYZlt{}:} \PY{k+kt}{AbstractFloat}\PY{p}{\PYZcb{}} \PY{o}{=} \PY{n}{T}\PY{p}{(}\PY{n}{x}\PY{o}{.}\PY{n}{num} \PY{o}{/} \PY{n}{x}\PY{o}{.}\PY{n}{den}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{242}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
convert (generic function with 536 methods)
\end{Verbatim}
\end{tcolorbox}
        
    This \texttt{convert()} works with any type \texttt{T} which is a
subtype of \texttt{AbstractFloat}. It just computes
\texttt{x.num\ /\ x.den} and converts the result to type \texttt{T}.
Let's try it:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{243}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{convert}\PY{p}{(}\PY{k+kt}{Float64}\PY{p}{,} \PY{l+m+mi}{3} \PY{o}{⨸} \PY{l+m+mi}{2}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{243}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
1.5
\end{Verbatim}
\end{tcolorbox}
        
    Now let's define a \texttt{promote\_rule()} method which will work for
any type \texttt{T} which is a subtype of \texttt{AbstractFloat}, and
which will give priority to \texttt{T} over \texttt{MyRational}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{244}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{promote\PYZus{}rule}\PY{p}{(}\PY{o}{::}\PY{k+kt}{Type}\PY{p}{\PYZob{}}\PY{k+kt}{MyRational}\PY{p}{\PYZcb{}}\PY{p}{,} \PY{o}{::}\PY{k+kt}{Type}\PY{p}{\PYZob{}}\PY{k+kt}{T}\PY{p}{\PYZcb{}}\PY{p}{)} \PY{k}{where} \PY{p}{\PYZob{}}\PY{k+kt}{T} \PY{o}{\PYZlt{}:} \PY{k+kt}{AbstractFloat}\PY{p}{\PYZcb{}} \PY{o}{=} \PY{n}{T}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{244}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
promote\_rule (generic function with 163 methods)
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{245}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{promote}\PY{p}{(}\PY{l+m+mi}{1} \PY{o}{⨸} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mf}{4.0}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{245}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
(0.5, 4.0)
\end{Verbatim}
\end{tcolorbox}
        
    Now we can combine floats and \texttt{MyRational} values easily:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{246}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{l+m+mf}{2.25} \PY{o}{\PYZca{}} \PY{p}{(}\PY{l+m+mi}{1} \PY{o}{⨸} \PY{l+m+mi}{2}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{246}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
1.5
\end{Verbatim}
\end{tcolorbox}
        
    \hypertarget{parametric-types-and-functions}{%
\subsection{Parametric Types and
Functions}\label{parametric-types-and-functions}}

    Julia's \texttt{Rational} type is actually a \textbf{parametric type}
which ensures that the numerator and denominator have the same type
\texttt{T}, subtype of \texttt{Integer}. Here's a new version of our
rational struct which enforces the same constraint:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{247}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{struct} \PY{k+kt}{MyRational2}\PY{p}{\PYZob{}}\PY{k+kt}{T} \PY{o}{\PYZlt{}:} \PY{k+kt}{Integer}\PY{p}{\PYZcb{}}
    \PY{n}{num}\PY{o}{::}\PY{k+kt}{T}
    \PY{n}{den}\PY{o}{::}\PY{k+kt}{T}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    To instantiate this type, we can specify the type \texttt{T}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{248}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kt}{MyRational2}\PY{p}{\PYZob{}}\PY{k+kt}{BigInt}\PY{p}{\PYZcb{}}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{248}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
MyRational2\{BigInt\}(2, 3)
\end{Verbatim}
\end{tcolorbox}
        
    Alternatively, we can use the \texttt{MyRational2} type's default
constructor, with two integers of the same type:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{249}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{MyRational2}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{249}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
MyRational2\{Int64\}(2, 3)
\end{Verbatim}
\end{tcolorbox}
        
    If we want to be able to construct a \texttt{MyRational2} with integers
of different types, we must write an appropriate constructor which
handles the promotion rule:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{250}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{function} \PY{n}{MyRational2}\PY{p}{(}\PY{n}{num}\PY{o}{::}\PY{k+kt}{Integer}\PY{p}{,} \PY{n}{den}\PY{o}{::}\PY{k+kt}{Integer}\PY{p}{)}
    \PY{n}{MyRational2}\PY{p}{(}\PY{n}{promote}\PY{p}{(}\PY{n}{num}\PY{p}{,} \PY{n}{den}\PY{p}{)}\PY{o}{...}\PY{p}{)}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{250}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
MyRational2
\end{Verbatim}
\end{tcolorbox}
        
    This constructor accepts two integers of potentially different types,
and promotes them to the same type. Then it calls the default
\texttt{MyRational2} constructor which expects two arguments of the same
type. The syntax \texttt{f(args...)} is analog to Python's
\texttt{f(*args)}.

    Let's see if this works:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{251}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{MyRational2}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,} \PY{k+kt}{BigInt}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{251}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
MyRational2\{BigInt\}(2, 3)
\end{Verbatim}
\end{tcolorbox}
        
    Great!

    Note that all parametrized types such as \texttt{MyRational2\{Int64\}}
or \texttt{MyRational2\{BigInt\}} are subtypes of \texttt{MyRational2}.
So if a function accepts a \texttt{MyRational2} argument, you can pass
it an instance of any specific, parametrized type:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{252}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{function} \PY{n}{for\PYZus{}any\PYZus{}my\PYZus{}rational2}\PY{p}{(}\PY{n}{x}\PY{o}{::}\PY{k+kt}{MyRational2}\PY{p}{)}
    \PY{n}{println}\PY{p}{(}\PY{n}{x}\PY{p}{)}
\PY{k}{end}

\PY{n}{for\PYZus{}any\PYZus{}my\PYZus{}rational2}\PY{p}{(}\PY{k+kt}{MyRational2}\PY{p}{\PYZob{}}\PY{k+kt}{BigInt}\PY{p}{\PYZcb{}}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}
\PY{n}{for\PYZus{}any\PYZus{}my\PYZus{}rational2}\PY{p}{(}\PY{k+kt}{MyRational2}\PY{p}{\PYZob{}}\PY{k+kt}{Int64}\PY{p}{\PYZcb{}}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
MyRational2\{BigInt\}(1, 2)
MyRational2\{Int64\}(1, 2)
    \end{Verbatim}

    A more explicit (but verbose) syntax for this function is:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{253}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{function} \PY{n}{for\PYZus{}any\PYZus{}my\PYZus{}rational2}\PY{p}{(}\PY{n}{x}\PY{o}{::}\PY{k+kt}{MyRational2}\PY{p}{\PYZob{}}\PY{k+kt}{T}\PY{p}{\PYZcb{}}\PY{p}{)} \PY{k}{where} \PY{p}{\PYZob{}}\PY{k+kt}{T} \PY{o}{\PYZlt{}:} \PY{k+kt}{Integer}\PY{p}{\PYZcb{}}
    \PY{n}{println}\PY{p}{(}\PY{n}{x}\PY{p}{)}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{253}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
for\_any\_my\_rational2 (generic function with 1 method)
\end{Verbatim}
\end{tcolorbox}
        
    It's useful to think of types as sets. For example, the \texttt{Int64}
type represents the set of all 64-bit integer values, so
\texttt{42\ isa\ Int64}: * When \texttt{x} is an instance of some type
\texttt{T}, it is an element of the set \texttt{T} represents, and
\texttt{x\ isa\ T}. * When \texttt{U} is a subtype of \texttt{V},
\texttt{U} is a subset of \texttt{V}, and \texttt{U\ \textless{}:\ V}.

The \texttt{MyRational2} type itself (without any parameter) represents
the set of all values of \texttt{MyRational2\{T\}} for all subtypes
\texttt{T} of \texttt{Integer}. In other words, it is the union of all
the \texttt{MyRational2\{T\}} types. This is called a \texttt{UnionAll}
type, and indeed the type \texttt{MyRational2} itself is an instance of
the \texttt{UnionAll} type:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{254}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nd}{@assert} \PY{k+kt}{MyRational2}\PY{p}{\PYZob{}}\PY{k+kt}{BigInt}\PY{p}{\PYZcb{}}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)} \PY{k}{isa} \PY{k+kt}{MyRational2}\PY{p}{\PYZob{}}\PY{k+kt}{BigInt}\PY{p}{\PYZcb{}}
\PY{n+nd}{@assert} \PY{k+kt}{MyRational2}\PY{p}{\PYZob{}}\PY{k+kt}{BigInt}\PY{p}{\PYZcb{}}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)} \PY{k}{isa} \PY{n}{MyRational2}
\PY{n+nd}{@assert} \PY{n}{MyRational2} \PY{o}{===} \PY{p}{(}\PY{k+kt}{MyRational2}\PY{p}{\PYZob{}}\PY{k+kt}{T}\PY{p}{\PYZcb{}} \PY{k}{where} \PY{p}{\PYZob{}}\PY{k+kt}{T} \PY{o}{\PYZlt{}:} \PY{k+kt}{Integer}\PY{p}{\PYZcb{}}\PY{p}{)}
\PY{n+nd}{@assert} \PY{k+kt}{MyRational2}\PY{p}{\PYZob{}}\PY{k+kt}{BigInt}\PY{p}{\PYZcb{}} \PY{o}{\PYZlt{}:} \PY{k+kt}{MyRational2}
\PY{n+nd}{@assert} \PY{n}{MyRational2} \PY{k}{isa} \PY{k+kt}{UnionAll}
\end{Verbatim}
\end{tcolorbox}

    If we dump the \texttt{MyRational2} type, we can see that it is a
\texttt{UnionAll} instance, with a parameter type \texttt{T},
constrained to a subtype of the \texttt{Integer} type (since the upper
bound \texttt{ub} is \texttt{Integer}):

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{255}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{dump}\PY{p}{(}\PY{n}{MyRational2}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
UnionAll
  var: TypeVar
    name: Symbol T
    lb: Union\{\}
    ub: Integer <: Real
  body: MyRational2\{T<:Integer\} <: Any
    num::T
    den::T
    \end{Verbatim}

    There's a lot more to learn about Julia types. When you feel ready to
explore this in more depth, check out
\href{https://docs.julialang.org/en/v1.4/manual/types/}{this page}. You
can also take a look at the
\href{https://github.com/JuliaLang/julia/blob/master/base/rational.jl}{source
code of Julia's rationals}.

    \hypertarget{writingreading-files}{%
\section{Writing/Reading Files}\label{writingreading-files}}

The \texttt{do} syntax we saw earlier is helpful when using the
\texttt{open()} function:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{256}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{open}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{test.txt}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{w}\PY{l+s}{\PYZdq{}}\PY{p}{)} \PY{k}{do} \PY{n}{f}
    \PY{n}{write}\PY{p}{(}\PY{n}{f}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{This is a test.}\PY{l+s+se}{\PYZbs{}n}\PY{l+s}{\PYZdq{}}\PY{p}{)}
    \PY{n}{write}\PY{p}{(}\PY{n}{f}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{I repeat, this is a test.}\PY{l+s+se}{\PYZbs{}n}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{k}{end}

\PY{n}{open}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{test.txt}\PY{l+s}{\PYZdq{}}\PY{p}{)} \PY{k}{do} \PY{n}{f}
    \PY{k}{for} \PY{n}{line} \PY{k}{in} \PY{n}{eachline}\PY{p}{(}\PY{n}{f}\PY{p}{)}
        \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{[}\PY{l+s+si}{\PYZdl{}line}\PY{l+s}{]}\PY{l+s}{\PYZdq{}}\PY{p}{)}
    \PY{k}{end}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
[This is a test.]
[I repeat, this is a test.]
    \end{Verbatim}

    The \texttt{open()} function automatically closes the file at the end of
the block. Notice that the line feeds \texttt{\textbackslash{}n} at the
end of each line are not returned by the \texttt{eachline()} function.
So the equivalent Python code is:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# PYTHON}
\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(}\StringTok{"test.txt"}\NormalTok{, }\StringTok{"w"}\NormalTok{) }\ImportTok{as}\NormalTok{ f:}
\NormalTok{    f.write(}\StringTok{"This is a test.}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{    f.write(}\StringTok{"I repeat, this is a test.}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(}\StringTok{"test.txt"}\NormalTok{) }\ImportTok{as}\NormalTok{ f:}
    \ControlFlowTok{for}\NormalTok{ line }\KeywordTok{in}\NormalTok{ f.readlines():}
\NormalTok{        line }\OperatorTok{=}\NormalTok{ line.rstrip(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
        \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"[}\SpecialCharTok{\{}\NormalTok{line}\SpecialCharTok{\}}\SpecialStringTok{]"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

    Alternatively, you can read the whole file into a string:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{257}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{open}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{test.txt}\PY{l+s}{\PYZdq{}}\PY{p}{)} \PY{k}{do} \PY{n}{f}
    \PY{n}{s} \PY{o}{=} \PY{n}{read}\PY{p}{(}\PY{n}{f}\PY{p}{,} \PY{k+kt}{String}\PY{p}{)}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{257}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
"This is a test.\textbackslash{}nI repeat, this is a test.\textbackslash{}n"
\end{Verbatim}
\end{tcolorbox}
        
    Or more concisely:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{258}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{s} \PY{o}{=} \PY{n}{read}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{test.txt}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{k+kt}{String}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{258}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
"This is a test.\textbackslash{}nI repeat, this is a test.\textbackslash{}n"
\end{Verbatim}
\end{tcolorbox}
        
    The Python equivalent is:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# PYTHON}
\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(}\StringTok{"test.txt"}\NormalTok{) }\ImportTok{as}\NormalTok{ f:}
\NormalTok{    s }\OperatorTok{=}\NormalTok{ f.read()}
\end{Highlighting}
\end{Shaded}

    \hypertarget{exceptions}{%
\section{Exceptions}\label{exceptions}}

Julia's exceptions behave very much like in Python:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{259}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{a} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}
\PY{k}{try}
    \PY{n}{push!}\PY{p}{(}\PY{n}{a}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)}
    \PY{c}{\PYZsh{}throw(\PYZdq{}Oops\PYZdq{}) \PYZsh{} try uncommenting this line}
    \PY{n}{push!}\PY{p}{(}\PY{n}{a}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
\PY{k}{catch} \PY{n}{ex}
    \PY{n}{println}\PY{p}{(}\PY{n}{ex}\PY{p}{)}
    \PY{n}{push!}\PY{p}{(}\PY{n}{a}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{)}
\PY{k}{finally}
    \PY{n}{push!}\PY{p}{(}\PY{n}{a}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{)}
\PY{k}{end}
\PY{n}{println}\PY{p}{(}\PY{n}{a}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
[1, 2, 3, 5]
    \end{Verbatim}

    The equivalent Python code is:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# PYTHON}
\NormalTok{a }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{]}
\ControlFlowTok{try}\NormalTok{:}
\NormalTok{    a.append(}\DecValTok{2}\NormalTok{)}
    \CommentTok{\#raise Exception("Oops") \# try uncommenting this line}
\NormalTok{    a.append(}\DecValTok{3}\NormalTok{)}
\ControlFlowTok{except} \PreprocessorTok{Exception} \ImportTok{as}\NormalTok{ ex:}
    \BuiltInTok{print}\NormalTok{(ex)}
\NormalTok{    a.append(}\DecValTok{4}\NormalTok{)}
\ControlFlowTok{finally}\NormalTok{:}
\NormalTok{    a.append(}\DecValTok{5}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

    There is a whole hierarchy of standard exceptions which can be thrown,
just like in Python. For example:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{260}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{choice} \PY{o}{=} \PY{l+m+mi}{1} \PY{c}{\PYZsh{} try changing this value (from 1 to 4)}
\PY{k}{try}
    \PY{n}{choice} \PY{o}{==} \PY{l+m+mi}{1} \PY{o}{\PYZam{}\PYZam{}} \PY{n}{open}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{/foo/bar/i\PYZus{}dont\PYZus{}exist.txt}\PY{l+s}{\PYZdq{}}\PY{p}{)}
    \PY{n}{choice} \PY{o}{==} \PY{l+m+mi}{2} \PY{o}{\PYZam{}\PYZam{}} \PY{n}{sqrt}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}
    \PY{n}{choice} \PY{o}{==} \PY{l+m+mi}{3} \PY{o}{\PYZam{}\PYZam{}} \PY{n}{push!}\PY{p}{(}\PY{n}{a}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{Oops}\PY{l+s}{\PYZdq{}}\PY{p}{)}
    \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Everything worked like a charm}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{k}{catch} \PY{n}{ex}
    \PY{k}{if} \PY{n}{ex} \PY{k}{isa} \PY{k+kt}{SystemError}
        \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Oops. System error \PYZsh{}}\PY{l+s+si}{\PYZdl{}}\PY{p}{(}\PY{n}{ex}\PY{o}{.}\PY{n}{errnum}\PY{p}{)}\PY{l+s}{ (}\PY{l+s+si}{\PYZdl{}}\PY{p}{(}\PY{n}{ex}\PY{o}{.}\PY{n}{prefix}\PY{p}{)}\PY{l+s}{)}\PY{l+s}{\PYZdq{}}\PY{p}{)}
    \PY{k}{elseif} \PY{n}{ex} \PY{k}{isa} \PY{k+kt}{DomainError}
        \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Oh no, I could not compute sqrt(\PYZhy{}1)}\PY{l+s}{\PYZdq{}}\PY{p}{)}
    \PY{k}{else}
        \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{I got an unexpected error: }\PY{l+s+si}{\PYZdl{}ex}\PY{l+s}{\PYZdq{}}\PY{p}{)}
    \PY{k}{end}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Oops. System error \#2 (opening file "/foo/bar/i\_dont\_exist.txt")
    \end{Verbatim}

    Compare this with Python's equivalent code:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# PYTHON}
\NormalTok{choice }\OperatorTok{=} \DecValTok{3} \CommentTok{\# try changing this value (from 1 to 4)}
\ControlFlowTok{try}\NormalTok{:}
  \ControlFlowTok{if}\NormalTok{ choice }\OperatorTok{==} \DecValTok{1}\NormalTok{:}
      \BuiltInTok{open}\NormalTok{(}\StringTok{"/foo/bar/i\_dont\_exist.txt"}\NormalTok{)}
  \ControlFlowTok{if}\NormalTok{ choice }\OperatorTok{==} \DecValTok{2}\NormalTok{:}
\NormalTok{      math.sqrt(}\OperatorTok{{-}}\DecValTok{1}\NormalTok{)}
  \ControlFlowTok{if}\NormalTok{ choice }\OperatorTok{==} \DecValTok{3}\NormalTok{:}
      \CommentTok{\#a.append("Ok") \# this would actually work}
      \ControlFlowTok{raise} \PreprocessorTok{TypeError}\NormalTok{(}\StringTok{"Oops"}\NormalTok{) }\CommentTok{\# so let\textquotesingle{}s fail manually}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Everything worked like a charm"}\NormalTok{)}
\ControlFlowTok{except} \PreprocessorTok{OSError} \ImportTok{as}\NormalTok{ ex:}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Oops. OS error (\#}\SpecialCharTok{\{ex.}\NormalTok{errno}\SpecialCharTok{\}}\SpecialStringTok{ (}\SpecialCharTok{\{ex.}\NormalTok{strerror}\SpecialCharTok{\}}\SpecialStringTok{)"}\NormalTok{)}
\ControlFlowTok{except} \PreprocessorTok{ValueError}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Oh no, I could not compute sqrt({-}1)"}\NormalTok{)}
\ControlFlowTok{except} \PreprocessorTok{Exception} \ImportTok{as}\NormalTok{ ex:}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"I got an unexpected error: }\SpecialCharTok{\{ex\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

    A few things to note here:

\begin{itemize}
\tightlist
\item
  Julia only allows a single \texttt{catch} block which handles all
  possible exceptions.
\item
  \texttt{obj\ isa\ SomeClass} is a shorthand for
  \texttt{isa(obj,\ SomeClass)} which is equivalent to Python's
  \texttt{isinstance(obj,\ SomeClass)}.
\end{itemize}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.45}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.55}}@{}}
\toprule
Julia & Python \\
\midrule
\endhead
\texttt{try}~~~~\texttt{...}\texttt{catch\ ex}~~~~\texttt{if\ ex\ isa\ SomeError}~~~~~~~~\texttt{...}~~~~\texttt{else}~~~~~~~~\texttt{...}~~~~\texttt{end}\texttt{finally}~~~~\texttt{...}\texttt{end}
&
\texttt{try:}~~~~\texttt{...}\texttt{except\ SomeException\ as\ ex:}~~~~\texttt{...}\texttt{except\ Exception\ as\ ex:}~~~~\texttt{...}\texttt{finally:}~~~~\texttt{...} \\
\texttt{throw\ any\_value} & \texttt{raise\ SomeException(...)} \\
\texttt{obj\ isa\ SomeType}or \texttt{isa(obj,\ SomeType}) &
\texttt{isinstance(obj,\ SomeType)} \\
\bottomrule
\end{longtable}

    Note that Julia does not support the equivalent of Python's
\texttt{try\ /\ catch\ /\ else} construct. You need to write something
like this:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{261}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{catch\PYZus{}exception} \PY{o}{=} \PY{n+nb}{true}
\PY{k}{try}
    \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Try something}\PY{l+s}{\PYZdq{}}\PY{p}{)}
    \PY{c}{\PYZsh{}error(\PYZdq{}ERROR: Catch me!\PYZdq{}) \PYZsh{} try uncommenting this line}
    \PY{n}{catch\PYZus{}exception} \PY{o}{=} \PY{n+nb}{false}
    \PY{c}{\PYZsh{}error(\PYZdq{}ERROR: Don\PYZsq{}t catch me!\PYZdq{}) \PYZsh{} try uncommenting this line}
    \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{No error occurred}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{k}{catch} \PY{n}{ex}
    \PY{k}{if} \PY{n}{catch\PYZus{}exception}
        \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{I caught this exception: }\PY{l+s+si}{\PYZdl{}ex}\PY{l+s}{\PYZdq{}}\PY{p}{)}
    \PY{k}{else}
        \PY{n}{throw}\PY{p}{(}\PY{n}{ex}\PY{p}{)}
    \PY{k}{end}
\PY{k}{finally}
    \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{The end}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{k}{end}
\PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{After the end}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Try something
No error occurred
The end
After the end
    \end{Verbatim}

    The equivalent Python code is shorter, but it's fairly uncommon:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# PYTHON}
\ControlFlowTok{try}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Try something"}\NormalTok{)}
    \ControlFlowTok{raise} \PreprocessorTok{Exception}\NormalTok{(}\StringTok{"Catch me!"}\NormalTok{) }\CommentTok{\# try uncommenting this line}
\ControlFlowTok{except} \PreprocessorTok{Exception} \ImportTok{as}\NormalTok{ ex:}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"I caught this exception: }\SpecialCharTok{\{ex\}}\SpecialStringTok{"}\NormalTok{)}
\ControlFlowTok{else}\NormalTok{:}
    \ControlFlowTok{raise} \PreprocessorTok{Exception}\NormalTok{(}\StringTok{"Don\textquotesingle{}t catch me!"}\NormalTok{) }\CommentTok{\# try uncommenting this line}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"No error occured"}\NormalTok{)}
\ControlFlowTok{finally}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"The end"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"After the end"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

    \hypertarget{docstrings}{%
\section{Docstrings}\label{docstrings}}

It's good practice to add docstrings to every function you export. The
docstring is placed just \emph{before} the definition of the function:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{262}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{l+s}{\PYZdq{}}\PY{l+s}{Compute the square of number x}\PY{l+s}{\PYZdq{}}
\PY{n}{square}\PY{p}{(}\PY{n}{x}\PY{o}{::}\PY{k+kt}{Number}\PY{p}{)} \PY{o}{=} \PY{n}{x}\PY{o}{\PYZca{}}\PY{l+m+mi}{2}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{262}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
square
\end{Verbatim}
\end{tcolorbox}
        
    You can retrieve a function's docstring using the \texttt{@doc} macro:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{263}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nd}{@doc} \PY{n}{square}
\end{Verbatim}
\end{tcolorbox}
 
            
\prompt{Out}{outcolor}{263}{}
    
    Compute the square of number x



    

    The docstring is displayed when asking for help:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{264}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{o}{?}\PY{n}{square}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
search: \textbf{s}\textbf{q}\textbf{u}\textbf{a}\textbf{r}[
0m\textbf{e} \textbf{S}\textbf{q}\textbf{u}\textbf{a}\textbf{r[
22m}\textbf{e} \textbf{S}\textbf{q}\textbf{u}\textbf{a}[
1mr\textbf{e}\_v2 My\textbf{S}\textbf{q}\textbf{u}\textbf{a
[22m}\textbf{r}\textbf{e}s Ab\textbf{s}tractS\textbf{q}\textbf{u
[22m}\textbf{a}\textbf{r}\textbf{e}

    \end{Verbatim}
 
            
\prompt{Out}{outcolor}{264}{}
    
    Compute the square of number x



    

    Docstrings follow the
\href{https://en.wikipedia.org/wiki/Markdown\#:~:text=Markdown\%20is\%20a\%20lightweight\%20markup,using\%20a\%20plain\%20text\%20editor.}{Markdown
format}. A typical docstring starts with the signature of the function,
indented by 4 spaces, so it will get syntax highlighted as Julia code.
It also includes an \texttt{Examples} section with Julia REPL outputs:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{265}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{l+s}{\PYZdq{}\PYZdq{}\PYZdq{}}
\PY{l+s}{    cube(x::Number)}

\PY{l+s}{Compute the cube of `x`.}

\PY{l+s}{\PYZsh{} Examples}
\PY{l+s}{```julia\PYZhy{}repl}
\PY{l+s}{julia\PYZgt{} cube(5)}
\PY{l+s}{125}
\PY{l+s}{julia\PYZgt{} cube(im)}
\PY{l+s}{0 \PYZhy{} 1im}
\PY{l+s}{```}
\PY{l+s}{\PYZdq{}\PYZdq{}\PYZdq{}}
\PY{n}{cube}\PY{p}{(}\PY{n}{x}\PY{p}{)} \PY{o}{=} \PY{n}{x}\PY{o}{\PYZca{}}\PY{l+m+mi}{3}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{265}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
cube
\end{Verbatim}
\end{tcolorbox}
        
    Instead of using \texttt{julia-repl} code blocks for the examples, you
can use \texttt{jldoctest} to mark these examples as doctests (similar
to Python's doctests).

    The help gets nicely formatted:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{266}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{o}{?}\PY{n}{cube}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
search: \textbf{c}\textbf{u}\textbf{b}\textbf{e}
\textbf{C}do\textbf{u}\textbf{b}l\textbf{e}

    \end{Verbatim}
 
            
\prompt{Out}{outcolor}{266}{}
    
    \begin{verbatim}
cube(x::Number)
\end{verbatim}
Compute the cube of \texttt{x}.

\section{Examples}
\begin{verbatim}
julia> cube(5)
125
julia> cube(im)
0 - 1im
\end{verbatim}


    

    When there are several methods for a given function, it is common to
give general information about the function in the first method (usually
the most generic), and only add docstrings to other methods if they add
useful information (without repeating the general info).

Alternatively, you may attach the general information to the function
itself:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{267}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{l+s}{\PYZdq{}\PYZdq{}\PYZdq{}}
\PY{l+s}{    foo(x)}

\PY{l+s}{Compute the foo of the bar}
\PY{l+s}{\PYZdq{}\PYZdq{}\PYZdq{}}
\PY{k}{function} \PY{n}{foo} \PY{k}{end}  \PY{c}{\PYZsh{} declares the foo function}

\PY{c}{\PYZsh{} foo(x::Number) behaves normally, no need for a docstring}
\PY{n}{foo}\PY{p}{(}\PY{n}{x}\PY{o}{::}\PY{k+kt}{Number}\PY{p}{)} \PY{o}{=} \PY{l+s}{\PYZdq{}}\PY{l+s}{baz}\PY{l+s}{\PYZdq{}}

\PY{l+s}{\PYZdq{}\PYZdq{}\PYZdq{}}
\PY{l+s}{    foo(x::String)}

\PY{l+s}{For strings, compute the qux of the bar instead.}
\PY{l+s}{\PYZdq{}\PYZdq{}\PYZdq{}}
\PY{n}{foo}\PY{p}{(}\PY{n}{x}\PY{o}{::}\PY{k+kt}{String}\PY{p}{)} \PY{o}{=} \PY{l+s}{\PYZdq{}}\PY{l+s}{qux}\PY{l+s}{\PYZdq{}}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{267}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
foo
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{268}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{o}{?}\PY{n}{foo}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
search: \textbf{f}\textbf{o}\textbf{o}
\textbf{f}l\textbf{o}\textbf{o}r
\textbf{F}\textbf{o}ntc\textbf{o}nfig
pointer\_\textbf{f}r\textbf{o}m\_\textbf{o}bjref
Over\textbf{f}l\textbf{o}wErr\textbf{o}r
Round\textbf{F}r\textbf{o}mZer\textbf{o}

    \end{Verbatim}
 
            
\prompt{Out}{outcolor}{268}{}
    
    \begin{verbatim}
foo(x)
\end{verbatim}
Compute the foo of the bar

\rule{\textwidth}{1pt}
\begin{verbatim}
foo(x::String)
\end{verbatim}
For strings, compute the qux of the bar instead.



    

    \hypertarget{macros}{%
\section{Macros}\label{macros}}

    We have seen a few macros already: \texttt{@which}, \texttt{@assert},
\texttt{@time}, \texttt{@benchmark}, \texttt{@btime} and \texttt{@doc}.
You guessed it: all macros start with an \texttt{@} sign.

What is a macro? It is a function which can fully inspect the expression
that follows it, and apply any transformation to that code at parse
time, before compilation.

This makes it possible for anyone to effectively extend the language in
any way they please. Whereas C/C++ macros just do simple text
replacement, \textbf{Julia macros are powerful meta-programming tools}.

On the flip side, this also means that \textbf{each macro has its own
syntax and behavior}.

\textbf{A personal opinion}: in my experience, languages that provide
great flexibility typically attract a community of programmers with a
tinkering mindset, who will \emph{love} to experiment with all the fun
features the language has to offer. This is great for creativity, but it
can also be a nuisance if the community ends up producing too much
experimental code, without much care for code reliability, API
stability, or even for simplicity. By all means, let's be creative,
let's experiment, but \emph{with great power comes great
responsibility}: let's also value reliability, stability and simplicity.

That said, to give you an idea of what macro definitions look like in
Julia, here's a simple toy macro that replaces \texttt{a\ +\ b}
expressions with \texttt{a\ -\ b}, and leaves other expressions alone.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{269}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{macro} \PY{n}{addtosub}\PY{p}{(}\PY{n}{x}\PY{p}{)}
  \PY{k}{if} \PY{n}{x}\PY{o}{.}\PY{n}{head} \PY{o}{==} \PY{l+s+ss}{:call} \PY{o}{\PYZam{}\PYZam{}} \PY{n}{x}\PY{o}{.}\PY{n}{args}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]} \PY{o}{==} \PY{o}{:}\PY{o}{+} \PY{o}{\PYZam{}\PYZam{}} \PY{n}{length}\PY{p}{(}\PY{n}{x}\PY{o}{.}\PY{n}{args}\PY{p}{)} \PY{o}{==} \PY{l+m+mi}{3}
    \PY{k+kt}{Expr}\PY{p}{(}\PY{l+s+ss}{:call}\PY{p}{,} \PY{o}{:}\PY{o}{\PYZhy{}}\PY{p}{,} \PY{n}{x}\PY{o}{.}\PY{n}{args}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,} \PY{n}{x}\PY{o}{.}\PY{n}{args}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{)}
  \PY{k}{else}
    \PY{n}{x}
  \PY{k}{end}
\PY{k}{end}

\PY{n+nd}{@addtosub} \PY{l+m+mi}{10} \PY{o}{+} \PY{l+m+mi}{2}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{269}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
8
\end{Verbatim}
\end{tcolorbox}
        
    In this macro definition, \texttt{:call}, \texttt{:+} and \texttt{:-}
are \textbf{symbols}. These are similar to strings, only more efficient
and less flexible. They are typically used as identifiers, such as keys
in dictionaries.

    If you're curious, the macro works because the parser converts
\texttt{10\ +\ 2} to \texttt{Expr(:call,\ :+,\ 10,\ 2)} and passes this
expression to the macro (before compilation). The \texttt{if} statement
checks that the expression is a function call, where the called function
is the \texttt{+} function, with two arguments. If so, then the macro
returns a new expression, corresponding to a call to the \texttt{-}
function, with the same arguments. So \texttt{a\ +\ b} becomes
\texttt{a\ -\ b}.

    For more info, check out
\href{https://docs.julialang.org/en/v1/manual/metaprogramming/}{this
page}.

    \hypertarget{special-prefixed-strings}{%
\subsection{Special Prefixed Strings}\label{special-prefixed-strings}}

    \texttt{py"..."} strings are defined by the \texttt{PyCall} module.
Writing \texttt{py"something"} is equivalent to writing
\texttt{@py\_str\ "something"}. In other words, anyone can write a macro
that defines a new kind of prefixed string. For example, if you write
the \texttt{@ok\_str} macro, it will be called when you write
\texttt{ok"something"}.

Another example is the \texttt{Pkg} module which defines the
\texttt{@pkg\_str} macro: this is why you can use \texttt{pkg"..."} to
interact with the \texttt{Pkg} module. This is how
\texttt{pkg"add\ PyCall;\ precompile;"} worked (at the end of the very
first cell). This downloaded, installed and precompiled the
\texttt{PyCall} module.

    \hypertarget{modules}{%
\section{Modules}\label{modules}}

In Python, a module must be defined in a dedicated file. In Julia,
modules are independent from the file system. You can define several
modules per file, or define one module across multiple files, it's up to
you. Let's create a simple module containing two submodules, each
containing a variable and a function:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{270}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{module} \PY{n}{ModA}
    \PY{n+nb}{pi} \PY{o}{=} \PY{l+m+mf}{3.14}
    \PY{n}{square}\PY{p}{(}\PY{n}{x}\PY{p}{)} \PY{o}{=} \PY{n}{x}\PY{o}{\PYZca{}}\PY{l+m+mi}{2}

    \PY{k}{module} \PY{n}{ModB}
        \PY{n}{e} \PY{o}{=} \PY{l+m+mf}{2.718}
        \PY{n}{cube}\PY{p}{(}\PY{n}{x}\PY{p}{)} \PY{o}{=} \PY{n}{x}\PY{o}{\PYZca{}}\PY{l+m+mi}{3}
    \PY{k}{end}

    \PY{k}{module} \PY{n}{ModC}
        \PY{n}{root2} \PY{o}{=} \PY{o}{√}\PY{l+m+mi}{2}
        \PY{n}{relu}\PY{p}{(}\PY{n}{x}\PY{p}{)} \PY{o}{=} \PY{n}{max}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{n}{x}\PY{p}{)}
    \PY{k}{end}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{270}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
Main.ModA
\end{Verbatim}
\end{tcolorbox}
        
    The default module is \texttt{Main}, so whatever we define is put in
this module (except when defining a package, as we will see). This is
why the \texttt{ModA}'s full name is \texttt{Main.ModA}.

    We can now access the contents of these modules by providing the full
paths:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{271}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{Main}\PY{o}{.}\PY{n}{ModA}\PY{o}{.}\PY{n}{ModC}\PY{o}{.}\PY{n}{root2}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{271}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
1.4142135623730951
\end{Verbatim}
\end{tcolorbox}
        
    Since our code runs in the \texttt{Main} module, we can leave out the
\texttt{Main.} part:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{272}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{ModA}\PY{o}{.}\PY{n}{ModC}\PY{o}{.}\PY{n}{root2}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{272}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
1.4142135623730951
\end{Verbatim}
\end{tcolorbox}
        
    Alternatively, you can use \texttt{import}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{273}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{import} \PY{n}{Main}\PY{o}{.}\PY{n}{ModA}\PY{o}{.}\PY{n}{ModC}\PY{o}{.}\PY{n}{root2}

\PY{n}{root2}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{273}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
1.4142135623730951
\end{Verbatim}
\end{tcolorbox}
        
    Or we can use \texttt{import} with a relative path. In this case, we
need to prefix \texttt{ModA} with a dot \texttt{.} to indicate that we
want the module \texttt{ModA} located in the current module:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{274}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{import} \PY{o}{.}\PY{n}{ModA}\PY{o}{.}\PY{n}{ModC}\PY{o}{.}\PY{n}{root2}

\PY{n}{root2}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{274}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
1.4142135623730951
\end{Verbatim}
\end{tcolorbox}
        
    Alternatively, we can \texttt{import} the submodule:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{275}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{import} \PY{o}{.}\PY{n}{ModA}\PY{o}{.}\PY{n}{ModC}

\PY{n}{ModC}\PY{o}{.}\PY{n}{root2}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{275}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
1.4142135623730951
\end{Verbatim}
\end{tcolorbox}
        
    When you want to import more than one name from a module, you can use
this syntax:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{276}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{import} \PY{o}{.}\PY{n}{ModA}\PY{o}{.}\PY{n}{ModC}\PY{o}{:} \PY{n}{root2}\PY{p}{,} \PY{n}{relu}
\end{Verbatim}
\end{tcolorbox}

    This is equivalent to this more verbose syntax:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{277}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{import} \PY{o}{.}\PY{n}{ModA}\PY{o}{.}\PY{n}{ModC}\PY{o}{.}\PY{n}{root2}\PY{p}{,} \PY{o}{.}\PY{n}{ModA}\PY{o}{.}\PY{n}{ModC}\PY{o}{.}\PY{n}{relu}
\end{Verbatim}
\end{tcolorbox}

    Nested modules do not automatically have access to names in enclosing
modules. To import names from a parent module, use \texttt{..x}. From a
grand-parent module, use \texttt{...x}, and so on.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{278}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{module} \PY{n}{ModD}
    \PY{n}{d} \PY{o}{=} \PY{l+m+mi}{1}
    \PY{k}{module} \PY{n}{ModE}
        \PY{k}{try}
            \PY{n}{println}\PY{p}{(}\PY{n}{d}\PY{p}{)}
        \PY{k}{catch} \PY{n}{ex}
            \PY{n}{println}\PY{p}{(}\PY{n}{ex}\PY{p}{)}
        \PY{k}{end}
    \PY{k}{end}
    \PY{k}{module} \PY{n}{ModF}
        \PY{n}{f} \PY{o}{=} \PY{l+m+mi}{2}
        \PY{k}{module} \PY{n}{ModG}
            \PY{k}{import} \PY{o}{..}\PY{n}{f}
            \PY{k}{import} \PY{o}{...}\PY{n}{d}
            \PY{n}{println}\PY{p}{(}\PY{n}{f}\PY{p}{)}
            \PY{n}{println}\PY{p}{(}\PY{n}{d}\PY{p}{)}
        \PY{k}{end}
    \PY{k}{end}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
UndefVarError(:d)
2
1
    \end{Verbatim}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{278}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
Main.ModD
\end{Verbatim}
\end{tcolorbox}
        
    Instead of \texttt{import}, you can use \texttt{using}. It is analog to
Python's \texttt{from\ foo\ import\ *}. It only gives access to names
which were explicitly exported using \texttt{export} (similar to the way
\texttt{from\ foo\ import\ *} in Python only imports names listed in the
module's \texttt{\_\_all\_\_} list):

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{279}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{module} \PY{n}{ModH}
    \PY{n}{h1} \PY{o}{=} \PY{l+m+mi}{1}
    \PY{n}{h2} \PY{o}{=} \PY{l+m+mi}{2}
    \PY{k}{export} \PY{n}{h1}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{279}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
Main.ModH
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{280}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{import} \PY{o}{.}\PY{n}{ModH}

\PY{n}{println}\PY{p}{(}\PY{n}{ModH}\PY{o}{.}\PY{n}{h1}\PY{p}{)}

\PY{k}{try}
    \PY{n}{println}\PY{p}{(}\PY{n}{ModH}\PY{o}{.}\PY{n}{h2}\PY{p}{)}
\PY{k}{catch} \PY{n}{ex}
    \PY{n}{ex}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
1
2
    \end{Verbatim}

    Note that \texttt{using\ Foo} not only imports all exported names (like
Python's \texttt{from\ foo\ import\ *}), it also imports \texttt{Foo}
itself (similarly, \texttt{import\ Foo.Bar} imports \texttt{Bar}
itself):

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{281}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{ModH}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{281}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
Main.ModH
\end{Verbatim}
\end{tcolorbox}
        
    Even if a name is not exported, you can always access it import its full
path, or using \texttt{import}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{282}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{ModH}\PY{o}{.}\PY{n}{h2}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{282}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
2
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{283}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{import} \PY{o}{.}\PY{n}{ModH}\PY{o}{.}\PY{n}{h2}

\PY{n}{ModH}\PY{o}{.}\PY{n}{h2}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{283}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
2
\end{Verbatim}
\end{tcolorbox}
        
    You can also import individual names like this:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{284}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{module} \PY{n}{ModG}
    \PY{n}{g1} \PY{o}{=} \PY{l+m+mi}{1}
    \PY{n}{g2} \PY{o}{=} \PY{l+m+mi}{2}
    \PY{k}{export} \PY{n}{g2}
\PY{k}{end}

\PY{k}{import} \PY{o}{.}\PY{n}{ModG}\PY{o}{:} \PY{n}{g1}\PY{p}{,} \PY{n}{g2}

\PY{n}{println}\PY{p}{(}\PY{n}{g1}\PY{p}{)}
\PY{n}{println}\PY{p}{(}\PY{n}{g2}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
1
2
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
WARNING: replacing module ModG.
WARNING: ignoring conflicting import of ModG.g1 into Main
WARNING: ignoring conflicting import of ModG.g2 into Main
    \end{Verbatim}

    Notice that this syntax gives you access to any name you want, whether
or not it was exported. In other words, whether a name is exported or
not only affects the \texttt{import\ Foo} syntax.

    Importantly, when you want to expand a function which is defined in a
module, you must import the function using \texttt{import}, or you must
specify the function's path:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{285}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{module} \PY{n}{ModH}
    \PY{n}{double}\PY{p}{(}\PY{n}{x}\PY{p}{)} \PY{o}{=} \PY{n}{x} \PY{o}{*} \PY{l+m+mi}{2}
    \PY{n}{triple}\PY{p}{(}\PY{n}{x}\PY{p}{)} \PY{o}{=} \PY{n}{x} \PY{o}{*} \PY{l+m+mi}{3}
\PY{k}{end}

\PY{k}{import} \PY{o}{.}\PY{n}{ModH}\PY{o}{:} \PY{n}{double}
\PY{n}{double}\PY{p}{(}\PY{n}{x}\PY{o}{::}\PY{k+kt}{AbstractString}\PY{p}{)} \PY{o}{=} \PY{n}{repeat}\PY{p}{(}\PY{n}{x}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)}

\PY{n}{ModH}\PY{o}{.}\PY{n}{triple}\PY{p}{(}\PY{n}{x}\PY{o}{::}\PY{k+kt}{AbstractString}\PY{p}{)} \PY{o}{=} \PY{n}{repeat}\PY{p}{(}\PY{n}{x}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}

\PY{n}{println}\PY{p}{(}\PY{n}{double}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}
\PY{n}{println}\PY{p}{(}\PY{n}{double}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Two}\PY{l+s}{\PYZdq{}}\PY{p}{)}\PY{p}{)}

\PY{n}{println}\PY{p}{(}\PY{n}{ModH}\PY{o}{.}\PY{n}{triple}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{)}\PY{p}{)}
\PY{n}{println}\PY{p}{(}\PY{n}{ModH}\PY{o}{.}\PY{n}{triple}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Three}\PY{l+s}{\PYZdq{}}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
4
TwoTwo
9
ThreeThreeThree
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
WARNING: replacing module ModH.
    \end{Verbatim}

    You must never extend a function imported with \texttt{import}, unless
you provide the function's path:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{286}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{module} \PY{n}{ModI}
    \PY{n}{quadruple}\PY{p}{(}\PY{n}{x}\PY{p}{)} \PY{o}{=} \PY{n}{x} \PY{o}{*} \PY{l+m+mi}{4}
    \PY{k}{export} \PY{n}{quadruple}
\PY{k}{end}

\PY{k}{import} \PY{o}{.}\PY{n}{ModI}
\PY{n}{ModI}\PY{o}{.}\PY{n}{quadruple}\PY{p}{(}\PY{n}{x}\PY{o}{::}\PY{k+kt}{AbstractString}\PY{p}{)} \PY{o}{=} \PY{n}{repeat}\PY{p}{(}\PY{n}{x}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{)} \PY{c}{\PYZsh{} OK}
\PY{n}{println}\PY{p}{(}\PY{n}{ModI}\PY{o}{.}\PY{n}{quadruple}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{)}\PY{p}{)}
\PY{n}{println}\PY{p}{(}\PY{n}{ModI}\PY{o}{.}\PY{n}{quadruple}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Four}\PY{l+s}{\PYZdq{}}\PY{p}{)}\PY{p}{)}

\PY{c}{\PYZsh{}quadruple(x::AbstractString) = repeat(x, 4) \PYZsh{} uncomment to see the error}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
16
FourFourFourFour
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
WARNING: replacing module ModI.
    \end{Verbatim}

    There is no equivalent of Python's \texttt{import\ foo\ as\ x}
(\href{https://github.com/JuliaLang/julia/issues/1255}{yet}), but you
can do something like this:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{287}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{import} \PY{o}{.}\PY{n}{ModI}\PY{o}{:} \PY{n}{quadruple}
\PY{n}{x} \PY{o}{=} \PY{n}{quadruple}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
WARNING: ignoring conflicting import of ModI.quadruple into Main
    \end{Verbatim}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{287}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
quadruple (generic function with 2 methods)
\end{Verbatim}
\end{tcolorbox}
        
    In general, a module named \texttt{Foo} will be defined in a file named
\texttt{Foo.jl} (along with its submodules). However, if the module
becomes too big for a single file, you can split it into multiple files
and include these files in \texttt{Foo.jl} using the \texttt{include()}
function.

For example, let's create three files: \texttt{Awesome.jl},
\texttt{great.jl} and \texttt{amazing/Fantastic.jl}, where: *
\texttt{Awesome.jl} defines the \texttt{Awesome} module and includes the
other two files * \texttt{great.jl} just defines a function *
\texttt{amazing/Fantastic.jl} defines the \texttt{Fantastic} submodule

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{288}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{code\PYZus{}awesome} \PY{o}{=} \PY{l+s}{\PYZdq{}\PYZdq{}\PYZdq{}}
\PY{l+s}{module Awesome}
\PY{l+s}{include(}\PY{l+s}{\PYZdq{}}\PY{l+s}{great.jl}\PY{l+s}{\PYZdq{}}\PY{l+s}{)}
\PY{l+s}{include(}\PY{l+s}{\PYZdq{}}\PY{l+s}{amazing/Fantastic.jl}\PY{l+s}{\PYZdq{}}\PY{l+s}{)}
\PY{l+s}{end}
\PY{l+s}{\PYZdq{}\PYZdq{}\PYZdq{}}

\PY{n}{code\PYZus{}great} \PY{o}{=} \PY{l+s}{\PYZdq{}\PYZdq{}\PYZdq{}}
\PY{l+s}{great() = }\PY{l+s}{\PYZdq{}}\PY{l+s}{This is great!}\PY{l+s}{\PYZdq{}}
\PY{l+s}{\PYZdq{}\PYZdq{}\PYZdq{}}

\PY{n}{code\PYZus{}fantastic} \PY{o}{=} \PY{l+s}{\PYZdq{}\PYZdq{}\PYZdq{}}
\PY{l+s}{module Fantastic}
\PY{l+s}{fantastic = true}
\PY{l+s}{end}
\PY{l+s}{\PYZdq{}\PYZdq{}\PYZdq{}}

\PY{n}{open}\PY{p}{(}\PY{n}{f}\PY{o}{\PYZhy{}\PYZgt{}}\PY{n}{write}\PY{p}{(}\PY{n}{f}\PY{p}{,} \PY{n}{code\PYZus{}awesome}\PY{p}{)}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{Awesome.jl}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{w}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{n}{open}\PY{p}{(}\PY{n}{f}\PY{o}{\PYZhy{}\PYZgt{}}\PY{n}{write}\PY{p}{(}\PY{n}{f}\PY{p}{,} \PY{n}{code\PYZus{}great}\PY{p}{)}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{great.jl}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{w}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{n}{mkdir}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{amazing}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{n}{open}\PY{p}{(}\PY{n}{f}\PY{o}{\PYZhy{}\PYZgt{}}\PY{n}{write}\PY{p}{(}\PY{n}{f}\PY{p}{,} \PY{n}{code\PYZus{}fantastic}\PY{p}{)}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{amazing/Fantastic.jl}\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{w}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{288}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
38
\end{Verbatim}
\end{tcolorbox}
        
    If we try to execute \texttt{import\ Awesome} now, it won't work since
Julia does not search in the current directory by default. Let's change
this:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{289}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{pushfirst!}\PY{p}{(}\PY{n+nb}{LOAD\PYZus{}PATH}\PY{p}{,} \PY{l+s}{\PYZdq{}}\PY{l+s}{.}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{289}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
5-element Vector\{String\}:
 "."
 "@"
 "@v\#.\#"
 "@stdlib"
 "/Users/vvv/Julia"
\end{Verbatim}
\end{tcolorbox}
        
    Now when we import the \texttt{Awesome} module, Julia will look for a
file named \texttt{Awesome.jl} in the current directory, or for
\texttt{Awesome/src/Awesome.jl}, or for
\texttt{Awesome.jl/src/Awesome.jl}. If it does not find any of these, it
will look in the other places listed in the \texttt{LOAD\_PATH} array
(we will discuss this in more details in the ``Package Management''
section).

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{290}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{import} \PY{n}{Awesome}
\PY{n}{println}\PY{p}{(}\PY{n}{Awesome}\PY{o}{.}\PY{n}{great}\PY{p}{(}\PY{p}{)}\PY{p}{)}
\PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Is fantastic? }\PY{l+s}{\PYZdq{}}\PY{p}{,} \PY{n}{Awesome}\PY{o}{.}\PY{n}{Fantastic}\PY{o}{.}\PY{n}{fantastic}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
┌ Info: Precompiling Awesome [top-level]
└ @ Base loading.jl:1342
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
This is great!
Is fantastic? true
    \end{Verbatim}

    Let's restore the original \texttt{LOAD\_PATH}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{291}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{popfirst!}\PY{p}{(}\PY{n+nb}{LOAD\PYZus{}PATH}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{291}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
"."
\end{Verbatim}
\end{tcolorbox}
        
    In short:

\begin{longtable}[]{@{}ll@{}}
\toprule
Julia & Python \\
\midrule
\endhead
\texttt{import\ Foo} & \texttt{import\ foo} \\
\texttt{import\ Foo.Bar} & \texttt{from\ foo\ import\ bar} \\
\texttt{import\ Foo.Bar:\ a,\ b} &
\texttt{from\ foo.bar\ import\ a,\ b} \\
\texttt{import\ Foo.Bar.a,\ Foo.Bar.b} &
\texttt{from\ foo.bar\ import\ a,\ b} \\
\texttt{import\ .Foo} & \texttt{import\ .foo} \\
\texttt{import\ ..Foo.Bar} & \texttt{from\ ..foo\ import\ bar} \\
\texttt{import\ ...Foo.Bar} & \texttt{from\ ...foo\ import\ bar} \\
\texttt{import\ .Foo:\ a,\ b} & \texttt{from\ .foo\ import\ a,\ b} \\
& \\
\texttt{using\ Foo} & \texttt{from\ foo\ import\ *;\ import\ foo} \\
\texttt{using\ Foo.Bar} &
\texttt{from\ foo.bar\ import\ *;\ from\ foo\ import\ bar} \\
\texttt{using\ Foo.Bar:\ a,\ b} &
\texttt{from\ foo.bar\ import\ a,\ b} \\
\bottomrule
\end{longtable}

\begin{longtable}[]{@{}ll@{}}
\toprule
Extending function \texttt{Foo.f()} & Result \\
\midrule
\endhead
\texttt{import\ Foo.f\ \ \#\ or\ Foo:\ f} \texttt{f(x::Int64)\ =\ ...} &
OK \\
\texttt{import\ Foo}\texttt{Foo.f(x::Int64)\ =\ ...} & OK \\
\texttt{using\ Foo}\texttt{Foo.f(x::Int64)\ =\ ...} & OK \\
\texttt{import\ Foo.f\ \#\ or\ Foo:\ f}\texttt{Foo.f(x::Int64)\ =\ ...}
& \texttt{ERROR:\ Foo\ not\ defined} \\
\texttt{using\ Foo}\texttt{f(x::Int64)\ =\ ...} &
\texttt{ERROR:\ Foo.f\ must\ be\ explicitly\ imported} \\
\texttt{using\ Foo:\ f}\texttt{f(x::Int64)\ =\ ...} &
\texttt{ERROR:\ Foo.f\ must\ be\ explicitly\ imported} \\
\bottomrule
\end{longtable}

    \hypertarget{scopes}{%
\section{Scopes}\label{scopes}}

Julia has two types of scopes: global and local.

Every module has its own global scope, independent from all other global
scopes. There is no overarching global scope.

Modules, macros and types (including structs) can only be defined in a
global scope.

Most code blocks, including \texttt{function}, \texttt{struct},
\texttt{for}, \texttt{while}, etc., have their own local scope. For
example:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{292}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{for} \PY{n}{q} \PY{k}{in} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{3}
    \PY{n}{println}\PY{p}{(}\PY{n}{q}\PY{p}{)}
\PY{k}{end}

\PY{k}{try}
    \PY{n}{println}\PY{p}{(}\PY{n}{q}\PY{p}{)} \PY{c}{\PYZsh{} q is not available here}
\PY{k}{catch} \PY{n}{ex}
    \PY{n}{ex}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
1
2
3
    \end{Verbatim}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{292}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
UndefVarError(:q)
\end{Verbatim}
\end{tcolorbox}
        
    A local scope inherits from its parent scope:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{293}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{z} \PY{o}{=} \PY{l+m+mi}{5}
\PY{k}{for} \PY{n}{i} \PY{k}{in} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{3}
    \PY{n}{w} \PY{o}{=} \PY{l+m+mi}{10}
    \PY{n}{println}\PY{p}{(}\PY{n}{i} \PY{o}{*} \PY{n}{w} \PY{o}{*} \PY{n}{z}\PY{p}{)} \PY{c}{\PYZsh{} i and w are local, z is from the parent scope}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
50
100
150
    \end{Verbatim}

    An inner scope can assign to a variable in the parent scope, if the
parent scope is not global:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{294}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{for} \PY{n}{i} \PY{k}{in} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{3}
    \PY{n}{s} \PY{o}{=} \PY{l+m+mi}{0}
    \PY{k}{for} \PY{n}{j} \PY{k}{in} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{5}
        \PY{n}{s} \PY{o}{=} \PY{n}{j} \PY{c}{\PYZsh{} variable s is from the parent scope}
    \PY{k}{end}
    \PY{n}{println}\PY{p}{(}\PY{n}{s}\PY{p}{)}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
5
5
5
    \end{Verbatim}

    You can force a variable to be local by using the \texttt{local}
keyword:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{295}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{for} \PY{n}{i} \PY{k}{in} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{3}
    \PY{n}{s} \PY{o}{=} \PY{l+m+mi}{0}
    \PY{k}{for} \PY{n}{j} \PY{k}{in} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{5}
        \PY{k}{local} \PY{n}{s} \PY{o}{=} \PY{n}{j} \PY{c}{\PYZsh{} variable s is local now}
    \PY{k}{end}
    \PY{n}{println}\PY{p}{(}\PY{n}{s}\PY{p}{)}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
0
0
0
    \end{Verbatim}

    To assign to a global variable, you must declare the variable as
\texttt{global} in the local scope:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{296}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{for} \PY{n}{i} \PY{k}{in} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{3}
    \PY{k}{global} \PY{n}{p}
    \PY{n}{p} \PY{o}{=} \PY{n}{i}
\PY{k}{end}
\PY{n}{p}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{296}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
3
\end{Verbatim}
\end{tcolorbox}
        
    There is one exception to this rule: when executing code directly in the
REPL (since Julia 1.5) or in IJulia, you do not need to declare a
variable as \texttt{global} if the global variable already exists:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{297}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{s} \PY{o}{=} \PY{l+m+mi}{0}
\PY{k}{for} \PY{n}{i} \PY{k}{in} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{3}
    \PY{n}{s} \PY{o}{=} \PY{n}{i} \PY{c}{\PYZsh{} implicitly global s: only in REPL Julia 1.5+ or IJulia}
\PY{k}{end}
\PY{n}{s}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{297}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
3
\end{Verbatim}
\end{tcolorbox}
        
    In functions, assigning to a variable which is not explicitly declared
as global always makes it local (even in the REPL and IJulia):

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{298}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{s}\PY{p}{,} \PY{n}{t} \PY{o}{=} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2} \PY{c}{\PYZsh{} globals}

\PY{k}{function} \PY{n}{foo}\PY{p}{(}\PY{p}{)}
   \PY{n}{s} \PY{o}{=} \PY{l+m+mi}{10} \PY{o}{*} \PY{n}{t} \PY{c}{\PYZsh{} s is local, t is global}
\PY{k}{end}

\PY{n}{println}\PY{p}{(}\PY{n}{foo}\PY{p}{(}\PY{p}{)}\PY{p}{)}
\PY{n}{println}\PY{p}{(}\PY{n}{s}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
20
1
    \end{Verbatim}

    Just like in Python, functions can capture variables from the enclosing
scope (not from the scope the function is called from):

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{299}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{t} \PY{o}{=} \PY{l+m+mi}{1}

\PY{n}{foo}\PY{p}{(}\PY{p}{)} \PY{o}{=} \PY{n}{t} \PY{c}{\PYZsh{} foo() captures t from the global scope}

\PY{k}{function} \PY{n}{bar}\PY{p}{(}\PY{p}{)}
    \PY{n}{t} \PY{o}{=} \PY{l+m+mi}{5} \PY{c}{\PYZsh{} this is a new local variable}
    \PY{n}{println}\PY{p}{(}\PY{n}{foo}\PY{p}{(}\PY{p}{)}\PY{p}{)} \PY{c}{\PYZsh{} foo() still uses t from the global scope}
\PY{k}{end}

\PY{n}{bar}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
1
    \end{Verbatim}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{300}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{function} \PY{n}{quz}\PY{p}{(}\PY{p}{)}
    \PY{k}{global} \PY{n}{t}
    \PY{n}{t} \PY{o}{=} \PY{l+m+mi}{5} \PY{c}{\PYZsh{} we change the global t}
    \PY{n}{println}\PY{p}{(}\PY{n}{foo}\PY{p}{(}\PY{p}{)}\PY{p}{)} \PY{c}{\PYZsh{} and this affects foo()}
\PY{k}{end}

\PY{n}{quz}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
5
    \end{Verbatim}

    Closures work much like in Python:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{301}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{function} \PY{n}{create\PYZus{}multiplier}\PY{p}{(}\PY{n}{n}\PY{p}{)}
    \PY{k}{function} \PY{n}{mul}\PY{p}{(}\PY{n}{x}\PY{p}{)}
        \PY{n}{x} \PY{o}{*} \PY{n}{n} \PY{c}{\PYZsh{} variable n is captured from the parent scope}
    \PY{k}{end}
\PY{k}{end}

\PY{n}{mul2} \PY{o}{=} \PY{n}{create\PYZus{}multiplier}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{)}
\PY{n}{mul2}\PY{p}{(}\PY{l+m+mi}{5}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{301}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
10
\end{Verbatim}
\end{tcolorbox}
        
    An inner function can modify variables from its parent scope:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{302}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{function} \PY{n}{create\PYZus{}counter}\PY{p}{(}\PY{p}{)}
    \PY{n}{c} \PY{o}{=} \PY{l+m+mi}{0}
    \PY{n}{inc}\PY{p}{(}\PY{p}{)} \PY{o}{=} \PY{n}{c} \PY{o}{+=} \PY{l+m+mi}{1} \PY{c}{\PYZsh{} this inner function modifies the c from the outer function}
\PY{k}{end}

\PY{n}{cnt} \PY{o}{=} \PY{n}{create\PYZus{}counter}\PY{p}{(}\PY{p}{)}
\PY{n}{println}\PY{p}{(}\PY{n}{cnt}\PY{p}{(}\PY{p}{)}\PY{p}{)}
\PY{n}{println}\PY{p}{(}\PY{n}{cnt}\PY{p}{(}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
1
2
    \end{Verbatim}

    Consider the following code, and see if you can figure out why it prints
the same result multiple times:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{303}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{funcs} \PY{o}{=} \PY{p}{[}\PY{p}{]}
\PY{n}{i} \PY{o}{=} \PY{l+m+mi}{1}
\PY{k}{while} \PY{n}{i} \PY{o}{≤} \PY{l+m+mi}{5}
    \PY{n}{push!}\PY{p}{(}\PY{n}{funcs}\PY{p}{,} \PY{p}{(}\PY{p}{)}\PY{o}{\PYZhy{}\PYZgt{}}\PY{n}{i}\PY{o}{\PYZca{}}\PY{l+m+mi}{2}\PY{p}{)}
    \PY{k}{global} \PY{n}{i} \PY{o}{+=} \PY{l+m+mi}{1}
\PY{k}{end}
\PY{k}{for} \PY{n}{fn} \PY{k}{in} \PY{n}{funcs}
    \PY{n}{println}\PY{p}{(}\PY{n}{fn}\PY{p}{(}\PY{p}{)}\PY{p}{)}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
36
36
36
36
36
    \end{Verbatim}

    The answer is that there is a single variable \texttt{i}, which is
captured by all 5 closures. By the time these closures are executed, the
value of \texttt{i} is 6, so the square is 36, for every closure.

    If we use a \texttt{for} loop, we don't have this problem, since a new
local variable is created at every iteration:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{304}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{funcs} \PY{o}{=} \PY{p}{[}\PY{p}{]}
\PY{k}{for} \PY{n}{i} \PY{k}{in} \PY{l+m+mi}{1}\PY{o}{:}\PY{l+m+mi}{5}
    \PY{n}{push!}\PY{p}{(}\PY{n}{funcs}\PY{p}{,} \PY{p}{(}\PY{p}{)}\PY{o}{\PYZhy{}\PYZgt{}}\PY{n}{i}\PY{o}{\PYZca{}}\PY{l+m+mi}{2}\PY{p}{)}
\PY{k}{end}
\PY{k}{for} \PY{n}{fn} \PY{k}{in} \PY{n}{funcs}
    \PY{n}{println}\PY{p}{(}\PY{n}{fn}\PY{p}{(}\PY{p}{)}\PY{p}{)}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
1
4
9
16
25
    \end{Verbatim}

    Any local variable created within a \texttt{for} loop, a \texttt{while}
loop or a comprehension also get a new copy at each iteration. So we
could code the above example like this:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{305}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{funcs} \PY{o}{=} \PY{p}{[}\PY{p}{]}
\PY{n}{i} \PY{o}{=} \PY{l+m+mi}{1}
\PY{k}{while} \PY{n}{i} \PY{o}{≤} \PY{l+m+mi}{5}  \PY{c}{\PYZsh{} since we are in a while loop...}
    \PY{k}{global} \PY{n}{i}
    \PY{k}{local} \PY{n}{j} \PY{o}{=} \PY{n}{i} \PY{c}{\PYZsh{} ...and j is created here, it\PYZsq{}s a new `j` at each iteration}
    \PY{n}{push!}\PY{p}{(}\PY{n}{funcs}\PY{p}{,} \PY{p}{(}\PY{p}{)}\PY{o}{\PYZhy{}\PYZgt{}}\PY{n}{j}\PY{o}{\PYZca{}}\PY{l+m+mi}{2}\PY{p}{)}
    \PY{n}{i} \PY{o}{+=} \PY{l+m+mi}{1}
\PY{k}{end}
\PY{k}{for} \PY{n}{fn} \PY{k}{in} \PY{n}{funcs}
    \PY{n}{println}\PY{p}{(}\PY{n}{fn}\PY{p}{(}\PY{p}{)}\PY{p}{)}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
1
4
9
16
25
    \end{Verbatim}

    Another way to get the same result is to use a \texttt{let} block, which
also creates a new local variable every time it is executed:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{306}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{funcs} \PY{o}{=} \PY{p}{[}\PY{p}{]}
\PY{n}{i} \PY{o}{=} \PY{l+m+mi}{0}
\PY{k}{while} \PY{n}{i} \PY{o}{\PYZlt{}} \PY{l+m+mi}{5}
    \PY{k}{let} \PY{n}{i}\PY{o}{=}\PY{n}{i}
        \PY{n}{push!}\PY{p}{(}\PY{n}{funcs}\PY{p}{,} \PY{p}{(}\PY{p}{)}\PY{o}{\PYZhy{}\PYZgt{}}\PY{n}{i}\PY{o}{\PYZca{}}\PY{l+m+mi}{2}\PY{p}{)}
    \PY{k}{end}
    \PY{k}{global} \PY{n}{i} \PY{o}{+=} \PY{l+m+mi}{1}
\PY{k}{end}
\PY{k}{for} \PY{n}{fn} \PY{k}{in} \PY{n}{funcs}
    \PY{n}{println}\PY{p}{(}\PY{n}{fn}\PY{p}{(}\PY{p}{)}\PY{p}{)}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
0
1
4
9
16
    \end{Verbatim}

    This \texttt{let\ i=i} block defines a new local variable \texttt{i} at
every iteration, and initializes it with the value of \texttt{i} from
the parent scope. Therefore each closure captures a different local
variable \texttt{i}.

    Variables in a \texttt{let} block are initialized from left to right, so
they can access variables on their left:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{307}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{a} \PY{o}{=} \PY{l+m+mi}{1}
\PY{k}{let} \PY{n}{a}\PY{o}{=}\PY{n}{a}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{b}\PY{o}{=}\PY{n}{a}
    \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{a=}\PY{l+s+si}{\PYZdl{}a}\PY{l+s}{, b=}\PY{l+s+si}{\PYZdl{}b}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
a=2, b=2
    \end{Verbatim}

    In this example, the local variable \texttt{a} is initialized with the
value of \texttt{a\ +\ 1}, where \texttt{a} comes from the parent scope
(i.e., it's the global \texttt{a} in this case). However, \texttt{b} is
initialized with the value of the local \texttt{a}, since it now hides
the variable \texttt{a} from the parent scope.

    Default values in function arguments also have this left-to-right
scoping logic:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{308}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{a} \PY{o}{=} \PY{l+m+mi}{1}
\PY{n}{foobar}\PY{p}{(}\PY{n}{a}\PY{o}{=}\PY{n}{a}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{b}\PY{o}{=}\PY{n}{a}\PY{p}{)} \PY{o}{=} \PY{n}{println}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{a=}\PY{l+s+si}{\PYZdl{}a}\PY{l+s}{, b=}\PY{l+s+si}{\PYZdl{}b}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\PY{n}{foobar}\PY{p}{(}\PY{p}{)}
\PY{n}{foobar}\PY{p}{(}\PY{l+m+mi}{5}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
a=2, b=2
a=5, b=5
    \end{Verbatim}

    In this example, the first argument's default value is \texttt{a\ +\ 1},
where \texttt{a} comes from the parent scope (i.e., the global
\texttt{a} in this case). However, the second argument's default value
is \texttt{a}, where \texttt{a} in this case is the value of the first
argument (not the parent scope's \texttt{a}).

    Note that \texttt{if} blocks and \texttt{begin} blocks do not have their
own local scope, they just use the parent scope:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{309}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{a} \PY{o}{=} \PY{l+m+mi}{1}
\PY{k}{if} \PY{n+nb}{true}
    \PY{n}{a} \PY{o}{=} \PY{l+m+mi}{2} \PY{c}{\PYZsh{} same `a` as above}
\PY{k}{end}
\PY{n}{a}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{309}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
2
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{310}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{a} \PY{o}{=} \PY{l+m+mi}{1}
\PY{k}{begin}
    \PY{n}{a} \PY{o}{=} \PY{l+m+mi}{2}  \PY{c}{\PYZsh{} same `a` as above}
\PY{k}{end}
\PY{n}{a}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{310}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
2
\end{Verbatim}
\end{tcolorbox}
        
    \hypertarget{package-management}{%
\section{Package Management}\label{package-management}}

    Information about package management (\texttt{Pkg}) commands can be
obtained by typing \texttt{{]}help}.

    \begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.45}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.55}}@{}}
\toprule
Julia (in interactive mode) & Python (in a terminal) \\
\midrule
\endhead
\texttt{{]}status} or\texttt{{]}st} &
\texttt{pip\ freeze}or\texttt{conda\ list} \\
\texttt{{]}add\ Foo} &
\texttt{pip\ install\ foo}or\texttt{conda\ install\ foo} \\
\texttt{{]}add\ Foo@1.2} &
\texttt{pip\ install\ foo==1.2}or\texttt{conda\ install\ foo=1.2} \\
\texttt{{]}update\ Foo} &
\texttt{pip\ install\ -\/-upgrade\ foo}or\texttt{conda\ update\ foo} \\
\texttt{{]}pin\ Foo} & \texttt{foo==\textless{}version\textgreater{}} in
\texttt{requirements.txt}
or\texttt{foo=\textless{}version\textgreater{}} in
\texttt{environment.yml} \\
\texttt{{]}free\ Foo} & \texttt{foo} in
\texttt{requirements.txt}or\texttt{foo} in \texttt{environment.yml} \\
\texttt{{]}test\ Foo} & \texttt{python\ -m\ unittest\ foo} \\
\texttt{{]}rm\ Foo} &
\texttt{pip\ uninstall\ foo}or\texttt{conda\ remove\ foo} \\
\texttt{{]}help} & \texttt{pip\ -\/-help} \\
\bottomrule
\end{longtable}

    This workflow is fairly simple, but it means that all of your programs
will be using the same version of each package. This is analog to
installing packages using \texttt{pip\ install} without using virtual
environments.


    % Add a bibliography block to the postdoc
    
    
    
\end{document}
