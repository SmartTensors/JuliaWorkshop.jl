\documentclass[11pt]{article}

    \usepackage[breakable]{tcolorbox}
    \usepackage{parskip} % Stop auto-indenting (to mimic markdown behaviour)
    
    \usepackage{iftex}
    \ifPDFTeX
    	\usepackage[T1]{fontenc}
    	\usepackage{mathpazo}
    \else
    	\usepackage{fontspec}
    \fi

    % Basic figure setup, for now with no caption control since it's done
    % automatically by Pandoc (which extracts ![](path) syntax from Markdown).
    \usepackage{graphicx}
    % Maintain compatibility with old templates. Remove in nbconvert 6.0
    \let\Oldincludegraphics\includegraphics
    % Ensure that by default, figures have no caption (until we provide a
    % proper Figure object with a Caption API and a way to capture that
    % in the conversion process - todo).
    \usepackage{caption}
    \DeclareCaptionFormat{nocaption}{}
    \captionsetup{format=nocaption,aboveskip=0pt,belowskip=0pt}

    \usepackage{float}
    \floatplacement{figure}{H} % forces figures to be placed at the correct location
    \usepackage{xcolor} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage{textcomp} % defines textquotesingle
    % Hack from http://tex.stackexchange.com/a/47451/13684:
    \AtBeginDocument{%
        \def\PYZsq{\textquotesingle}% Upright quotes in Pygmentized code
    }
    \usepackage{upquote} % Upright quotes for verbatim code
    \usepackage{eurosym} % defines \euro
    \usepackage[mathletters]{ucs} % Extended unicode (utf-8) support
    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics 
                         % to support a larger range
    \makeatletter % fix for old versions of grffile with XeLaTeX
    \@ifpackagelater{grffile}{2019/11/01}
    {
      % Do nothing on new versions
    }
    {
      \def\Gread@@xetex#1{%
        \IfFileExists{"\Gin@base".bb}%
        {\Gread@eps{\Gin@base.bb}}%
        {\Gread@@xetex@aux#1}%
      }
    }
    \makeatother
    \usepackage[Export]{adjustbox} % Used to constrain images to a maximum size
    \adjustboxset{max size={0.9\linewidth}{0.9\paperheight}}

    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    % The default LaTeX title has an obnoxious amount of whitespace. By default,
    % titling removes some of it. It also provides customization options.
    \usepackage{titling}
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    \usepackage[inline]{enumitem} % IRkernel/repr support (it uses the enumerate* environment)
    \usepackage[normalem]{ulem} % ulem is needed to support strikethroughs (\sout)
                                % normalem makes italics be italics, not underlines
    \usepackage{mathrsfs}
    

    
    % Colors for the hyperref package
    \definecolor{urlcolor}{rgb}{0,.145,.698}
    \definecolor{linkcolor}{rgb}{.71,0.21,0.01}
    \definecolor{citecolor}{rgb}{.12,.54,.11}

    % ANSI colors
    \definecolor{ansi-black}{HTML}{3E424D}
    \definecolor{ansi-black-intense}{HTML}{282C36}
    \definecolor{ansi-red}{HTML}{E75C58}
    \definecolor{ansi-red-intense}{HTML}{B22B31}
    \definecolor{ansi-green}{HTML}{00A250}
    \definecolor{ansi-green-intense}{HTML}{007427}
    \definecolor{ansi-yellow}{HTML}{DDB62B}
    \definecolor{ansi-yellow-intense}{HTML}{B27D12}
    \definecolor{ansi-blue}{HTML}{208FFB}
    \definecolor{ansi-blue-intense}{HTML}{0065CA}
    \definecolor{ansi-magenta}{HTML}{D160C4}
    \definecolor{ansi-magenta-intense}{HTML}{A03196}
    \definecolor{ansi-cyan}{HTML}{60C6C8}
    \definecolor{ansi-cyan-intense}{HTML}{258F8F}
    \definecolor{ansi-white}{HTML}{C5C1B4}
    \definecolor{ansi-white-intense}{HTML}{A1A6B2}
    \definecolor{ansi-default-inverse-fg}{HTML}{FFFFFF}
    \definecolor{ansi-default-inverse-bg}{HTML}{000000}

    % common color for the border for error outputs.
    \definecolor{outerrorbackground}{HTML}{FFDFDF}

    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \providecommand{\tightlist}{%
      \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}
    
    % Additional commands for more recent versions of Pandoc
    \newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
    \newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
    \newcommand{\ImportTok}[1]{{#1}}
    \newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
    \newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
    \newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
    \newcommand{\BuiltInTok}[1]{{#1}}
    \newcommand{\ExtensionTok}[1]{{#1}}
    \newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
    \newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
    \newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    
    
    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatibility definitions
    \def\gt{>}
    \def\lt{<}
    \let\Oldtex\TeX
    \let\Oldlatex\LaTeX
    \renewcommand{\TeX}{\textrm{\Oldtex}}
    \renewcommand{\LaTeX}{\textrm{\Oldlatex}}
    % Document parameters
    % Document title
    \title{GPU\_acceleration}
    
    
    
    
    
% Pygments definitions
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\@namedef{PY@tok@w}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\@namedef{PY@tok@c}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\@namedef{PY@tok@cp}{\def\PY@tc##1{\textcolor[rgb]{0.74,0.48,0.00}{##1}}}
\@namedef{PY@tok@k}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kp}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kt}{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\@namedef{PY@tok@o}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@ow}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\@namedef{PY@tok@nb}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@nf}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@nc}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@nn}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@ne}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.82,0.25,0.23}{##1}}}
\@namedef{PY@tok@nv}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@no}{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\@namedef{PY@tok@nl}{\def\PY@tc##1{\textcolor[rgb]{0.63,0.63,0.00}{##1}}}
\@namedef{PY@tok@ni}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}
\@namedef{PY@tok@na}{\def\PY@tc##1{\textcolor[rgb]{0.49,0.56,0.16}{##1}}}
\@namedef{PY@tok@nt}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@nd}{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\@namedef{PY@tok@s}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sd}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@si}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\@namedef{PY@tok@se}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.13}{##1}}}
\@namedef{PY@tok@sr}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\@namedef{PY@tok@ss}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@sx}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@m}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@gh}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\@namedef{PY@tok@gu}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\@namedef{PY@tok@gd}{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\@namedef{PY@tok@gi}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\@namedef{PY@tok@gr}{\def\PY@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\@namedef{PY@tok@ge}{\let\PY@it=\textit}
\@namedef{PY@tok@gs}{\let\PY@bf=\textbf}
\@namedef{PY@tok@gp}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\@namedef{PY@tok@go}{\def\PY@tc##1{\textcolor[rgb]{0.53,0.53,0.53}{##1}}}
\@namedef{PY@tok@gt}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\@namedef{PY@tok@err}{\def\PY@bc##1{{\setlength{\fboxsep}{\string -\fboxrule}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}}
\@namedef{PY@tok@kc}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kd}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kn}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kr}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@bp}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@fm}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@vc}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vg}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vi}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vm}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@sa}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sb}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sc}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@dl}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@s2}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sh}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@s1}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@mb}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mf}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mh}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mi}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@il}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mo}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@ch}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\@namedef{PY@tok@cm}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\@namedef{PY@tok@cpf}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\@namedef{PY@tok@c1}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\@namedef{PY@tok@cs}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % For linebreaks inside Verbatim environment from package fancyvrb. 
    \makeatletter
        \newbox\Wrappedcontinuationbox 
        \newbox\Wrappedvisiblespacebox 
        \newcommand*\Wrappedvisiblespace {\textcolor{red}{\textvisiblespace}} 
        \newcommand*\Wrappedcontinuationsymbol {\textcolor{red}{\llap{\tiny$\m@th\hookrightarrow$}}} 
        \newcommand*\Wrappedcontinuationindent {3ex } 
        \newcommand*\Wrappedafterbreak {\kern\Wrappedcontinuationindent\copy\Wrappedcontinuationbox} 
        % Take advantage of the already applied Pygments mark-up to insert 
        % potential linebreaks for TeX processing. 
        %        {, <, #, %, $, ' and ": go to next line. 
        %        _, }, ^, &, >, - and ~: stay at end of broken line. 
        % Use of \textquotesingle for straight quote. 
        \newcommand*\Wrappedbreaksatspecials {% 
            \def\PYGZus{\discretionary{\char`\_}{\Wrappedafterbreak}{\char`\_}}% 
            \def\PYGZob{\discretionary{}{\Wrappedafterbreak\char`\{}{\char`\{}}% 
            \def\PYGZcb{\discretionary{\char`\}}{\Wrappedafterbreak}{\char`\}}}% 
            \def\PYGZca{\discretionary{\char`\^}{\Wrappedafterbreak}{\char`\^}}% 
            \def\PYGZam{\discretionary{\char`\&}{\Wrappedafterbreak}{\char`\&}}% 
            \def\PYGZlt{\discretionary{}{\Wrappedafterbreak\char`\<}{\char`\<}}% 
            \def\PYGZgt{\discretionary{\char`\>}{\Wrappedafterbreak}{\char`\>}}% 
            \def\PYGZsh{\discretionary{}{\Wrappedafterbreak\char`\#}{\char`\#}}% 
            \def\PYGZpc{\discretionary{}{\Wrappedafterbreak\char`\%}{\char`\%}}% 
            \def\PYGZdl{\discretionary{}{\Wrappedafterbreak\char`\$}{\char`\$}}% 
            \def\PYGZhy{\discretionary{\char`\-}{\Wrappedafterbreak}{\char`\-}}% 
            \def\PYGZsq{\discretionary{}{\Wrappedafterbreak\textquotesingle}{\textquotesingle}}% 
            \def\PYGZdq{\discretionary{}{\Wrappedafterbreak\char`\"}{\char`\"}}% 
            \def\PYGZti{\discretionary{\char`\~}{\Wrappedafterbreak}{\char`\~}}% 
        } 
        % Some characters . , ; ? ! / are not pygmentized. 
        % This macro makes them "active" and they will insert potential linebreaks 
        \newcommand*\Wrappedbreaksatpunct {% 
            \lccode`\~`\.\lowercase{\def~}{\discretionary{\hbox{\char`\.}}{\Wrappedafterbreak}{\hbox{\char`\.}}}% 
            \lccode`\~`\,\lowercase{\def~}{\discretionary{\hbox{\char`\,}}{\Wrappedafterbreak}{\hbox{\char`\,}}}% 
            \lccode`\~`\;\lowercase{\def~}{\discretionary{\hbox{\char`\;}}{\Wrappedafterbreak}{\hbox{\char`\;}}}% 
            \lccode`\~`\:\lowercase{\def~}{\discretionary{\hbox{\char`\:}}{\Wrappedafterbreak}{\hbox{\char`\:}}}% 
            \lccode`\~`\?\lowercase{\def~}{\discretionary{\hbox{\char`\?}}{\Wrappedafterbreak}{\hbox{\char`\?}}}% 
            \lccode`\~`\!\lowercase{\def~}{\discretionary{\hbox{\char`\!}}{\Wrappedafterbreak}{\hbox{\char`\!}}}% 
            \lccode`\~`\/\lowercase{\def~}{\discretionary{\hbox{\char`\/}}{\Wrappedafterbreak}{\hbox{\char`\/}}}% 
            \catcode`\.\active
            \catcode`\,\active 
            \catcode`\;\active
            \catcode`\:\active
            \catcode`\?\active
            \catcode`\!\active
            \catcode`\/\active 
            \lccode`\~`\~ 	
        }
    \makeatother

    \let\OriginalVerbatim=\Verbatim
    \makeatletter
    \renewcommand{\Verbatim}[1][1]{%
        %\parskip\z@skip
        \sbox\Wrappedcontinuationbox {\Wrappedcontinuationsymbol}%
        \sbox\Wrappedvisiblespacebox {\FV@SetupFont\Wrappedvisiblespace}%
        \def\FancyVerbFormatLine ##1{\hsize\linewidth
            \vtop{\raggedright\hyphenpenalty\z@\exhyphenpenalty\z@
                \doublehyphendemerits\z@\finalhyphendemerits\z@
                \strut ##1\strut}%
        }%
        % If the linebreak is at a space, the latter will be displayed as visible
        % space at end of first line, and a continuation symbol starts next line.
        % Stretch/shrink are however usually zero for typewriter font.
        \def\FV@Space {%
            \nobreak\hskip\z@ plus\fontdimen3\font minus\fontdimen4\font
            \discretionary{\copy\Wrappedvisiblespacebox}{\Wrappedafterbreak}
            {\kern\fontdimen2\font}%
        }%
        
        % Allow breaks at special characters using \PYG... macros.
        \Wrappedbreaksatspecials
        % Breaks at punctuation characters . , ; ? ! and / need catcode=\active 	
        \OriginalVerbatim[#1,codes*=\Wrappedbreaksatpunct]%
    }
    \makeatother

    % Exact colors from NB
    \definecolor{incolor}{HTML}{303F9F}
    \definecolor{outcolor}{HTML}{D84315}
    \definecolor{cellborder}{HTML}{CFCFCF}
    \definecolor{cellbackground}{HTML}{F7F7F7}
    
    % prompt
    \makeatletter
    \newcommand{\boxspacing}{\kern\kvtcb@left@rule\kern\kvtcb@boxsep}
    \makeatother
    \newcommand{\prompt}[4]{
        {\ttfamily\llap{{\color{#2}[#3]:\hspace{3pt}#4}}\vspace{-\baselineskip}}
    }
    

    
    % Prevent overflowing lines due to hard-to-break entities
    \sloppy 
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=urlcolor,
      linkcolor=linkcolor,
      citecolor=citecolor,
      }
    % Slightly bigger margins than the latex defaults
    
    \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
    
    

\begin{document}
    
    \maketitle
    
    

    
    \hypertarget{gpu}{%
\section{GPU}\label{gpu}}

Julia provides excellent GPU support.

GPUs are devices which can run thousands of threads simultanously in
parallel.

GPU threads are slower and memory limited than the CPU threads.

However, there are so many of GPU threads.

Many tasks can be executed much faster on a GPU than on a CPU, if these
tasks can be parallelized.

\hypertarget{check-installed-gpu-device}{%
\subsection{Check installed GPU
device:}\label{check-installed-gpu-device}}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{p}{;}\PY{n}{nvidia}\PY{o}{\PYZhy{}}\PY{n}{smi}
\end{Verbatim}
\end{tcolorbox}

    

    \hypertarget{banchmark-cpu-performace}{%
\subsection{Banchmark CPU performace}\label{banchmark-cpu-performace}}

Let us create a large matrix and time how long it takes to square it on
the CPU:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{import} \PY{n}{BenchmarkTools}

\PY{n}{M} \PY{o}{=} \PY{n}{rand}\PY{p}{(}\PY{l+m+mi}{2}\PY{o}{\PYZca{}}\PY{l+m+mi}{11}\PY{p}{,} \PY{l+m+mi}{2}\PY{o}{\PYZca{}}\PY{l+m+mi}{11}\PY{p}{)}

\PY{k}{function} \PY{n}{benchmark\PYZus{}matmul\PYZus{}cpu}\PY{p}{(}\PY{n}{M}\PY{p}{)}
    \PY{n}{M} \PY{o}{*} \PY{n}{M}
    \PY{k}{return} \PY{n+nb}{nothing}
\PY{k}{end}

\PY{n}{benchmark\PYZus{}matmul\PYZus{}cpu}\PY{p}{(}\PY{n}{M}\PY{p}{)} \PY{c}{\PYZsh{} warm up}

\PY{n+nd}{@BenchmarkTools}\PY{o}{.}\PY{n}{btime} \PY{n}{benchmark\PYZus{}matmul\PYZus{}cpu}\PY{p}{(}\PY{o}{\PYZdl{}}\PY{n}{M}\PY{p}{)}
\PY{n+nd}{@BenchmarkTools}\PY{o}{.}\PY{n}{benchmark} \PY{n}{benchmark\PYZus{}matmul\PYZus{}cpu}\PY{p}{(}\PY{o}{\PYZdl{}}\PY{n}{M}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    For benchmarking, the math operations are in a function which returns
\texttt{nothing}.

We need a ``warm up'' line. Since Julia compiles code on the fly the
first time it is executed, the operation we want to benchmark needs to
be exectured at least once before starting the benchmark Otherwise, the
benchmark will include the compilation time.

Note that \texttt{\$M} is used instead of \texttt{M} for banchmarking.
This is a feature of the \texttt{@BenchmarkTools.btime} macro. It allows
evaluation of \texttt{M} before benchmarking takes place, to avoid the
extra delay that is incurred when benchmarking with global variables.

    \hypertarget{banchmark-gpu-performace}{%
\subsection{Banchmark GPU performace}\label{banchmark-gpu-performace}}

GPU operations using CUDA:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{import} \PY{n}{CUDA}

\PY{n}{M\PYZus{}on\PYZus{}gpu} \PY{o}{=} \PY{n}{CUDA}\PY{o}{.}\PY{n}{cu}\PY{p}{(}\PY{n}{M}\PY{p}{)} \PY{c}{\PYZsh{} Copy the data to the GPU and create a CuArray}

\PY{n}{M\PYZus{}on\PYZus{}gpu} \PY{o}{=} \PY{n}{CUDA}\PY{o}{.}\PY{n}{CURAND}\PY{o}{.}\PY{n}{rand}\PY{p}{(}\PY{n}{size}\PY{p}{(}\PY{n}{M}\PY{p}{)}\PY{p}{)} \PY{c}{\PYZsh{} or create a new random matrix directly on the GPU}

\PY{k}{function} \PY{n}{benchmark\PYZus{}matmul\PYZus{}gpu}\PY{p}{(}\PY{n}{M}\PY{p}{)}
    \PY{n}{CUDA}\PY{o}{.}\PY{n+nd}{@sync} \PY{n}{M} \PY{o}{*} \PY{n}{M}
    \PY{k}{return} \PY{n+nb}{nothing}
\PY{k}{end}

\PY{n}{benchmark\PYZus{}matmul\PYZus{}gpu}\PY{p}{(}\PY{n}{M\PYZus{}on\PYZus{}gpu}\PY{p}{)} \PY{c}{\PYZsh{} warm up}

\PY{n+nd}{@BenchmarkTools}\PY{o}{.}\PY{n}{btime} \PY{n}{benchmark\PYZus{}matmul\PYZus{}gpu}\PY{p}{(}\PY{o}{\PYZdl{}}\PY{n}{M\PYZus{}on\PYZus{}gpu}\PY{p}{)}
\PY{n+nd}{@BenchmarkTools}\PY{o}{.}\PY{n}{benchmark} \PY{n}{benchmark\PYZus{}matmul\PYZus{}gpu}\PY{p}{(}\PY{o}{\PYZdl{}}\PY{n}{M\PYZus{}on\PYZus{}gpu}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Important: * Before the GPU can work on some data, it needs to be copied
to the GPU (or generated there directly). * The \texttt{CUDA.@sync}
macro waits for the GPU operation to complete. Without it, the operation
would happen in parallel on the GPU, while execution would continue on
the CPU. So we would just be timing how long it takes to \emph{start}
the operation, not how long it takes to complete. * In general, you
don't need \texttt{CUDA.@sync}, since many operations (including
\texttt{cu()}) call it implicitly. And it is usually a good idea to let
the CPU and GPU work in parallel. Typically, the GPU will be working on
the current batch of data while the CPU works on preparing the next
batch.

    \hypertarget{gpu-memory-status}{%
\subsection{GPU memory status}\label{gpu-memory-status}}

    Let's check how much RAM we have left on the GPU:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{CUDA}\PY{o}{.}\PY{n}{memory\PYZus{}status}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Julia's Garbage Collector (GC) will free CUDA arrays like any other
object, when there's no more reference to it.

However, \texttt{CUDA.jl} uses a memory pool to make allocations faster
on the GPU, so don't be surprised if the allocated memory on the GPU
does not go down immediately.

Moreover, IJulia keeps a reference to the output of each cell, so if you
let any cell output a \texttt{CuArray} it will be staying in the memory.

To force the Garbage Collector to run, execute \texttt{GC.gc()}. To
reclaim memory from the memory pool, use \texttt{CUDA.reclaim()}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{GC}\PY{o}{.}\PY{n}{gc}\PY{p}{(}\PY{p}{)}
\PY{n}{CUDA}\PY{o}{.}\PY{n}{reclaim}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{gpu-loop-fussion}{%
\subsection{GPU loop fussion}\label{gpu-loop-fussion}}

Many other operations are implemented for \texttt{CuArray} (\texttt{+},
\texttt{-}, etc.).

Their dotted versions are implemented as well (\texttt{.+},
\texttt{exp.()}, etc).

Importantly, the Julia loop fusion also works on the GPU.

For example, if we want to compute \texttt{M\ .*\ M\ .+\ M}, without
loop fusion the GPU would first compute \texttt{M\ .*\ M} and create a
temporary array, then it would add \texttt{M} to that array, like this:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{function} \PY{n}{benchmark\PYZus{}without\PYZus{}fusion}\PY{p}{(}\PY{n}{M}\PY{p}{)}
    \PY{n}{P} \PY{o}{=} \PY{n}{M} \PY{o}{.*} \PY{n}{M}
    \PY{n}{CUDA}\PY{o}{.}\PY{n+nd}{@sync} \PY{n}{P} \PY{o}{.+} \PY{n}{M}
    \PY{k}{return}
\PY{k}{end}

\PY{n}{benchmark\PYZus{}without\PYZus{}fusion}\PY{p}{(}\PY{n}{M\PYZus{}on\PYZus{}gpu}\PY{p}{)} \PY{c}{\PYZsh{} warm up}

\PY{n+nd}{@BenchmarkTools}\PY{o}{.}\PY{n}{btime} \PY{n}{benchmark\PYZus{}without\PYZus{}fusion}\PY{p}{(}\PY{o}{\PYZdl{}}\PY{n}{M\PYZus{}on\PYZus{}gpu}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Instead, the loop fusion in Julia ensures that the array is only
traversed once, without the need for a temporary array:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{function} \PY{n}{benchmark\PYZus{}with\PYZus{}fusion}\PY{p}{(}\PY{n}{M}\PY{p}{)}
    \PY{n}{CUDA}\PY{o}{.}\PY{n+nd}{@sync} \PY{n}{M} \PY{o}{.*} \PY{n}{M} \PY{o}{.+} \PY{n}{M}
    \PY{k}{return}
\PY{k}{end}

\PY{n}{benchmark\PYZus{}with\PYZus{}fusion}\PY{p}{(}\PY{n}{M\PYZus{}on\PYZus{}gpu}\PY{p}{)} \PY{c}{\PYZsh{} warm up}

\PY{n+nd}{@BenchmarkTools}\PY{o}{.}\PY{n}{btime} \PY{n}{benchmark\PYZus{}with\PYZus{}fusion}\PY{p}{(}\PY{o}{\PYZdl{}}\PY{n}{M\PYZus{}on\PYZus{}gpu}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{gpu-coding}{%
\subsection{GPU coding}\label{gpu-coding}}

Julia allows you to write your own GPU operations!

Rather than using GPU operations implemented in the \texttt{CUDA.jl}
package (or others), you can write Julia code that will be compiled for
the GPU, and executed there.

This can be useful to speed up some algorithms where the standard
kernels do not suffice.

For example, here's a GPU kernel which implements \texttt{u\ .+=\ v},
where \texttt{u} and \texttt{v} are two (large) vectors:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{function} \PY{n}{worker\PYZus{}gpu\PYZus{}add!}\PY{p}{(}\PY{n}{u}\PY{p}{,} \PY{n}{v}\PY{p}{)}
    \PY{n}{index} \PY{o}{=} \PY{p}{(}\PY{n}{CUDA}\PY{o}{.}\PY{n}{blockIdx}\PY{p}{(}\PY{p}{)}\PY{o}{.}\PY{n}{x} \PY{o}{\PYZhy{}} \PY{l+m+mi}{1}\PY{p}{)} \PY{o}{*} \PY{n}{CUDA}\PY{o}{.}\PY{n}{blockDim}\PY{p}{(}\PY{p}{)}\PY{o}{.}\PY{n}{x} \PY{o}{+} \PY{n}{CUDA}\PY{o}{.}\PY{n}{threadIdx}\PY{p}{(}\PY{p}{)}\PY{o}{.}\PY{n}{x}
    \PY{n}{index} \PY{o}{≤} \PY{n}{length}\PY{p}{(}\PY{n}{u}\PY{p}{)} \PY{o}{\PYZam{}\PYZam{}} \PY{p}{(}\PY{n+nd}{@inbounds} \PY{n}{u}\PY{p}{[}\PY{n}{index}\PY{p}{]} \PY{o}{+=} \PY{n}{v}\PY{p}{[}\PY{n}{index}\PY{p}{]}\PY{p}{)}
    \PY{k}{return}
\PY{k}{end}

\PY{k}{function} \PY{n}{gpu\PYZus{}add!}\PY{p}{(}\PY{n}{u}\PY{p}{,} \PY{n}{v}\PY{p}{)}
    \PY{n}{numblocks} \PY{o}{=} \PY{n}{ceil}\PY{p}{(}\PY{k+kt}{Int}\PY{p}{,} \PY{n}{length}\PY{p}{(}\PY{n}{u}\PY{p}{)} \PY{o}{/} \PY{l+m+mi}{256}\PY{p}{)}
    \PY{n}{CUDA}\PY{o}{.}\PY{n+nd}{@cuda} \PY{n}{threads}\PY{o}{=}\PY{l+m+mi}{256} \PY{n}{blocks}\PY{o}{=}\PY{n}{numblocks} \PY{n}{worker\PYZus{}gpu\PYZus{}add!}\PY{p}{(}\PY{n}{u}\PY{p}{,} \PY{n}{v}\PY{p}{)}
    \PY{k}{return} \PY{n}{u}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    Important:

\begin{itemize}
\tightlist
\item
  The \texttt{gpu\_add!()} function first calculates \texttt{numblocks},
  the number of blocks of threads to start, then it uses the
  \texttt{CUDA.@cuda} macro to spawn \texttt{numblocks} blocks of 256
  GPU threads and each thread executeds
  \texttt{worker\_gpu\_add!(u,\ v)}.
\item
  The \texttt{worker\_gpu\_add!()} function computes
  \texttt{u{[}index{]}\ +=\ v{[}index{]}} for a single value of
  \texttt{index}: in other words, each thread will just update a single
  value in the vector!
\item
  The \texttt{CUDA.@cuda} macro spawns \texttt{numblocks} blocks of 256
  threads each. These blocks are organized in a grid, which is
  one-dimensional by default, but it can be up to three-dimensional.
  Therefore each thread and each block have an \texttt{(x,\ y,\ z)}
  coordinate in this grid. See this diagram from the
  \href{https://developer.nvidia.com/blog/even-easier-introduction-cuda/}{Nvidia
  blog post}: .
\item
  \texttt{CUDA.threadIdx().x} returns the current GPU thread's
  \texttt{x} coordinate within its block (one difference with the
  diagram is that Julia is 1-indexed).
\item
  \texttt{CUDA.blockIdx().x} returns the current block's \texttt{x}
  coordinate in the grid.
\item
  \texttt{CUDA.blockDim().x} returns the block size along the \texttt{x}
  axis (in this example, it's 256).
\item
  \texttt{CUDA.gridDim().x} returns the number of blocks in the grid,
  along the \texttt{x} axis (in this example it's \texttt{numblocks}).
\item
  So the \texttt{index} that each thread must update in the array is
  \texttt{(CUDA.blockIdx().x\ -\ 1)\ *\ CUDA.blockDim().x\ +\ CUDA.threadIdx().x}.
\item
  As explained earlier, the \texttt{@inbounds} macro is an optimization
  that tells Julia that the index is guaranteed to be inbounds, so
  there's no need for it to check.
\end{itemize}

Hopefully, now writing your own GPU kernel in Julia will not seem like
something only top experts with advanced C++ skills can do.

    Let's check that the kernel works as expected:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{u} \PY{o}{=} \PY{n}{rand}\PY{p}{(}\PY{l+m+mi}{2}\PY{o}{\PYZca{}}\PY{l+m+mi}{20}\PY{p}{)}
\PY{n}{v} \PY{o}{=} \PY{n}{rand}\PY{p}{(}\PY{l+m+mi}{2}\PY{o}{\PYZca{}}\PY{l+m+mi}{20}\PY{p}{)}

\PY{n}{u\PYZus{}on\PYZus{}gpu} \PY{o}{=} \PY{n}{CUDA}\PY{o}{.}\PY{n}{cu}\PY{p}{(}\PY{n}{u}\PY{p}{)}
\PY{n}{v\PYZus{}on\PYZus{}gpu} \PY{o}{=} \PY{n}{CUDA}\PY{o}{.}\PY{n}{cu}\PY{p}{(}\PY{n}{v}\PY{p}{)}

\PY{n}{u} \PY{o}{.+=} \PY{n}{v}

\PY{n}{gpu\PYZus{}add!}\PY{p}{(}\PY{n}{u\PYZus{}on\PYZus{}gpu}\PY{p}{,} \PY{n}{v\PYZus{}on\PYZus{}gpu}\PY{p}{)}

\PY{n+nd}{@assert} \PY{k+kt}{Array}\PY{p}{(}\PY{n}{u\PYZus{}on\PYZus{}gpu}\PY{p}{)} \PY{o}{≈} \PY{n}{u}
\end{Verbatim}
\end{tcolorbox}

    Note: the \texttt{≈} operator checks whether the operands are
approximately equal within the float precision limit.

    Let us benchmark the new custom kernel:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{function} \PY{n}{benchmark\PYZus{}custom\PYZus{}assign\PYZus{}add!}\PY{p}{(}\PY{n}{u}\PY{p}{,} \PY{n}{v}\PY{p}{)}
    \PY{n}{CUDA}\PY{o}{.}\PY{n+nd}{@sync} \PY{n}{gpu\PYZus{}add!}\PY{p}{(}\PY{n}{u}\PY{p}{,} \PY{n}{v}\PY{p}{)}
    \PY{k}{return} \PY{n+nb}{nothing}
\PY{k}{end}

\PY{n}{benchmark\PYZus{}custom\PYZus{}assign\PYZus{}add!}\PY{p}{(}\PY{n}{u\PYZus{}on\PYZus{}gpu}\PY{p}{,} \PY{n}{v\PYZus{}on\PYZus{}gpu}\PY{p}{)} \PY{c}{\PYZsh{} warm up}

\PY{n+nd}{@BenchmarkTools}\PY{o}{.}\PY{n}{btime} \PY{n}{benchmark\PYZus{}custom\PYZus{}assign\PYZus{}add!}\PY{p}{(}\PY{o}{\PYZdl{}}\PY{n}{u\PYZus{}on\PYZus{}gpu}\PY{p}{,} \PY{o}{\PYZdl{}}\PY{n}{v\PYZus{}on\PYZus{}gpu}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Let us see how this compares to \texttt{CUDA.jl}'s implementation:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{function} \PY{n}{benchmark\PYZus{}assign\PYZus{}add!}\PY{p}{(}\PY{n}{u}\PY{p}{,} \PY{n}{v}\PY{p}{)}
    \PY{n}{CUDA}\PY{o}{.}\PY{n+nd}{@sync} \PY{n}{u} \PY{o}{.+=} \PY{n}{v}
    \PY{k}{return} \PY{n+nb}{nothing}
\PY{k}{end}

\PY{n}{benchmark\PYZus{}assign\PYZus{}add!}\PY{p}{(}\PY{n}{u\PYZus{}on\PYZus{}gpu}\PY{p}{,} \PY{n}{v\PYZus{}on\PYZus{}gpu}\PY{p}{)} \PY{c}{\PYZsh{} warm up}

\PY{n+nd}{@BenchmarkTools}\PY{o}{.}\PY{n}{btime} \PY{n}{benchmark\PYZus{}assign\PYZus{}add!}\PY{p}{(}\PY{o}{\PYZdl{}}\PY{n}{u\PYZus{}on\PYZus{}gpu}\PY{p}{,} \PY{o}{\PYZdl{}}\PY{n}{v\PYZus{}on\PYZus{}gpu}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    The new custom kernel is just as fast as \texttt{CUDA.jl}'s kernel!

Howvever, the new kernel would not work with huge vectors!

This is because there is a limit to the number of blocks \& threads can
be spawned.

To support huge vectors, each worker needs to run a loop like this:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{function} \PY{n}{worker\PYZus{}gpu\PYZus{}add!}\PY{p}{(}\PY{n}{u}\PY{p}{,} \PY{n}{v}\PY{p}{)}
    \PY{n}{index} \PY{o}{=} \PY{p}{(}\PY{n}{CUDA}\PY{o}{.}\PY{n}{blockIdx}\PY{p}{(}\PY{p}{)}\PY{o}{.}\PY{n}{x} \PY{o}{\PYZhy{}} \PY{l+m+mi}{1}\PY{p}{)} \PY{o}{*} \PY{n}{CUDA}\PY{o}{.}\PY{n}{blockDim}\PY{p}{(}\PY{p}{)}\PY{o}{.}\PY{n}{x} \PY{o}{+} \PY{n}{CUDA}\PY{o}{.}\PY{n}{threadIdx}\PY{p}{(}\PY{p}{)}\PY{o}{.}\PY{n}{x}
    \PY{n}{stride} \PY{o}{=} \PY{n}{CUDA}\PY{o}{.}\PY{n}{blockDim}\PY{p}{(}\PY{p}{)}\PY{o}{.}\PY{n}{x} \PY{o}{*} \PY{n}{CUDA}\PY{o}{.}\PY{n}{gridDim}\PY{p}{(}\PY{p}{)}\PY{o}{.}\PY{n}{x}
    \PY{k}{for} \PY{n}{i} \PY{o}{=} \PY{n}{index}\PY{o}{:}\PY{n}{stride}\PY{l+s+ss}{:length}\PY{p}{(}\PY{n}{u}\PY{p}{)}
        \PY{n+nd}{@inbounds} \PY{n}{u}\PY{p}{[}\PY{n}{i}\PY{p}{]} \PY{o}{+=} \PY{n}{v}\PY{p}{[}\PY{n}{i}\PY{p}{]}
    \PY{k}{end}
    \PY{k}{return} \PY{n+nb}{nothing}
\PY{k}{end}
\end{Verbatim}
\end{tcolorbox}

    This way, if \texttt{CUDA.@cuda} is executed with a smaller number of
blocks than needed to have one thread per array item, the workers will
loop appropriately.

For more info, check out
\href{https://juliagpu.gitlab.io/CUDA.jl}{\texttt{CUDA.jl}'s
documentation}.


    % Add a bibliography block to the postdoc
    
    
    
\end{document}
